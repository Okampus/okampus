# whether this query should be cached (Hasura Cloud only)
directive @cached(
  # measured in seconds
  ttl: Int! = 60

  # refresh the cache entry
  refresh: Boolean! = false
) on QUERY

scalar _text

# Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
input _textComparisonExp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _isNull: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

# columns and relationships of "account"
type Account {
  # An array relationship
  accountAllocates(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # An aggregate relationship
  accountAllocatesAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!
  balance: Float!

  # An object relationship
  bankInfo: BankInfo
  bankInfoId: bigint
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  individual: Individual
  name: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "account"
type AccountAggregate {
  aggregate: AccountAggregateFields
  nodes: [Account!]!
}

input AccountAggregateBoolExp {
  count: accountAggregateBoolExpCount
}

input accountAggregateBoolExpCount {
  arguments: [AccountSelectColumn!]
  distinct: Boolean
  filter: AccountBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "account"
type AccountAggregateFields {
  avg: AccountAvgFields
  count(columns: [AccountSelectColumn!], distinct: Boolean): Int!
  max: AccountMaxFields
  min: AccountMinFields
  stddev: AccountStddevFields
  stddevPop: AccountStddevPopFields
  stddevSamp: AccountStddevSampFields
  sum: AccountSumFields
  varPop: AccountVarPopFields
  varSamp: AccountVarSampFields
  variance: AccountVarianceFields
}

# order by aggregate values of table "account"
input AccountAggregateOrderBy {
  avg: AccountAvgOrderBy
  count: OrderBy
  max: AccountMaxOrderBy
  min: AccountMinOrderBy
  stddev: AccountStddevOrderBy
  stddevPop: AccountStddevPopOrderBy
  stddevSamp: AccountStddevSampOrderBy
  sum: AccountSumOrderBy
  varPop: AccountVarPopOrderBy
  varSamp: AccountVarSampOrderBy
  variance: AccountVarianceOrderBy
}

# columns and relationships of "account_allocate"
type AccountAllocate {
  # An object relationship
  account: Account!
  accountId: bigint!
  balance: Float!
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  individual: Individual

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "account_allocate"
type AccountAllocateAggregate {
  aggregate: AccountAllocateAggregateFields
  nodes: [AccountAllocate!]!
}

input AccountAllocateAggregateBoolExp {
  count: accountAllocateAggregateBoolExpCount
}

input accountAllocateAggregateBoolExpCount {
  arguments: [AccountAllocateSelectColumn!]
  distinct: Boolean
  filter: AccountAllocateBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "account_allocate"
type AccountAllocateAggregateFields {
  avg: AccountAllocateAvgFields
  count(columns: [AccountAllocateSelectColumn!], distinct: Boolean): Int!
  max: AccountAllocateMaxFields
  min: AccountAllocateMinFields
  stddev: AccountAllocateStddevFields
  stddevPop: AccountAllocateStddevPopFields
  stddevSamp: AccountAllocateStddevSampFields
  sum: AccountAllocateSumFields
  varPop: AccountAllocateVarPopFields
  varSamp: AccountAllocateVarSampFields
  variance: AccountAllocateVarianceFields
}

# order by aggregate values of table "account_allocate"
input AccountAllocateAggregateOrderBy {
  avg: AccountAllocateAvgOrderBy
  count: OrderBy
  max: AccountAllocateMaxOrderBy
  min: AccountAllocateMinOrderBy
  stddev: AccountAllocateStddevOrderBy
  stddevPop: AccountAllocateStddevPopOrderBy
  stddevSamp: AccountAllocateStddevSampOrderBy
  sum: AccountAllocateSumOrderBy
  varPop: AccountAllocateVarPopOrderBy
  varSamp: AccountAllocateVarSampOrderBy
  variance: AccountAllocateVarianceOrderBy
}

# input type for inserting array relation for remote table "account_allocate"
input AccountAllocateArrRelInsertInput {
  data: [AccountAllocateInsertInput!]!

  # upsert condition
  onConflict: AccountAllocateOnConflict
}

# aggregate avg on columns
type AccountAllocateAvgFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "account_allocate"
input AccountAllocateAvgOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "account_allocate". All fields are combined with a logical 'AND'.
input AccountAllocateBoolExp {
  _and: [AccountAllocateBoolExp!]
  _not: AccountAllocateBoolExp
  _or: [AccountAllocateBoolExp!]
  account: AccountBoolExp
  accountId: BigintComparisonExp
  balance: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  individual: IndividualBoolExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "account_allocate"
enum AccountAllocateConstraint {
  # unique or primary key constraint on columns "id"
  account_allocate_pkey
}

# input type for incrementing numeric columns in table "account_allocate"
input AccountAllocateIncInput {
  accountId: bigint
  balance: Float
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "account_allocate"
input AccountAllocateInsertInput {
  account: AccountObjRelInsertInput
  accountId: bigint
  balance: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  individual: IndividualObjRelInsertInput
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type AccountAllocateMaxFields {
  accountId: bigint
  balance: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "account_allocate"
input AccountAllocateMaxOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type AccountAllocateMinFields {
  accountId: bigint
  balance: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "account_allocate"
input AccountAllocateMinOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "account_allocate"
type AccountAllocateMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [AccountAllocate!]!
}

# on_conflict condition type for table "account_allocate"
input AccountAllocateOnConflict {
  constraint: AccountAllocateConstraint!
  updateColumns: [AccountAllocateUpdateColumn!]! = []
  where: AccountAllocateBoolExp
}

# Ordering options when selecting data from "account_allocate".
input AccountAllocateOrderBy {
  account: AccountOrderBy
  accountId: OrderBy
  balance: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  individual: IndividualOrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: account_allocate
input AccountAllocatePkColumnsInput {
  id: bigint!
}

# select columns of table "account_allocate"
enum AccountAllocateSelectColumn {
  # column name
  accountId

  # column name
  balance

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "account_allocate"
input AccountAllocateSetInput {
  accountId: bigint
  balance: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type AccountAllocateStddevFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "account_allocate"
input AccountAllocateStddevOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type AccountAllocateStddevPopFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "account_allocate"
input AccountAllocateStddevPopOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type AccountAllocateStddevSampFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "account_allocate"
input AccountAllocateStddevSampOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "account_allocate"
input AccountAllocateStreamCursorInput {
  # Stream column input with initial value
  initialValue: AccountAllocateStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input AccountAllocateStreamCursorValueInput {
  accountId: bigint
  balance: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type AccountAllocateSumFields {
  accountId: bigint
  balance: Float
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "account_allocate"
input AccountAllocateSumOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "account_allocate"
enum AccountAllocateUpdateColumn {
  # column name
  accountId

  # column name
  balance

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

input AccountAllocateUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: AccountAllocateIncInput

  # sets the columns of the filtered rows to the given values
  _set: AccountAllocateSetInput

  # filter the rows which have to be updated
  where: AccountAllocateBoolExp!
}

# aggregate variance on columns
type AccountAllocateVarianceFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "account_allocate"
input AccountAllocateVarianceOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type AccountAllocateVarPopFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "account_allocate"
input AccountAllocateVarPopOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type AccountAllocateVarSampFields {
  accountId: Float
  balance: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "account_allocate"
input AccountAllocateVarSampOrderBy {
  accountId: OrderBy
  balance: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# input type for inserting array relation for remote table "account"
input AccountArrRelInsertInput {
  data: [AccountInsertInput!]!

  # upsert condition
  onConflict: AccountOnConflict
}

# aggregate avg on columns
type AccountAvgFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "account"
input AccountAvgOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
input AccountBoolExp {
  _and: [AccountBoolExp!]
  _not: AccountBoolExp
  _or: [AccountBoolExp!]
  accountAllocates: AccountAllocateBoolExp
  accountAllocatesAggregate: AccountAllocateAggregateBoolExp
  balance: FloatComparisonExp
  bankInfo: BankInfoBoolExp
  bankInfoId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  individual: IndividualBoolExp
  name: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "account"
enum AccountConstraint {
  # unique or primary key constraint on columns "id"
  account_pkey
}

# input type for incrementing numeric columns in table "account"
input AccountIncInput {
  balance: Float
  bankInfoId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "account"
input AccountInsertInput {
  accountAllocates: AccountAllocateArrRelInsertInput
  balance: Float
  bankInfo: BankInfoObjRelInsertInput
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  individual: IndividualObjRelInsertInput
  name: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type AccountMaxFields {
  balance: Float
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by max() on columns of table "account"
input AccountMaxOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type AccountMinFields {
  balance: Float
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by min() on columns of table "account"
input AccountMinOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "account"
type AccountMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Account!]!
}

# input type for inserting object relation for remote table "account"
input AccountObjRelInsertInput {
  data: AccountInsertInput!

  # upsert condition
  onConflict: AccountOnConflict
}

# on_conflict condition type for table "account"
input AccountOnConflict {
  constraint: AccountConstraint!
  updateColumns: [AccountUpdateColumn!]! = []
  where: AccountBoolExp
}

# Ordering options when selecting data from "account".
input AccountOrderBy {
  accountAllocatesAggregate: AccountAllocateAggregateOrderBy
  balance: OrderBy
  bankInfo: BankInfoOrderBy
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  individual: IndividualOrderBy
  name: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: account
input AccountPkColumnsInput {
  id: bigint!
}

# select columns of table "account"
enum AccountSelectColumn {
  # column name
  balance

  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "account"
input AccountSetInput {
  balance: Float
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type AccountStddevFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "account"
input AccountStddevOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type AccountStddevPopFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "account"
input AccountStddevPopOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type AccountStddevSampFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "account"
input AccountStddevSampOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "account"
input AccountStreamCursorInput {
  # Stream column input with initial value
  initialValue: AccountStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input AccountStreamCursorValueInput {
  balance: Float
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type AccountSumFields {
  balance: Float
  bankInfoId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "account"
input AccountSumOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "account"
enum AccountUpdateColumn {
  # column name
  balance

  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

input AccountUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: AccountIncInput

  # sets the columns of the filtered rows to the given values
  _set: AccountSetInput

  # filter the rows which have to be updated
  where: AccountBoolExp!
}

# aggregate variance on columns
type AccountVarianceFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "account"
input AccountVarianceOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type AccountVarPopFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "account"
input AccountVarPopOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type AccountVarSampFields {
  balance: Float
  bankInfoId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "account"
input AccountVarSampOrderBy {
  balance: OrderBy
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "action"
type Action {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  eventJoin: EventJoin
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  points: smallint
  pointsSettledAt: timestamptz

  # An object relationship
  pointsSettledBy: Individual
  pointsSettledById: bigint

  # An object relationship
  project: Project
  projectId: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "action"
type ActionAggregate {
  aggregate: ActionAggregateFields
  nodes: [Action!]!
}

input ActionAggregateBoolExp {
  count: actionAggregateBoolExpCount
}

input actionAggregateBoolExpCount {
  arguments: [ActionSelectColumn!]
  distinct: Boolean
  filter: ActionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "action"
type ActionAggregateFields {
  avg: ActionAvgFields
  count(columns: [ActionSelectColumn!], distinct: Boolean): Int!
  max: ActionMaxFields
  min: ActionMinFields
  stddev: ActionStddevFields
  stddevPop: ActionStddevPopFields
  stddevSamp: ActionStddevSampFields
  sum: ActionSumFields
  varPop: ActionVarPopFields
  varSamp: ActionVarSampFields
  variance: ActionVarianceFields
}

# order by aggregate values of table "action"
input ActionAggregateOrderBy {
  avg: ActionAvgOrderBy
  count: OrderBy
  max: ActionMaxOrderBy
  min: ActionMinOrderBy
  stddev: ActionStddevOrderBy
  stddevPop: ActionStddevPopOrderBy
  stddevSamp: ActionStddevSampOrderBy
  sum: ActionSumOrderBy
  varPop: ActionVarPopOrderBy
  varSamp: ActionVarSampOrderBy
  variance: ActionVarianceOrderBy
}

# input type for inserting array relation for remote table "action"
input ActionArrRelInsertInput {
  data: [ActionInsertInput!]!

  # upsert condition
  onConflict: ActionOnConflict
}

# aggregate avg on columns
type ActionAvgFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "action"
input ActionAvgOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
input ActionBoolExp {
  _and: [ActionBoolExp!]
  _not: ActionBoolExp
  _or: [ActionBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventJoin: EventJoinBoolExp
  eventJoinId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  points: SmallintComparisonExp
  pointsSettledAt: TimestamptzComparisonExp
  pointsSettledBy: IndividualBoolExp
  pointsSettledById: BigintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "action"
enum ActionConstraint {
  # unique or primary key constraint on columns "id"
  action_pkey
}

# input type for incrementing numeric columns in table "action"
input ActionIncInput {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  points: smallint
  pointsSettledById: bigint
  projectId: bigint
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "action"
input ActionInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoin: EventJoinObjRelInsertInput
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledBy: IndividualObjRelInsertInput
  pointsSettledById: bigint
  project: ProjectObjRelInsertInput
  projectId: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type ActionMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by max() on columns of table "action"
input ActionMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type ActionMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by min() on columns of table "action"
input ActionMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "action"
type ActionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Action!]!
}

# on_conflict condition type for table "action"
input ActionOnConflict {
  constraint: ActionConstraint!
  updateColumns: [ActionUpdateColumn!]! = []
  where: ActionBoolExp
}

# Ordering options when selecting data from "action".
input ActionOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoin: EventJoinOrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledBy: IndividualOrderBy
  pointsSettledById: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: action
input ActionPkColumnsInput {
  id: bigint!
}

# select columns of table "action"
enum ActionSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  points

  # column name
  pointsSettledAt

  # column name
  pointsSettledById

  # column name
  projectId

  # column name
  state

  # column name
  teamId

  # column name
  tenantId

  # column name
  userId
}

# input type for updating data in table "action"
input ActionSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# aggregate stddev on columns
type ActionStddevFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "action"
input ActionStddevOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type ActionStddevPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "action"
input ActionStddevPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type ActionStddevSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "action"
input ActionStddevSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "action"
input ActionStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActionStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# aggregate sum on columns
type ActionSumFields {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  points: smallint
  pointsSettledById: bigint
  projectId: bigint
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "action"
input ActionSumOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "action"
enum ActionUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  points

  # column name
  pointsSettledAt

  # column name
  pointsSettledById

  # column name
  projectId

  # column name
  state

  # column name
  teamId

  # column name
  tenantId

  # column name
  userId
}

input ActionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActionIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActionSetInput

  # filter the rows which have to be updated
  where: ActionBoolExp!
}

# aggregate variance on columns
type ActionVarianceFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "action"
input ActionVarianceOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type ActionVarPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "action"
input ActionVarPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type ActionVarSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "action"
input ActionVarSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# columns and relationships of "actor"
type Actor {
  # An array relationship
  actorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  actorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): [ActorTags!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): ActorTagsAggregate!

  # An array relationship
  addresses(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # An aggregate relationship
  addressesAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!
  bio: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  email: String!

  # An array relationship
  favorites(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # An aggregate relationship
  favoritesAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!

  # An array relationship
  followers(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followersAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!
  hiddenAt: timestamptz
  ical: String!
  id: bigint!

  # An object relationship
  individual: Individual
  individualId: bigint

  # An object relationship
  legalUnit: LegalUnit
  legalUnitId: bigint
  name: String!

  # An array relationship
  ownedBots(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # An aggregate relationship
  ownedBotsAggregate(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): BotAggregate!

  # An array relationship
  payedFinances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  payedFinancesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  receivedFinances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  receivedFinancesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  reports(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # An aggregate relationship
  reportsAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # An array relationship
  shortcuts(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # An aggregate relationship
  shortcutsAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!
  slug: String!

  # An array relationship
  socials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  socialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!
  status: String!

  # An object relationship
  team: Team
  teamId: bigint

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  website: String!
}

# aggregated selection of "actor"
type ActorAggregate {
  aggregate: ActorAggregateFields
  nodes: [Actor!]!
}

input ActorAggregateBoolExp {
  count: actorAggregateBoolExpCount
}

input actorAggregateBoolExpCount {
  arguments: [ActorSelectColumn!]
  distinct: Boolean
  filter: ActorBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor"
type ActorAggregateFields {
  avg: ActorAvgFields
  count(columns: [ActorSelectColumn!], distinct: Boolean): Int!
  max: ActorMaxFields
  min: ActorMinFields
  stddev: ActorStddevFields
  stddevPop: ActorStddevPopFields
  stddevSamp: ActorStddevSampFields
  sum: ActorSumFields
  varPop: ActorVarPopFields
  varSamp: ActorVarSampFields
  variance: ActorVarianceFields
}

# order by aggregate values of table "actor"
input ActorAggregateOrderBy {
  avg: ActorAvgOrderBy
  count: OrderBy
  max: ActorMaxOrderBy
  min: ActorMinOrderBy
  stddev: ActorStddevOrderBy
  stddevPop: ActorStddevPopOrderBy
  stddevSamp: ActorStddevSampOrderBy
  sum: ActorSumOrderBy
  varPop: ActorVarPopOrderBy
  varSamp: ActorVarSampOrderBy
  variance: ActorVarianceOrderBy
}

# input type for inserting array relation for remote table "actor"
input ActorArrRelInsertInput {
  data: [ActorInsertInput!]!

  # upsert condition
  onConflict: ActorOnConflict
}

# aggregate avg on columns
type ActorAvgFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "actor"
input ActorAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "actor". All fields are combined with a logical 'AND'.
input ActorBoolExp {
  _and: [ActorBoolExp!]
  _not: ActorBoolExp
  _or: [ActorBoolExp!]
  actorImages: ActorImageBoolExp
  actorImagesAggregate: ActorImageAggregateBoolExp
  actorTags: ActorTagsBoolExp
  actorTagsAggregate: ActorTagsAggregateBoolExp
  addresses: AddressBoolExp
  addressesAggregate: AddressAggregateBoolExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  bio: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  email: StringComparisonExp
  favorites: FavoriteBoolExp
  favoritesAggregate: FavoriteAggregateBoolExp
  followers: FollowBoolExp
  followersAggregate: FollowAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  ical: StringComparisonExp
  id: BigintComparisonExp
  individual: IndividualBoolExp
  individualId: BigintComparisonExp
  legalUnit: LegalUnitBoolExp
  legalUnitId: BigintComparisonExp
  name: StringComparisonExp
  ownedBots: BotBoolExp
  ownedBotsAggregate: BotAggregateBoolExp
  payedFinances: FinanceBoolExp
  payedFinancesAggregate: FinanceAggregateBoolExp
  receivedFinances: FinanceBoolExp
  receivedFinancesAggregate: FinanceAggregateBoolExp
  reports: ReportBoolExp
  reportsAggregate: ReportAggregateBoolExp
  shortcuts: ShortcutBoolExp
  shortcutsAggregate: ShortcutAggregateBoolExp
  slug: StringComparisonExp
  socials: SocialBoolExp
  socialsAggregate: SocialAggregateBoolExp
  status: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  website: StringComparisonExp
}

# unique or primary key constraints on table "actor"
enum ActorConstraint {
  # unique or primary key constraint on columns "ical"
  actor_ical_unique

  # unique or primary key constraint on columns "individual_id"
  actor_individual_id_unique

  # unique or primary key constraint on columns "legal_unit_id"
  actor_legal_unit_id_unique

  # unique or primary key constraint on columns "id"
  actor_pkey

  # unique or primary key constraint on columns "team_id"
  actor_team_id_unique
}

# columns and relationships of "actor_image"
type ActorImage {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  image: FileUpload!
  imageId: bigint!
  lastActiveDate: timestamptz

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "actor_image"
type ActorImageAggregate {
  aggregate: ActorImageAggregateFields
  nodes: [ActorImage!]!
}

input ActorImageAggregateBoolExp {
  count: actorImageAggregateBoolExpCount
}

input actorImageAggregateBoolExpCount {
  arguments: [ActorImageSelectColumn!]
  distinct: Boolean
  filter: ActorImageBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor_image"
type ActorImageAggregateFields {
  avg: ActorImageAvgFields
  count(columns: [ActorImageSelectColumn!], distinct: Boolean): Int!
  max: ActorImageMaxFields
  min: ActorImageMinFields
  stddev: ActorImageStddevFields
  stddevPop: ActorImageStddevPopFields
  stddevSamp: ActorImageStddevSampFields
  sum: ActorImageSumFields
  varPop: ActorImageVarPopFields
  varSamp: ActorImageVarSampFields
  variance: ActorImageVarianceFields
}

# order by aggregate values of table "actor_image"
input ActorImageAggregateOrderBy {
  avg: ActorImageAvgOrderBy
  count: OrderBy
  max: ActorImageMaxOrderBy
  min: ActorImageMinOrderBy
  stddev: ActorImageStddevOrderBy
  stddevPop: ActorImageStddevPopOrderBy
  stddevSamp: ActorImageStddevSampOrderBy
  sum: ActorImageSumOrderBy
  varPop: ActorImageVarPopOrderBy
  varSamp: ActorImageVarSampOrderBy
  variance: ActorImageVarianceOrderBy
}

# input type for inserting array relation for remote table "actor_image"
input ActorImageArrRelInsertInput {
  data: [ActorImageInsertInput!]!

  # upsert condition
  onConflict: ActorImageOnConflict
}

# aggregate avg on columns
type ActorImageAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by avg() on columns of table "actor_image"
input ActorImageAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "actor_image". All fields are combined with a logical 'AND'.
input ActorImageBoolExp {
  _and: [ActorImageBoolExp!]
  _not: ActorImageBoolExp
  _or: [ActorImageBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  image: FileUploadBoolExp
  imageId: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "actor_image"
enum ActorImageConstraint {
  # unique or primary key constraint on columns "image_id"
  actor_image_image_id_unique

  # unique or primary key constraint on columns "id"
  actor_image_pkey
}

# input type for incrementing numeric columns in table "actor_image"
input ActorImageIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantId: bigint
}

# input type for inserting data into table "actor_image"
input ActorImageInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  image: FileUploadObjRelInsertInput
  imageId: bigint
  lastActiveDate: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type ActorImageMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# order by max() on columns of table "actor_image"
input ActorImageMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ActorImageMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# order by min() on columns of table "actor_image"
input ActorImageMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "actor_image"
type ActorImageMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ActorImage!]!
}

# input type for inserting object relation for remote table "actor_image"
input ActorImageObjRelInsertInput {
  data: ActorImageInsertInput!

  # upsert condition
  onConflict: ActorImageOnConflict
}

# on_conflict condition type for table "actor_image"
input ActorImageOnConflict {
  constraint: ActorImageConstraint!
  updateColumns: [ActorImageUpdateColumn!]! = []
  where: ActorImageBoolExp
}

# Ordering options when selecting data from "actor_image".
input ActorImageOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  image: FileUploadOrderBy
  imageId: OrderBy
  lastActiveDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: actor_image
input ActorImagePkColumnsInput {
  id: bigint!
}

# select columns of table "actor_image"
enum ActorImageSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "actor_image"
input ActorImageSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type ActorImageStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddev() on columns of table "actor_image"
input ActorImageStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ActorImageStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "actor_image"
input ActorImageStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ActorImageStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "actor_image"
input ActorImageStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "actor_image"
input ActorImageStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorImageStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorImageStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type ActorImageSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "actor_image"
input ActorImageSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# update columns of table "actor_image"
enum ActorImageUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  type
}

input ActorImageUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorImageIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorImageSetInput

  # filter the rows which have to be updated
  where: ActorImageBoolExp!
}

# aggregate variance on columns
type ActorImageVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by variance() on columns of table "actor_image"
input ActorImageVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ActorImageVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by varPop() on columns of table "actor_image"
input ActorImageVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ActorImageVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "actor_image"
input ActorImageVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# input type for incrementing numeric columns in table "actor"
input ActorIncInput {
  createdById: bigint
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "actor"
input ActorInsertInput {
  actorImages: ActorImageArrRelInsertInput
  actorTags: ActorTagsArrRelInsertInput
  addresses: AddressArrRelInsertInput
  bankInfos: BankInfoArrRelInsertInput
  bio: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  email: String
  favorites: FavoriteArrRelInsertInput
  followers: FollowArrRelInsertInput
  hiddenAt: timestamptz
  ical: String
  id: bigint
  individual: IndividualObjRelInsertInput
  individualId: bigint
  legalUnit: LegalUnitObjRelInsertInput
  legalUnitId: bigint
  name: String
  ownedBots: BotArrRelInsertInput
  payedFinances: FinanceArrRelInsertInput
  receivedFinances: FinanceArrRelInsertInput
  reports: ReportArrRelInsertInput
  shortcuts: ShortcutArrRelInsertInput
  slug: String
  socials: SocialArrRelInsertInput
  status: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  website: String
}

# aggregate max on columns
type ActorMaxFields {
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  hiddenAt: timestamptz
  ical: String
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  name: String
  slug: String
  status: String
  teamId: bigint
  tenantId: bigint
  website: String
}

# order by max() on columns of table "actor"
input ActorMaxOrderBy {
  bio: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  hiddenAt: OrderBy
  ical: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  name: OrderBy
  slug: OrderBy
  status: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  website: OrderBy
}

# aggregate min on columns
type ActorMinFields {
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  hiddenAt: timestamptz
  ical: String
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  name: String
  slug: String
  status: String
  teamId: bigint
  tenantId: bigint
  website: String
}

# order by min() on columns of table "actor"
input ActorMinOrderBy {
  bio: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  hiddenAt: OrderBy
  ical: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  name: OrderBy
  slug: OrderBy
  status: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  website: OrderBy
}

# response of any mutation on the table "actor"
type ActorMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Actor!]!
}

# input type for inserting object relation for remote table "actor"
input ActorObjRelInsertInput {
  data: ActorInsertInput!

  # upsert condition
  onConflict: ActorOnConflict
}

# on_conflict condition type for table "actor"
input ActorOnConflict {
  constraint: ActorConstraint!
  updateColumns: [ActorUpdateColumn!]! = []
  where: ActorBoolExp
}

# Ordering options when selecting data from "actor".
input ActorOrderBy {
  actorImagesAggregate: ActorImageAggregateOrderBy
  actorTagsAggregate: ActorTagsAggregateOrderBy
  addressesAggregate: AddressAggregateOrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  bio: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  favoritesAggregate: FavoriteAggregateOrderBy
  followersAggregate: FollowAggregateOrderBy
  hiddenAt: OrderBy
  ical: OrderBy
  id: OrderBy
  individual: IndividualOrderBy
  individualId: OrderBy
  legalUnit: LegalUnitOrderBy
  legalUnitId: OrderBy
  name: OrderBy
  ownedBotsAggregate: BotAggregateOrderBy
  payedFinancesAggregate: FinanceAggregateOrderBy
  receivedFinancesAggregate: FinanceAggregateOrderBy
  reportsAggregate: ReportAggregateOrderBy
  shortcutsAggregate: ShortcutAggregateOrderBy
  slug: OrderBy
  socialsAggregate: SocialAggregateOrderBy
  status: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  website: OrderBy
}

# primary key columns input for table: actor
input ActorPkColumnsInput {
  id: bigint!
}

# select columns of table "actor"
enum ActorSelectColumn {
  # column name
  bio

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  email

  # column name
  hiddenAt

  # column name
  ical

  # column name
  id

  # column name
  individualId

  # column name
  legalUnitId

  # column name
  name

  # column name
  slug

  # column name
  status

  # column name
  teamId

  # column name
  tenantId

  # column name
  website
}

# input type for updating data in table "actor"
input ActorSetInput {
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  hiddenAt: timestamptz
  ical: String
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  name: String
  slug: String
  status: String
  teamId: bigint
  tenantId: bigint
  website: String
}

# aggregate stddev on columns
type ActorStddevFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "actor"
input ActorStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ActorStddevPopFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "actor"
input ActorStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ActorStddevSampFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "actor"
input ActorStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "actor"
input ActorStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorStreamCursorValueInput {
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  hiddenAt: timestamptz
  ical: String
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  name: String
  slug: String
  status: String
  teamId: bigint
  tenantId: bigint
  website: String
}

# aggregate sum on columns
type ActorSumFields {
  createdById: bigint
  id: bigint
  individualId: bigint
  legalUnitId: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "actor"
input ActorSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "actor_tags"
type ActorTags {
  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An object relationship
  tag: Tag!
  tagId: bigint!
}

# aggregated selection of "actor_tags"
type ActorTagsAggregate {
  aggregate: ActorTagsAggregateFields
  nodes: [ActorTags!]!
}

input ActorTagsAggregateBoolExp {
  count: actorTagsAggregateBoolExpCount
}

input actorTagsAggregateBoolExpCount {
  arguments: [ActorTagsSelectColumn!]
  distinct: Boolean
  filter: ActorTagsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor_tags"
type ActorTagsAggregateFields {
  avg: ActorTagsAvgFields
  count(columns: [ActorTagsSelectColumn!], distinct: Boolean): Int!
  max: ActorTagsMaxFields
  min: ActorTagsMinFields
  stddev: ActorTagsStddevFields
  stddevPop: ActorTagsStddevPopFields
  stddevSamp: ActorTagsStddevSampFields
  sum: ActorTagsSumFields
  varPop: ActorTagsVarPopFields
  varSamp: ActorTagsVarSampFields
  variance: ActorTagsVarianceFields
}

# order by aggregate values of table "actor_tags"
input ActorTagsAggregateOrderBy {
  avg: ActorTagsAvgOrderBy
  count: OrderBy
  max: ActorTagsMaxOrderBy
  min: ActorTagsMinOrderBy
  stddev: ActorTagsStddevOrderBy
  stddevPop: ActorTagsStddevPopOrderBy
  stddevSamp: ActorTagsStddevSampOrderBy
  sum: ActorTagsSumOrderBy
  varPop: ActorTagsVarPopOrderBy
  varSamp: ActorTagsVarSampOrderBy
  variance: ActorTagsVarianceOrderBy
}

# input type for inserting array relation for remote table "actor_tags"
input ActorTagsArrRelInsertInput {
  data: [ActorTagsInsertInput!]!

  # upsert condition
  onConflict: ActorTagsOnConflict
}

# aggregate avg on columns
type ActorTagsAvgFields {
  actorId: Float
  tagId: Float
}

# order by avg() on columns of table "actor_tags"
input ActorTagsAvgOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# Boolean expression to filter rows from the table "actor_tags". All fields are combined with a logical 'AND'.
input ActorTagsBoolExp {
  _and: [ActorTagsBoolExp!]
  _not: ActorTagsBoolExp
  _or: [ActorTagsBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  tag: TagBoolExp
  tagId: BigintComparisonExp
}

# unique or primary key constraints on table "actor_tags"
enum ActorTagsConstraint {
  # unique or primary key constraint on columns "tag_id", "actor_id"
  actor_tags_pkey
}

# input type for incrementing numeric columns in table "actor_tags"
input ActorTagsIncInput {
  actorId: bigint
  tagId: bigint
}

# input type for inserting data into table "actor_tags"
input ActorTagsInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  tag: TagObjRelInsertInput
  tagId: bigint
}

# aggregate max on columns
type ActorTagsMaxFields {
  actorId: bigint
  tagId: bigint
}

# order by max() on columns of table "actor_tags"
input ActorTagsMaxOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# aggregate min on columns
type ActorTagsMinFields {
  actorId: bigint
  tagId: bigint
}

# order by min() on columns of table "actor_tags"
input ActorTagsMinOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# response of any mutation on the table "actor_tags"
type ActorTagsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ActorTags!]!
}

# on_conflict condition type for table "actor_tags"
input ActorTagsOnConflict {
  constraint: ActorTagsConstraint!
  updateColumns: [ActorTagsUpdateColumn!]! = []
  where: ActorTagsBoolExp
}

# Ordering options when selecting data from "actor_tags".
input ActorTagsOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
}

# primary key columns input for table: actor_tags
input ActorTagsPkColumnsInput {
  actorId: bigint!
  tagId: bigint!
}

# select columns of table "actor_tags"
enum ActorTagsSelectColumn {
  # column name
  actorId

  # column name
  tagId
}

# input type for updating data in table "actor_tags"
input ActorTagsSetInput {
  actorId: bigint
  tagId: bigint
}

# aggregate stddev on columns
type ActorTagsStddevFields {
  actorId: Float
  tagId: Float
}

# order by stddev() on columns of table "actor_tags"
input ActorTagsStddevOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# aggregate stddevPop on columns
type ActorTagsStddevPopFields {
  actorId: Float
  tagId: Float
}

# order by stddevPop() on columns of table "actor_tags"
input ActorTagsStddevPopOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# aggregate stddevSamp on columns
type ActorTagsStddevSampFields {
  actorId: Float
  tagId: Float
}

# order by stddevSamp() on columns of table "actor_tags"
input ActorTagsStddevSampOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# Streaming cursor of the table "actor_tags"
input ActorTagsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorTagsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorTagsStreamCursorValueInput {
  actorId: bigint
  tagId: bigint
}

# aggregate sum on columns
type ActorTagsSumFields {
  actorId: bigint
  tagId: bigint
}

# order by sum() on columns of table "actor_tags"
input ActorTagsSumOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# update columns of table "actor_tags"
enum ActorTagsUpdateColumn {
  # column name
  actorId

  # column name
  tagId
}

input ActorTagsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorTagsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorTagsSetInput

  # filter the rows which have to be updated
  where: ActorTagsBoolExp!
}

# aggregate variance on columns
type ActorTagsVarianceFields {
  actorId: Float
  tagId: Float
}

# order by variance() on columns of table "actor_tags"
input ActorTagsVarianceOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# aggregate varPop on columns
type ActorTagsVarPopFields {
  actorId: Float
  tagId: Float
}

# order by varPop() on columns of table "actor_tags"
input ActorTagsVarPopOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# aggregate varSamp on columns
type ActorTagsVarSampFields {
  actorId: Float
  tagId: Float
}

# order by varSamp() on columns of table "actor_tags"
input ActorTagsVarSampOrderBy {
  actorId: OrderBy
  tagId: OrderBy
}

# update columns of table "actor"
enum ActorUpdateColumn {
  # column name
  bio

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  email

  # column name
  hiddenAt

  # column name
  ical

  # column name
  id

  # column name
  individualId

  # column name
  legalUnitId

  # column name
  name

  # column name
  slug

  # column name
  status

  # column name
  teamId

  # column name
  tenantId

  # column name
  website
}

input ActorUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorSetInput

  # filter the rows which have to be updated
  where: ActorBoolExp!
}

# aggregate variance on columns
type ActorVarianceFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "actor"
input ActorVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ActorVarPopFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "actor"
input ActorVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ActorVarSampFields {
  createdById: Float
  id: Float
  individualId: Float
  legalUnitId: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "actor"
input ActorVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  individualId: OrderBy
  legalUnitId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "address"
type Address {
  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # An object relationship
  campus: Campus

  # An array relationship
  campusClusters(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # An aggregate relationship
  campusClustersAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!
  campusId: bigint
  city: String!
  country: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  finances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  financesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  image: FileUpload
  imageId: bigint
  isPublic: Boolean!
  latitude: Float
  longitude: Float
  name: String!
  state: String!
  street: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  zip: String!
}

# aggregated selection of "address"
type AddressAggregate {
  aggregate: AddressAggregateFields
  nodes: [Address!]!
}

input AddressAggregateBoolExp {
  bool_and: addressAggregateBoolExpBool_and
  bool_or: addressAggregateBoolExpBool_or
  count: addressAggregateBoolExpCount
}

input addressAggregateBoolExpBool_and {
  arguments: AddressSelectColumnAddressAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: AddressBoolExp
  predicate: BooleanComparisonExp!
}

input addressAggregateBoolExpBool_or {
  arguments: AddressSelectColumnAddressAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: AddressBoolExp
  predicate: BooleanComparisonExp!
}

input addressAggregateBoolExpCount {
  arguments: [AddressSelectColumn!]
  distinct: Boolean
  filter: AddressBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "address"
type AddressAggregateFields {
  avg: AddressAvgFields
  count(columns: [AddressSelectColumn!], distinct: Boolean): Int!
  max: AddressMaxFields
  min: AddressMinFields
  stddev: AddressStddevFields
  stddevPop: AddressStddevPopFields
  stddevSamp: AddressStddevSampFields
  sum: AddressSumFields
  varPop: AddressVarPopFields
  varSamp: AddressVarSampFields
  variance: AddressVarianceFields
}

# order by aggregate values of table "address"
input AddressAggregateOrderBy {
  avg: AddressAvgOrderBy
  count: OrderBy
  max: AddressMaxOrderBy
  min: AddressMinOrderBy
  stddev: AddressStddevOrderBy
  stddevPop: AddressStddevPopOrderBy
  stddevSamp: AddressStddevSampOrderBy
  sum: AddressSumOrderBy
  varPop: AddressVarPopOrderBy
  varSamp: AddressVarSampOrderBy
  variance: AddressVarianceOrderBy
}

# input type for inserting array relation for remote table "address"
input AddressArrRelInsertInput {
  data: [AddressInsertInput!]!

  # upsert condition
  onConflict: AddressOnConflict
}

# aggregate avg on columns
type AddressAvgFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by avg() on columns of table "address"
input AddressAvgOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'.
input AddressBoolExp {
  _and: [AddressBoolExp!]
  _not: AddressBoolExp
  _or: [AddressBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  campus: CampusBoolExp
  campusClusters: CampusClusterBoolExp
  campusClustersAggregate: CampusClusterAggregateBoolExp
  campusId: BigintComparisonExp
  city: StringComparisonExp
  country: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  finances: FinanceBoolExp
  financesAggregate: FinanceAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  image: FileUploadBoolExp
  imageId: BigintComparisonExp
  isPublic: BooleanComparisonExp
  latitude: FloatComparisonExp
  longitude: FloatComparisonExp
  name: StringComparisonExp
  state: StringComparisonExp
  street: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  zip: StringComparisonExp
}

# unique or primary key constraints on table "address"
enum AddressConstraint {
  # unique or primary key constraint on columns "campus_id"
  address_campus_id_unique

  # unique or primary key constraint on columns "image_id"
  address_image_id_unique

  # unique or primary key constraint on columns "id"
  address_pkey
}

# input type for incrementing numeric columns in table "address"
input AddressIncInput {
  actorId: bigint
  campusId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  latitude: Float
  longitude: Float
  tenantId: bigint
}

# input type for inserting data into table "address"
input AddressInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  bankInfos: BankInfoArrRelInsertInput
  campus: CampusObjRelInsertInput
  campusClusters: CampusClusterArrRelInsertInput
  campusId: bigint
  city: String
  country: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  events: EventArrRelInsertInput
  expenseItems: ExpenseItemArrRelInsertInput
  finances: FinanceArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  image: FileUploadObjRelInsertInput
  imageId: bigint
  isPublic: Boolean
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  zip: String
}

# aggregate max on columns
type AddressMaxFields {
  actorId: bigint
  campusId: bigint
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  tenantId: bigint
  zip: String
}

# order by max() on columns of table "address"
input AddressMaxOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  tenantId: OrderBy
  zip: OrderBy
}

# aggregate min on columns
type AddressMinFields {
  actorId: bigint
  campusId: bigint
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  tenantId: bigint
  zip: String
}

# order by min() on columns of table "address"
input AddressMinOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  tenantId: OrderBy
  zip: OrderBy
}

# response of any mutation on the table "address"
type AddressMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Address!]!
}

# input type for inserting object relation for remote table "address"
input AddressObjRelInsertInput {
  data: AddressInsertInput!

  # upsert condition
  onConflict: AddressOnConflict
}

# on_conflict condition type for table "address"
input AddressOnConflict {
  constraint: AddressConstraint!
  updateColumns: [AddressUpdateColumn!]! = []
  where: AddressBoolExp
}

# Ordering options when selecting data from "address".
input AddressOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  campus: CampusOrderBy
  campusClustersAggregate: CampusClusterAggregateOrderBy
  campusId: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventsAggregate: EventAggregateOrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  financesAggregate: FinanceAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  image: FileUploadOrderBy
  imageId: OrderBy
  isPublic: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  zip: OrderBy
}

# primary key columns input for table: address
input AddressPkColumnsInput {
  id: bigint!
}

# select columns of table "address"
enum AddressSelectColumn {
  # column name
  actorId

  # column name
  campusId

  # column name
  city

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  isPublic

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  state

  # column name
  street

  # column name
  tenantId

  # column name
  zip
}

# select "addressAggregateBoolExpBool_andArgumentsColumns" columns of table "address"
enum AddressSelectColumnAddressAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isPublic
}

# select "addressAggregateBoolExpBool_orArgumentsColumns" columns of table "address"
enum AddressSelectColumnAddressAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isPublic
}

# input type for updating data in table "address"
input AddressSetInput {
  actorId: bigint
  campusId: bigint
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  isPublic: Boolean
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  tenantId: bigint
  zip: String
}

# aggregate stddev on columns
type AddressStddevFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by stddev() on columns of table "address"
input AddressStddevOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type AddressStddevPopFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "address"
input AddressStddevPopOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type AddressStddevSampFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "address"
input AddressStddevSampOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "address"
input AddressStreamCursorInput {
  # Stream column input with initial value
  initialValue: AddressStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input AddressStreamCursorValueInput {
  actorId: bigint
  campusId: bigint
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  isPublic: Boolean
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  tenantId: bigint
  zip: String
}

# aggregate sum on columns
type AddressSumFields {
  actorId: bigint
  campusId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  latitude: Float
  longitude: Float
  tenantId: bigint
}

# order by sum() on columns of table "address"
input AddressSumOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# update columns of table "address"
enum AddressUpdateColumn {
  # column name
  actorId

  # column name
  campusId

  # column name
  city

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  isPublic

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  state

  # column name
  street

  # column name
  tenantId

  # column name
  zip
}

input AddressUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: AddressIncInput

  # sets the columns of the filtered rows to the given values
  _set: AddressSetInput

  # filter the rows which have to be updated
  where: AddressBoolExp!
}

# aggregate variance on columns
type AddressVarianceFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by variance() on columns of table "address"
input AddressVarianceOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type AddressVarPopFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by varPop() on columns of table "address"
input AddressVarPopOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type AddressVarSampFields {
  actorId: Float
  campusId: Float
  createdById: Float
  id: Float
  imageId: Float
  latitude: Float
  longitude: Float
  tenantId: Float
}

# order by varSamp() on columns of table "address"
input AddressVarSampOrderBy {
  actorId: OrderBy
  campusId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "bank_info"
type BankInfo {
  accountCode: String!

  # An array relationship
  accounts(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # An aggregate relationship
  accountsAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An object relationship
  address: Address!
  addressId: bigint!
  agencyCode: String!

  # An object relationship
  bank: LegalUnit
  bankCode: String!
  bankCodeBic: String!
  bankId: bigint
  checksum: String!
  country: String!
  countryCode: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!
  fullAcount: String!
  hiddenAt: timestamptz
  holderName: String!
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "bank_info"
type BankInfoAggregate {
  aggregate: BankInfoAggregateFields
  nodes: [BankInfo!]!
}

input BankInfoAggregateBoolExp {
  count: bankInfoAggregateBoolExpCount
}

input bankInfoAggregateBoolExpCount {
  arguments: [BankInfoSelectColumn!]
  distinct: Boolean
  filter: BankInfoBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "bank_info"
type BankInfoAggregateFields {
  avg: BankInfoAvgFields
  count(columns: [BankInfoSelectColumn!], distinct: Boolean): Int!
  max: BankInfoMaxFields
  min: BankInfoMinFields
  stddev: BankInfoStddevFields
  stddevPop: BankInfoStddevPopFields
  stddevSamp: BankInfoStddevSampFields
  sum: BankInfoSumFields
  varPop: BankInfoVarPopFields
  varSamp: BankInfoVarSampFields
  variance: BankInfoVarianceFields
}

# order by aggregate values of table "bank_info"
input BankInfoAggregateOrderBy {
  avg: BankInfoAvgOrderBy
  count: OrderBy
  max: BankInfoMaxOrderBy
  min: BankInfoMinOrderBy
  stddev: BankInfoStddevOrderBy
  stddevPop: BankInfoStddevPopOrderBy
  stddevSamp: BankInfoStddevSampOrderBy
  sum: BankInfoSumOrderBy
  varPop: BankInfoVarPopOrderBy
  varSamp: BankInfoVarSampOrderBy
  variance: BankInfoVarianceOrderBy
}

# input type for inserting array relation for remote table "bank_info"
input BankInfoArrRelInsertInput {
  data: [BankInfoInsertInput!]!

  # upsert condition
  onConflict: BankInfoOnConflict
}

# aggregate avg on columns
type BankInfoAvgFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "bank_info"
input BankInfoAvgOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "bank_info". All fields are combined with a logical 'AND'.
input BankInfoBoolExp {
  _and: [BankInfoBoolExp!]
  _not: BankInfoBoolExp
  _or: [BankInfoBoolExp!]
  accountCode: StringComparisonExp
  accounts: AccountBoolExp
  accountsAggregate: AccountAggregateBoolExp
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  address: AddressBoolExp
  addressId: BigintComparisonExp
  agencyCode: StringComparisonExp
  bank: LegalUnitBoolExp
  bankCode: StringComparisonExp
  bankCodeBic: StringComparisonExp
  bankId: BigintComparisonExp
  checksum: StringComparisonExp
  country: StringComparisonExp
  countryCode: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  fullAcount: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  holderName: StringComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "bank_info"
enum BankInfoConstraint {
  # unique or primary key constraint on columns "id"
  bank_info_pkey
}

# input type for incrementing numeric columns in table "bank_info"
input BankInfoIncInput {
  actorId: bigint
  addressId: bigint
  bankId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "bank_info"
input BankInfoInsertInput {
  accountCode: String
  accounts: AccountArrRelInsertInput
  actor: ActorObjRelInsertInput
  actorId: bigint
  address: AddressObjRelInsertInput
  addressId: bigint
  agencyCode: String
  bank: LegalUnitObjRelInsertInput
  bankCode: String
  bankCodeBic: String
  bankId: bigint
  checksum: String
  country: String
  countryCode: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  expenses: ExpenseArrRelInsertInput
  fullAcount: String
  hiddenAt: timestamptz
  holderName: String
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type BankInfoMaxFields {
  accountCode: String
  actorId: bigint
  addressId: bigint
  agencyCode: String
  bankCode: String
  bankCodeBic: String
  bankId: bigint
  checksum: String
  country: String
  countryCode: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fullAcount: String
  hiddenAt: timestamptz
  holderName: String
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "bank_info"
input BankInfoMaxOrderBy {
  accountCode: OrderBy
  actorId: OrderBy
  addressId: OrderBy
  agencyCode: OrderBy
  bankCode: OrderBy
  bankCodeBic: OrderBy
  bankId: OrderBy
  checksum: OrderBy
  country: OrderBy
  countryCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fullAcount: OrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type BankInfoMinFields {
  accountCode: String
  actorId: bigint
  addressId: bigint
  agencyCode: String
  bankCode: String
  bankCodeBic: String
  bankId: bigint
  checksum: String
  country: String
  countryCode: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fullAcount: String
  hiddenAt: timestamptz
  holderName: String
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "bank_info"
input BankInfoMinOrderBy {
  accountCode: OrderBy
  actorId: OrderBy
  addressId: OrderBy
  agencyCode: OrderBy
  bankCode: OrderBy
  bankCodeBic: OrderBy
  bankId: OrderBy
  checksum: OrderBy
  country: OrderBy
  countryCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fullAcount: OrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "bank_info"
type BankInfoMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [BankInfo!]!
}

# input type for inserting object relation for remote table "bank_info"
input BankInfoObjRelInsertInput {
  data: BankInfoInsertInput!

  # upsert condition
  onConflict: BankInfoOnConflict
}

# on_conflict condition type for table "bank_info"
input BankInfoOnConflict {
  constraint: BankInfoConstraint!
  updateColumns: [BankInfoUpdateColumn!]! = []
  where: BankInfoBoolExp
}

# Ordering options when selecting data from "bank_info".
input BankInfoOrderBy {
  accountCode: OrderBy
  accountsAggregate: AccountAggregateOrderBy
  actor: ActorOrderBy
  actorId: OrderBy
  address: AddressOrderBy
  addressId: OrderBy
  agencyCode: OrderBy
  bank: LegalUnitOrderBy
  bankCode: OrderBy
  bankCodeBic: OrderBy
  bankId: OrderBy
  checksum: OrderBy
  country: OrderBy
  countryCode: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  fullAcount: OrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: bank_info
input BankInfoPkColumnsInput {
  id: bigint!
}

# select columns of table "bank_info"
enum BankInfoSelectColumn {
  # column name
  accountCode

  # column name
  actorId

  # column name
  addressId

  # column name
  agencyCode

  # column name
  bankCode

  # column name
  bankCodeBic

  # column name
  bankId

  # column name
  checksum

  # column name
  country

  # column name
  countryCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fullAcount

  # column name
  hiddenAt

  # column name
  holderName

  # column name
  id

  # column name
  tenantId
}

# input type for updating data in table "bank_info"
input BankInfoSetInput {
  accountCode: String
  actorId: bigint
  addressId: bigint
  agencyCode: String
  bankCode: String
  bankCodeBic: String
  bankId: bigint
  checksum: String
  country: String
  countryCode: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fullAcount: String
  hiddenAt: timestamptz
  holderName: String
  id: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type BankInfoStddevFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "bank_info"
input BankInfoStddevOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type BankInfoStddevPopFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "bank_info"
input BankInfoStddevPopOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type BankInfoStddevSampFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "bank_info"
input BankInfoStddevSampOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "bank_info"
input BankInfoStreamCursorInput {
  # Stream column input with initial value
  initialValue: BankInfoStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input BankInfoStreamCursorValueInput {
  accountCode: String
  actorId: bigint
  addressId: bigint
  agencyCode: String
  bankCode: String
  bankCodeBic: String
  bankId: bigint
  checksum: String
  country: String
  countryCode: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fullAcount: String
  hiddenAt: timestamptz
  holderName: String
  id: bigint
  tenantId: bigint
}

# aggregate sum on columns
type BankInfoSumFields {
  actorId: bigint
  addressId: bigint
  bankId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "bank_info"
input BankInfoSumOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "bank_info"
enum BankInfoUpdateColumn {
  # column name
  accountCode

  # column name
  actorId

  # column name
  addressId

  # column name
  agencyCode

  # column name
  bankCode

  # column name
  bankCodeBic

  # column name
  bankId

  # column name
  checksum

  # column name
  country

  # column name
  countryCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fullAcount

  # column name
  hiddenAt

  # column name
  holderName

  # column name
  id

  # column name
  tenantId
}

input BankInfoUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: BankInfoIncInput

  # sets the columns of the filtered rows to the given values
  _set: BankInfoSetInput

  # filter the rows which have to be updated
  where: BankInfoBoolExp!
}

# aggregate variance on columns
type BankInfoVarianceFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "bank_info"
input BankInfoVarianceOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type BankInfoVarPopFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "bank_info"
input BankInfoVarPopOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type BankInfoVarSampFields {
  actorId: Float
  addressId: Float
  bankId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "bank_info"
input BankInfoVarSampOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  bankId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

scalar bigint

# Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

# Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "bot"
type Bot {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  individual: Individual

  # An object relationship
  owner: Actor!
  ownerId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "bot"
type BotAggregate {
  aggregate: BotAggregateFields
  nodes: [Bot!]!
}

input BotAggregateBoolExp {
  count: botAggregateBoolExpCount
}

input botAggregateBoolExpCount {
  arguments: [BotSelectColumn!]
  distinct: Boolean
  filter: BotBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "bot"
type BotAggregateFields {
  avg: BotAvgFields
  count(columns: [BotSelectColumn!], distinct: Boolean): Int!
  max: BotMaxFields
  min: BotMinFields
  stddev: BotStddevFields
  stddevPop: BotStddevPopFields
  stddevSamp: BotStddevSampFields
  sum: BotSumFields
  varPop: BotVarPopFields
  varSamp: BotVarSampFields
  variance: BotVarianceFields
}

# order by aggregate values of table "bot"
input BotAggregateOrderBy {
  avg: BotAvgOrderBy
  count: OrderBy
  max: BotMaxOrderBy
  min: BotMinOrderBy
  stddev: BotStddevOrderBy
  stddevPop: BotStddevPopOrderBy
  stddevSamp: BotStddevSampOrderBy
  sum: BotSumOrderBy
  varPop: BotVarPopOrderBy
  varSamp: BotVarSampOrderBy
  variance: BotVarianceOrderBy
}

# input type for inserting array relation for remote table "bot"
input BotArrRelInsertInput {
  data: [BotInsertInput!]!

  # upsert condition
  onConflict: BotOnConflict
}

# aggregate avg on columns
type BotAvgFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by avg() on columns of table "bot"
input BotAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "bot". All fields are combined with a logical 'AND'.
input BotBoolExp {
  _and: [BotBoolExp!]
  _not: BotBoolExp
  _or: [BotBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  individual: IndividualBoolExp
  owner: ActorBoolExp
  ownerId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "bot"
enum BotConstraint {
  # unique or primary key constraint on columns "id"
  bot_pkey
}

# input type for incrementing numeric columns in table "bot"
input BotIncInput {
  createdById: bigint
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# input type for inserting data into table "bot"
input BotInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  individual: IndividualObjRelInsertInput
  owner: ActorObjRelInsertInput
  ownerId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type BotMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# order by max() on columns of table "bot"
input BotMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type BotMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# order by min() on columns of table "bot"
input BotMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "bot"
type BotMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Bot!]!
}

# input type for inserting object relation for remote table "bot"
input BotObjRelInsertInput {
  data: BotInsertInput!

  # upsert condition
  onConflict: BotOnConflict
}

# on_conflict condition type for table "bot"
input BotOnConflict {
  constraint: BotConstraint!
  updateColumns: [BotUpdateColumn!]! = []
  where: BotBoolExp
}

# Ordering options when selecting data from "bot".
input BotOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  individual: IndividualOrderBy
  owner: ActorOrderBy
  ownerId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: bot
input BotPkColumnsInput {
  id: bigint!
}

# select columns of table "bot"
enum BotSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  ownerId

  # column name
  tenantId
}

# input type for updating data in table "bot"
input BotSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type BotStddevFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by stddev() on columns of table "bot"
input BotStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type BotStddevPopFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "bot"
input BotStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type BotStddevSampFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "bot"
input BotStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "bot"
input BotStreamCursorInput {
  # Stream column input with initial value
  initialValue: BotStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input BotStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type BotSumFields {
  createdById: bigint
  id: bigint
  ownerId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "bot"
input BotSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# update columns of table "bot"
enum BotUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  ownerId

  # column name
  tenantId
}

input BotUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: BotIncInput

  # sets the columns of the filtered rows to the given values
  _set: BotSetInput

  # filter the rows which have to be updated
  where: BotBoolExp!
}

# aggregate variance on columns
type BotVarianceFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by variance() on columns of table "bot"
input BotVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type BotVarPopFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by varPop() on columns of table "bot"
input BotVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type BotVarSampFields {
  createdById: Float
  id: Float
  ownerId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "bot"
input BotVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  ownerId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "campus"
type Campus {
  # An object relationship
  address: Address

  # An object relationship
  campusCluster: CampusCluster!
  campusClusterId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "campus"
type CampusAggregate {
  aggregate: CampusAggregateFields
  nodes: [Campus!]!
}

input CampusAggregateBoolExp {
  count: campusAggregateBoolExpCount
}

input campusAggregateBoolExpCount {
  arguments: [CampusSelectColumn!]
  distinct: Boolean
  filter: CampusBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "campus"
type CampusAggregateFields {
  avg: CampusAvgFields
  count(columns: [CampusSelectColumn!], distinct: Boolean): Int!
  max: CampusMaxFields
  min: CampusMinFields
  stddev: CampusStddevFields
  stddevPop: CampusStddevPopFields
  stddevSamp: CampusStddevSampFields
  sum: CampusSumFields
  varPop: CampusVarPopFields
  varSamp: CampusVarSampFields
  variance: CampusVarianceFields
}

# order by aggregate values of table "campus"
input CampusAggregateOrderBy {
  avg: CampusAvgOrderBy
  count: OrderBy
  max: CampusMaxOrderBy
  min: CampusMinOrderBy
  stddev: CampusStddevOrderBy
  stddevPop: CampusStddevPopOrderBy
  stddevSamp: CampusStddevSampOrderBy
  sum: CampusSumOrderBy
  varPop: CampusVarPopOrderBy
  varSamp: CampusVarSampOrderBy
  variance: CampusVarianceOrderBy
}

# input type for inserting array relation for remote table "campus"
input CampusArrRelInsertInput {
  data: [CampusInsertInput!]!

  # upsert condition
  onConflict: CampusOnConflict
}

# aggregate avg on columns
type CampusAvgFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "campus"
input CampusAvgOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "campus". All fields are combined with a logical 'AND'.
input CampusBoolExp {
  _and: [CampusBoolExp!]
  _not: CampusBoolExp
  _or: [CampusBoolExp!]
  address: AddressBoolExp
  campusCluster: CampusClusterBoolExp
  campusClusterId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# columns and relationships of "campus_cluster"
type CampusCluster {
  # An object relationship
  approximateAddress: Address
  approximateAddressId: bigint

  # An array relationship
  campuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  campusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An array relationship
  tenantManages(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # An aggregate relationship
  tenantManagesAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!
}

# aggregated selection of "campus_cluster"
type CampusClusterAggregate {
  aggregate: CampusClusterAggregateFields
  nodes: [CampusCluster!]!
}

input CampusClusterAggregateBoolExp {
  count: campusClusterAggregateBoolExpCount
}

input campusClusterAggregateBoolExpCount {
  arguments: [CampusClusterSelectColumn!]
  distinct: Boolean
  filter: CampusClusterBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "campus_cluster"
type CampusClusterAggregateFields {
  avg: CampusClusterAvgFields
  count(columns: [CampusClusterSelectColumn!], distinct: Boolean): Int!
  max: CampusClusterMaxFields
  min: CampusClusterMinFields
  stddev: CampusClusterStddevFields
  stddevPop: CampusClusterStddevPopFields
  stddevSamp: CampusClusterStddevSampFields
  sum: CampusClusterSumFields
  varPop: CampusClusterVarPopFields
  varSamp: CampusClusterVarSampFields
  variance: CampusClusterVarianceFields
}

# order by aggregate values of table "campus_cluster"
input CampusClusterAggregateOrderBy {
  avg: CampusClusterAvgOrderBy
  count: OrderBy
  max: CampusClusterMaxOrderBy
  min: CampusClusterMinOrderBy
  stddev: CampusClusterStddevOrderBy
  stddevPop: CampusClusterStddevPopOrderBy
  stddevSamp: CampusClusterStddevSampOrderBy
  sum: CampusClusterSumOrderBy
  varPop: CampusClusterVarPopOrderBy
  varSamp: CampusClusterVarSampOrderBy
  variance: CampusClusterVarianceOrderBy
}

# input type for inserting array relation for remote table "campus_cluster"
input CampusClusterArrRelInsertInput {
  data: [CampusClusterInsertInput!]!

  # upsert condition
  onConflict: CampusClusterOnConflict
}

# aggregate avg on columns
type CampusClusterAvgFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "campus_cluster"
input CampusClusterAvgOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "campus_cluster". All fields are combined with a logical 'AND'.
input CampusClusterBoolExp {
  _and: [CampusClusterBoolExp!]
  _not: CampusClusterBoolExp
  _or: [CampusClusterBoolExp!]
  approximateAddress: AddressBoolExp
  approximateAddressId: BigintComparisonExp
  campuses: CampusBoolExp
  campusesAggregate: CampusAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  tenantManages: TenantManageBoolExp
  tenantManagesAggregate: TenantManageAggregateBoolExp
}

# unique or primary key constraints on table "campus_cluster"
enum CampusClusterConstraint {
  # unique or primary key constraint on columns "id"
  campus_cluster_pkey
}

# input type for incrementing numeric columns in table "campus_cluster"
input CampusClusterIncInput {
  approximateAddressId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "campus_cluster"
input CampusClusterInsertInput {
  approximateAddress: AddressObjRelInsertInput
  approximateAddressId: bigint
  campuses: CampusArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  tenantManages: TenantManageArrRelInsertInput
}

# aggregate max on columns
type CampusClusterMaxFields {
  approximateAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# order by max() on columns of table "campus_cluster"
input CampusClusterMaxOrderBy {
  approximateAddressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type CampusClusterMinFields {
  approximateAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# order by min() on columns of table "campus_cluster"
input CampusClusterMinOrderBy {
  approximateAddressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "campus_cluster"
type CampusClusterMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [CampusCluster!]!
}

# input type for inserting object relation for remote table "campus_cluster"
input CampusClusterObjRelInsertInput {
  data: CampusClusterInsertInput!

  # upsert condition
  onConflict: CampusClusterOnConflict
}

# on_conflict condition type for table "campus_cluster"
input CampusClusterOnConflict {
  constraint: CampusClusterConstraint!
  updateColumns: [CampusClusterUpdateColumn!]! = []
  where: CampusClusterBoolExp
}

# Ordering options when selecting data from "campus_cluster".
input CampusClusterOrderBy {
  approximateAddress: AddressOrderBy
  approximateAddressId: OrderBy
  campusesAggregate: CampusAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  tenantManagesAggregate: TenantManageAggregateOrderBy
}

# primary key columns input for table: campus_cluster
input CampusClusterPkColumnsInput {
  id: bigint!
}

# select columns of table "campus_cluster"
enum CampusClusterSelectColumn {
  # column name
  approximateAddressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantId
}

# input type for updating data in table "campus_cluster"
input CampusClusterSetInput {
  approximateAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# aggregate stddev on columns
type CampusClusterStddevFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "campus_cluster"
input CampusClusterStddevOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type CampusClusterStddevPopFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "campus_cluster"
input CampusClusterStddevPopOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type CampusClusterStddevSampFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "campus_cluster"
input CampusClusterStddevSampOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "campus_cluster"
input CampusClusterStreamCursorInput {
  # Stream column input with initial value
  initialValue: CampusClusterStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CampusClusterStreamCursorValueInput {
  approximateAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# aggregate sum on columns
type CampusClusterSumFields {
  approximateAddressId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "campus_cluster"
input CampusClusterSumOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "campus_cluster"
enum CampusClusterUpdateColumn {
  # column name
  approximateAddressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantId
}

input CampusClusterUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CampusClusterIncInput

  # sets the columns of the filtered rows to the given values
  _set: CampusClusterSetInput

  # filter the rows which have to be updated
  where: CampusClusterBoolExp!
}

# aggregate variance on columns
type CampusClusterVarianceFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "campus_cluster"
input CampusClusterVarianceOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type CampusClusterVarPopFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "campus_cluster"
input CampusClusterVarPopOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type CampusClusterVarSampFields {
  approximateAddressId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "campus_cluster"
input CampusClusterVarSampOrderBy {
  approximateAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# unique or primary key constraints on table "campus"
enum CampusConstraint {
  # unique or primary key constraint on columns "id"
  campus_pkey
}

# input type for incrementing numeric columns in table "campus"
input CampusIncInput {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "campus"
input CampusInsertInput {
  address: AddressObjRelInsertInput
  campusCluster: CampusClusterObjRelInsertInput
  campusClusterId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type CampusMaxFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# order by max() on columns of table "campus"
input CampusMaxOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type CampusMinFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# order by min() on columns of table "campus"
input CampusMinOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "campus"
type CampusMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Campus!]!
}

# input type for inserting object relation for remote table "campus"
input CampusObjRelInsertInput {
  data: CampusInsertInput!

  # upsert condition
  onConflict: CampusOnConflict
}

# on_conflict condition type for table "campus"
input CampusOnConflict {
  constraint: CampusConstraint!
  updateColumns: [CampusUpdateColumn!]! = []
  where: CampusBoolExp
}

# Ordering options when selecting data from "campus".
input CampusOrderBy {
  address: AddressOrderBy
  campusCluster: CampusClusterOrderBy
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: campus
input CampusPkColumnsInput {
  id: bigint!
}

# select columns of table "campus"
enum CampusSelectColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantId
}

# input type for updating data in table "campus"
input CampusSetInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# aggregate stddev on columns
type CampusStddevFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "campus"
input CampusStddevOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type CampusStddevPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "campus"
input CampusStddevPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type CampusStddevSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "campus"
input CampusStddevSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "campus"
input CampusStreamCursorInput {
  # Stream column input with initial value
  initialValue: CampusStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CampusStreamCursorValueInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantId: bigint
}

# aggregate sum on columns
type CampusSumFields {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "campus"
input CampusSumOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "campus"
enum CampusUpdateColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantId
}

input CampusUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CampusIncInput

  # sets the columns of the filtered rows to the given values
  _set: CampusSetInput

  # filter the rows which have to be updated
  where: CampusBoolExp!
}

# aggregate variance on columns
type CampusVarianceFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "campus"
input CampusVarianceOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type CampusVarPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "campus"
input CampusVarPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type CampusVarSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "campus"
input CampusVarSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "canteen"
type Canteen {
  # An array relationship
  canteenFoods(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # An aggregate relationship
  canteenFoodsAggregate(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): CanteenFoodAggregate!

  # An array relationship
  canteenMenus(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # An aggregate relationship
  canteenMenusAggregate(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): CanteenMenuAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "canteen"
type CanteenAggregate {
  aggregate: CanteenAggregateFields
  nodes: [Canteen!]!
}

input CanteenAggregateBoolExp {
  count: canteenAggregateBoolExpCount
}

input canteenAggregateBoolExpCount {
  arguments: [CanteenSelectColumn!]
  distinct: Boolean
  filter: CanteenBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "canteen"
type CanteenAggregateFields {
  avg: CanteenAvgFields
  count(columns: [CanteenSelectColumn!], distinct: Boolean): Int!
  max: CanteenMaxFields
  min: CanteenMinFields
  stddev: CanteenStddevFields
  stddevPop: CanteenStddevPopFields
  stddevSamp: CanteenStddevSampFields
  sum: CanteenSumFields
  varPop: CanteenVarPopFields
  varSamp: CanteenVarSampFields
  variance: CanteenVarianceFields
}

# order by aggregate values of table "canteen"
input CanteenAggregateOrderBy {
  avg: CanteenAvgOrderBy
  count: OrderBy
  max: CanteenMaxOrderBy
  min: CanteenMinOrderBy
  stddev: CanteenStddevOrderBy
  stddevPop: CanteenStddevPopOrderBy
  stddevSamp: CanteenStddevSampOrderBy
  sum: CanteenSumOrderBy
  varPop: CanteenVarPopOrderBy
  varSamp: CanteenVarSampOrderBy
  variance: CanteenVarianceOrderBy
}

# input type for inserting array relation for remote table "canteen"
input CanteenArrRelInsertInput {
  data: [CanteenInsertInput!]!

  # upsert condition
  onConflict: CanteenOnConflict
}

# aggregate avg on columns
type CanteenAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "canteen"
input CanteenAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "canteen". All fields are combined with a logical 'AND'.
input CanteenBoolExp {
  _and: [CanteenBoolExp!]
  _not: CanteenBoolExp
  _or: [CanteenBoolExp!]
  canteenFoods: CanteenFoodBoolExp
  canteenFoodsAggregate: CanteenFoodAggregateBoolExp
  canteenMenus: CanteenMenuBoolExp
  canteenMenusAggregate: CanteenMenuAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "canteen"
enum CanteenConstraint {
  # unique or primary key constraint on columns "id"
  canteen_pkey
}

# columns and relationships of "canteen_food"
type CanteenFood {
  # An object relationship
  canteen: Canteen!
  canteenId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "canteen_food"
type CanteenFoodAggregate {
  aggregate: CanteenFoodAggregateFields
  nodes: [CanteenFood!]!
}

input CanteenFoodAggregateBoolExp {
  count: canteenFoodAggregateBoolExpCount
}

input canteenFoodAggregateBoolExpCount {
  arguments: [CanteenFoodSelectColumn!]
  distinct: Boolean
  filter: CanteenFoodBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "canteen_food"
type CanteenFoodAggregateFields {
  avg: CanteenFoodAvgFields
  count(columns: [CanteenFoodSelectColumn!], distinct: Boolean): Int!
  max: CanteenFoodMaxFields
  min: CanteenFoodMinFields
  stddev: CanteenFoodStddevFields
  stddevPop: CanteenFoodStddevPopFields
  stddevSamp: CanteenFoodStddevSampFields
  sum: CanteenFoodSumFields
  varPop: CanteenFoodVarPopFields
  varSamp: CanteenFoodVarSampFields
  variance: CanteenFoodVarianceFields
}

# order by aggregate values of table "canteen_food"
input CanteenFoodAggregateOrderBy {
  avg: CanteenFoodAvgOrderBy
  count: OrderBy
  max: CanteenFoodMaxOrderBy
  min: CanteenFoodMinOrderBy
  stddev: CanteenFoodStddevOrderBy
  stddevPop: CanteenFoodStddevPopOrderBy
  stddevSamp: CanteenFoodStddevSampOrderBy
  sum: CanteenFoodSumOrderBy
  varPop: CanteenFoodVarPopOrderBy
  varSamp: CanteenFoodVarSampOrderBy
  variance: CanteenFoodVarianceOrderBy
}

# input type for inserting array relation for remote table "canteen_food"
input CanteenFoodArrRelInsertInput {
  data: [CanteenFoodInsertInput!]!

  # upsert condition
  onConflict: CanteenFoodOnConflict
}

# aggregate avg on columns
type CanteenFoodAvgFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "canteen_food"
input CanteenFoodAvgOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "canteen_food". All fields are combined with a logical 'AND'.
input CanteenFoodBoolExp {
  _and: [CanteenFoodBoolExp!]
  _not: CanteenFoodBoolExp
  _or: [CanteenFoodBoolExp!]
  canteen: CanteenBoolExp
  canteenId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "canteen_food"
enum CanteenFoodConstraint {
  # unique or primary key constraint on columns "id"
  canteen_food_pkey
}

# input type for incrementing numeric columns in table "canteen_food"
input CanteenFoodIncInput {
  canteenId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "canteen_food"
input CanteenFoodInsertInput {
  canteen: CanteenObjRelInsertInput
  canteenId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type CanteenFoodMaxFields {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "canteen_food"
input CanteenFoodMaxOrderBy {
  canteenId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type CanteenFoodMinFields {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "canteen_food"
input CanteenFoodMinOrderBy {
  canteenId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "canteen_food"
type CanteenFoodMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [CanteenFood!]!
}

# on_conflict condition type for table "canteen_food"
input CanteenFoodOnConflict {
  constraint: CanteenFoodConstraint!
  updateColumns: [CanteenFoodUpdateColumn!]! = []
  where: CanteenFoodBoolExp
}

# Ordering options when selecting data from "canteen_food".
input CanteenFoodOrderBy {
  canteen: CanteenOrderBy
  canteenId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: canteen_food
input CanteenFoodPkColumnsInput {
  id: bigint!
}

# select columns of table "canteen_food"
enum CanteenFoodSelectColumn {
  # column name
  canteenId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

# input type for updating data in table "canteen_food"
input CanteenFoodSetInput {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type CanteenFoodStddevFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "canteen_food"
input CanteenFoodStddevOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type CanteenFoodStddevPopFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "canteen_food"
input CanteenFoodStddevPopOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type CanteenFoodStddevSampFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "canteen_food"
input CanteenFoodStddevSampOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "canteen_food"
input CanteenFoodStreamCursorInput {
  # Stream column input with initial value
  initialValue: CanteenFoodStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CanteenFoodStreamCursorValueInput {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate sum on columns
type CanteenFoodSumFields {
  canteenId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "canteen_food"
input CanteenFoodSumOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "canteen_food"
enum CanteenFoodUpdateColumn {
  # column name
  canteenId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

input CanteenFoodUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CanteenFoodIncInput

  # sets the columns of the filtered rows to the given values
  _set: CanteenFoodSetInput

  # filter the rows which have to be updated
  where: CanteenFoodBoolExp!
}

# aggregate variance on columns
type CanteenFoodVarianceFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "canteen_food"
input CanteenFoodVarianceOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type CanteenFoodVarPopFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "canteen_food"
input CanteenFoodVarPopOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type CanteenFoodVarSampFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "canteen_food"
input CanteenFoodVarSampOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# input type for incrementing numeric columns in table "canteen"
input CanteenIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "canteen"
input CanteenInsertInput {
  canteenFoods: CanteenFoodArrRelInsertInput
  canteenMenus: CanteenMenuArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type CanteenMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "canteen"
input CanteenMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "canteen_menu"
type CanteenMenu {
  # An object relationship
  canteen: Canteen!
  canteenId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "canteen_menu"
type CanteenMenuAggregate {
  aggregate: CanteenMenuAggregateFields
  nodes: [CanteenMenu!]!
}

input CanteenMenuAggregateBoolExp {
  count: canteenMenuAggregateBoolExpCount
}

input canteenMenuAggregateBoolExpCount {
  arguments: [CanteenMenuSelectColumn!]
  distinct: Boolean
  filter: CanteenMenuBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "canteen_menu"
type CanteenMenuAggregateFields {
  avg: CanteenMenuAvgFields
  count(columns: [CanteenMenuSelectColumn!], distinct: Boolean): Int!
  max: CanteenMenuMaxFields
  min: CanteenMenuMinFields
  stddev: CanteenMenuStddevFields
  stddevPop: CanteenMenuStddevPopFields
  stddevSamp: CanteenMenuStddevSampFields
  sum: CanteenMenuSumFields
  varPop: CanteenMenuVarPopFields
  varSamp: CanteenMenuVarSampFields
  variance: CanteenMenuVarianceFields
}

# order by aggregate values of table "canteen_menu"
input CanteenMenuAggregateOrderBy {
  avg: CanteenMenuAvgOrderBy
  count: OrderBy
  max: CanteenMenuMaxOrderBy
  min: CanteenMenuMinOrderBy
  stddev: CanteenMenuStddevOrderBy
  stddevPop: CanteenMenuStddevPopOrderBy
  stddevSamp: CanteenMenuStddevSampOrderBy
  sum: CanteenMenuSumOrderBy
  varPop: CanteenMenuVarPopOrderBy
  varSamp: CanteenMenuVarSampOrderBy
  variance: CanteenMenuVarianceOrderBy
}

# input type for inserting array relation for remote table "canteen_menu"
input CanteenMenuArrRelInsertInput {
  data: [CanteenMenuInsertInput!]!

  # upsert condition
  onConflict: CanteenMenuOnConflict
}

# aggregate avg on columns
type CanteenMenuAvgFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "canteen_menu"
input CanteenMenuAvgOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "canteen_menu". All fields are combined with a logical 'AND'.
input CanteenMenuBoolExp {
  _and: [CanteenMenuBoolExp!]
  _not: CanteenMenuBoolExp
  _or: [CanteenMenuBoolExp!]
  canteen: CanteenBoolExp
  canteenId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "canteen_menu"
enum CanteenMenuConstraint {
  # unique or primary key constraint on columns "id"
  canteen_menu_pkey
}

# input type for incrementing numeric columns in table "canteen_menu"
input CanteenMenuIncInput {
  canteenId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "canteen_menu"
input CanteenMenuInsertInput {
  canteen: CanteenObjRelInsertInput
  canteenId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type CanteenMenuMaxFields {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "canteen_menu"
input CanteenMenuMaxOrderBy {
  canteenId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type CanteenMenuMinFields {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "canteen_menu"
input CanteenMenuMinOrderBy {
  canteenId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "canteen_menu"
type CanteenMenuMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [CanteenMenu!]!
}

# on_conflict condition type for table "canteen_menu"
input CanteenMenuOnConflict {
  constraint: CanteenMenuConstraint!
  updateColumns: [CanteenMenuUpdateColumn!]! = []
  where: CanteenMenuBoolExp
}

# Ordering options when selecting data from "canteen_menu".
input CanteenMenuOrderBy {
  canteen: CanteenOrderBy
  canteenId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: canteen_menu
input CanteenMenuPkColumnsInput {
  id: bigint!
}

# select columns of table "canteen_menu"
enum CanteenMenuSelectColumn {
  # column name
  canteenId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

# input type for updating data in table "canteen_menu"
input CanteenMenuSetInput {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type CanteenMenuStddevFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "canteen_menu"
input CanteenMenuStddevOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type CanteenMenuStddevPopFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "canteen_menu"
input CanteenMenuStddevPopOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type CanteenMenuStddevSampFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "canteen_menu"
input CanteenMenuStddevSampOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "canteen_menu"
input CanteenMenuStreamCursorInput {
  # Stream column input with initial value
  initialValue: CanteenMenuStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CanteenMenuStreamCursorValueInput {
  canteenId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate sum on columns
type CanteenMenuSumFields {
  canteenId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "canteen_menu"
input CanteenMenuSumOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "canteen_menu"
enum CanteenMenuUpdateColumn {
  # column name
  canteenId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

input CanteenMenuUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CanteenMenuIncInput

  # sets the columns of the filtered rows to the given values
  _set: CanteenMenuSetInput

  # filter the rows which have to be updated
  where: CanteenMenuBoolExp!
}

# aggregate variance on columns
type CanteenMenuVarianceFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "canteen_menu"
input CanteenMenuVarianceOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type CanteenMenuVarPopFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "canteen_menu"
input CanteenMenuVarPopOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type CanteenMenuVarSampFields {
  canteenId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "canteen_menu"
input CanteenMenuVarSampOrderBy {
  canteenId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type CanteenMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "canteen"
input CanteenMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "canteen"
type CanteenMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Canteen!]!
}

# input type for inserting object relation for remote table "canteen"
input CanteenObjRelInsertInput {
  data: CanteenInsertInput!

  # upsert condition
  onConflict: CanteenOnConflict
}

# on_conflict condition type for table "canteen"
input CanteenOnConflict {
  constraint: CanteenConstraint!
  updateColumns: [CanteenUpdateColumn!]! = []
  where: CanteenBoolExp
}

# Ordering options when selecting data from "canteen".
input CanteenOrderBy {
  canteenFoodsAggregate: CanteenFoodAggregateOrderBy
  canteenMenusAggregate: CanteenMenuAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: canteen
input CanteenPkColumnsInput {
  id: bigint!
}

# select columns of table "canteen"
enum CanteenSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

# input type for updating data in table "canteen"
input CanteenSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type CanteenStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "canteen"
input CanteenStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type CanteenStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "canteen"
input CanteenStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type CanteenStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "canteen"
input CanteenStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "canteen"
input CanteenStreamCursorInput {
  # Stream column input with initial value
  initialValue: CanteenStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CanteenStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate sum on columns
type CanteenSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "canteen"
input CanteenSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "canteen"
enum CanteenUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

input CanteenUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CanteenIncInput

  # sets the columns of the filtered rows to the given values
  _set: CanteenSetInput

  # filter the rows which have to be updated
  where: CanteenBoolExp!
}

# aggregate variance on columns
type CanteenVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "canteen"
input CanteenVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type CanteenVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "canteen"
input CanteenVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type CanteenVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "canteen"
input CanteenVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "class_group"
type ClassGroup {
  # An array relationship
  classGroupTeachers(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # An aggregate relationship
  classGroupTeachersAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  subjectClassGroups(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): [SubjectClassGroups!]!

  # An aggregate relationship
  subjectClassGroupsAggregate(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): SubjectClassGroupsAggregate!

  # An object relationship
  team: Team

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "class_group"
type ClassGroupAggregate {
  aggregate: ClassGroupAggregateFields
  nodes: [ClassGroup!]!
}

input ClassGroupAggregateBoolExp {
  count: classGroupAggregateBoolExpCount
}

input classGroupAggregateBoolExpCount {
  arguments: [ClassGroupSelectColumn!]
  distinct: Boolean
  filter: ClassGroupBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "class_group"
type ClassGroupAggregateFields {
  avg: ClassGroupAvgFields
  count(columns: [ClassGroupSelectColumn!], distinct: Boolean): Int!
  max: ClassGroupMaxFields
  min: ClassGroupMinFields
  stddev: ClassGroupStddevFields
  stddevPop: ClassGroupStddevPopFields
  stddevSamp: ClassGroupStddevSampFields
  sum: ClassGroupSumFields
  varPop: ClassGroupVarPopFields
  varSamp: ClassGroupVarSampFields
  variance: ClassGroupVarianceFields
}

# order by aggregate values of table "class_group"
input ClassGroupAggregateOrderBy {
  avg: ClassGroupAvgOrderBy
  count: OrderBy
  max: ClassGroupMaxOrderBy
  min: ClassGroupMinOrderBy
  stddev: ClassGroupStddevOrderBy
  stddevPop: ClassGroupStddevPopOrderBy
  stddevSamp: ClassGroupStddevSampOrderBy
  sum: ClassGroupSumOrderBy
  varPop: ClassGroupVarPopOrderBy
  varSamp: ClassGroupVarSampOrderBy
  variance: ClassGroupVarianceOrderBy
}

# input type for inserting array relation for remote table "class_group"
input ClassGroupArrRelInsertInput {
  data: [ClassGroupInsertInput!]!

  # upsert condition
  onConflict: ClassGroupOnConflict
}

# aggregate avg on columns
type ClassGroupAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "class_group"
input ClassGroupAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "class_group". All fields are combined with a logical 'AND'.
input ClassGroupBoolExp {
  _and: [ClassGroupBoolExp!]
  _not: ClassGroupBoolExp
  _or: [ClassGroupBoolExp!]
  classGroupTeachers: ClassGroupTeacherBoolExp
  classGroupTeachersAggregate: ClassGroupTeacherAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  subjectClassGroups: SubjectClassGroupsBoolExp
  subjectClassGroupsAggregate: SubjectClassGroupsAggregateBoolExp
  team: TeamBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "class_group"
enum ClassGroupConstraint {
  # unique or primary key constraint on columns "id"
  class_group_pkey
}

# input type for incrementing numeric columns in table "class_group"
input ClassGroupIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "class_group"
input ClassGroupInsertInput {
  classGroupTeachers: ClassGroupTeacherArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  subjectClassGroups: SubjectClassGroupsArrRelInsertInput
  team: TeamObjRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type ClassGroupMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# order by max() on columns of table "class_group"
input ClassGroupMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ClassGroupMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# order by min() on columns of table "class_group"
input ClassGroupMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "class_group"
type ClassGroupMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ClassGroup!]!
}

# input type for inserting object relation for remote table "class_group"
input ClassGroupObjRelInsertInput {
  data: ClassGroupInsertInput!

  # upsert condition
  onConflict: ClassGroupOnConflict
}

# on_conflict condition type for table "class_group"
input ClassGroupOnConflict {
  constraint: ClassGroupConstraint!
  updateColumns: [ClassGroupUpdateColumn!]! = []
  where: ClassGroupBoolExp
}

# Ordering options when selecting data from "class_group".
input ClassGroupOrderBy {
  classGroupTeachersAggregate: ClassGroupTeacherAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  subjectClassGroupsAggregate: SubjectClassGroupsAggregateOrderBy
  team: TeamOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: class_group
input ClassGroupPkColumnsInput {
  id: bigint!
}

# select columns of table "class_group"
enum ClassGroupSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "class_group"
input ClassGroupSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type ClassGroupStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "class_group"
input ClassGroupStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ClassGroupStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "class_group"
input ClassGroupStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ClassGroupStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "class_group"
input ClassGroupStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "class_group"
input ClassGroupStreamCursorInput {
  # Stream column input with initial value
  initialValue: ClassGroupStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ClassGroupStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type ClassGroupSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "class_group"
input ClassGroupSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "class_group_teacher"
type ClassGroupTeacher {
  # An object relationship
  classGroup: ClassGroup!
  classGroupId: bigint!

  # An array relationship
  classGroupTeacherSubjects(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): [ClassGroupTeacherSubjects!]!

  # An aggregate relationship
  classGroupTeacherSubjectsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): ClassGroupTeacherSubjectsAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  startDate: timestamptz!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "class_group_teacher"
type ClassGroupTeacherAggregate {
  aggregate: ClassGroupTeacherAggregateFields
  nodes: [ClassGroupTeacher!]!
}

input ClassGroupTeacherAggregateBoolExp {
  count: classGroupTeacherAggregateBoolExpCount
}

input classGroupTeacherAggregateBoolExpCount {
  arguments: [ClassGroupTeacherSelectColumn!]
  distinct: Boolean
  filter: ClassGroupTeacherBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "class_group_teacher"
type ClassGroupTeacherAggregateFields {
  avg: ClassGroupTeacherAvgFields
  count(columns: [ClassGroupTeacherSelectColumn!], distinct: Boolean): Int!
  max: ClassGroupTeacherMaxFields
  min: ClassGroupTeacherMinFields
  stddev: ClassGroupTeacherStddevFields
  stddevPop: ClassGroupTeacherStddevPopFields
  stddevSamp: ClassGroupTeacherStddevSampFields
  sum: ClassGroupTeacherSumFields
  varPop: ClassGroupTeacherVarPopFields
  varSamp: ClassGroupTeacherVarSampFields
  variance: ClassGroupTeacherVarianceFields
}

# order by aggregate values of table "class_group_teacher"
input ClassGroupTeacherAggregateOrderBy {
  avg: ClassGroupTeacherAvgOrderBy
  count: OrderBy
  max: ClassGroupTeacherMaxOrderBy
  min: ClassGroupTeacherMinOrderBy
  stddev: ClassGroupTeacherStddevOrderBy
  stddevPop: ClassGroupTeacherStddevPopOrderBy
  stddevSamp: ClassGroupTeacherStddevSampOrderBy
  sum: ClassGroupTeacherSumOrderBy
  varPop: ClassGroupTeacherVarPopOrderBy
  varSamp: ClassGroupTeacherVarSampOrderBy
  variance: ClassGroupTeacherVarianceOrderBy
}

# input type for inserting array relation for remote table "class_group_teacher"
input ClassGroupTeacherArrRelInsertInput {
  data: [ClassGroupTeacherInsertInput!]!

  # upsert condition
  onConflict: ClassGroupTeacherOnConflict
}

# aggregate avg on columns
type ClassGroupTeacherAvgFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "class_group_teacher"
input ClassGroupTeacherAvgOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "class_group_teacher". All fields are combined with a logical 'AND'.
input ClassGroupTeacherBoolExp {
  _and: [ClassGroupTeacherBoolExp!]
  _not: ClassGroupTeacherBoolExp
  _or: [ClassGroupTeacherBoolExp!]
  classGroup: ClassGroupBoolExp
  classGroupId: BigintComparisonExp
  classGroupTeacherSubjects: ClassGroupTeacherSubjectsBoolExp
  classGroupTeacherSubjectsAggregate: ClassGroupTeacherSubjectsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  endDate: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  startDate: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "class_group_teacher"
enum ClassGroupTeacherConstraint {
  # unique or primary key constraint on columns "id"
  class_group_teacher_pkey
}

# input type for incrementing numeric columns in table "class_group_teacher"
input ClassGroupTeacherIncInput {
  classGroupId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "class_group_teacher"
input ClassGroupTeacherInsertInput {
  classGroup: ClassGroupObjRelInsertInput
  classGroupId: bigint
  classGroupTeacherSubjects: ClassGroupTeacherSubjectsArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  startDate: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type ClassGroupTeacherMaxFields {
  classGroupId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  startDate: timestamptz
  tenantId: bigint
  userId: bigint
}

# order by max() on columns of table "class_group_teacher"
input ClassGroupTeacherMaxOrderBy {
  classGroupId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type ClassGroupTeacherMinFields {
  classGroupId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  startDate: timestamptz
  tenantId: bigint
  userId: bigint
}

# order by min() on columns of table "class_group_teacher"
input ClassGroupTeacherMinOrderBy {
  classGroupId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "class_group_teacher"
type ClassGroupTeacherMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ClassGroupTeacher!]!
}

# input type for inserting object relation for remote table "class_group_teacher"
input ClassGroupTeacherObjRelInsertInput {
  data: ClassGroupTeacherInsertInput!

  # upsert condition
  onConflict: ClassGroupTeacherOnConflict
}

# on_conflict condition type for table "class_group_teacher"
input ClassGroupTeacherOnConflict {
  constraint: ClassGroupTeacherConstraint!
  updateColumns: [ClassGroupTeacherUpdateColumn!]! = []
  where: ClassGroupTeacherBoolExp
}

# Ordering options when selecting data from "class_group_teacher".
input ClassGroupTeacherOrderBy {
  classGroup: ClassGroupOrderBy
  classGroupId: OrderBy
  classGroupTeacherSubjectsAggregate: ClassGroupTeacherSubjectsAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  startDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: class_group_teacher
input ClassGroupTeacherPkColumnsInput {
  id: bigint!
}

# select columns of table "class_group_teacher"
enum ClassGroupTeacherSelectColumn {
  # column name
  classGroupId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  endDate

  # column name
  hiddenAt

  # column name
  id

  # column name
  startDate

  # column name
  tenantId

  # column name
  userId
}

# input type for updating data in table "class_group_teacher"
input ClassGroupTeacherSetInput {
  classGroupId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  startDate: timestamptz
  tenantId: bigint
  userId: bigint
}

# aggregate stddev on columns
type ClassGroupTeacherStddevFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "class_group_teacher"
input ClassGroupTeacherStddevOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type ClassGroupTeacherStddevPopFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "class_group_teacher"
input ClassGroupTeacherStddevPopOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type ClassGroupTeacherStddevSampFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "class_group_teacher"
input ClassGroupTeacherStddevSampOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "class_group_teacher"
input ClassGroupTeacherStreamCursorInput {
  # Stream column input with initial value
  initialValue: ClassGroupTeacherStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ClassGroupTeacherStreamCursorValueInput {
  classGroupId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  startDate: timestamptz
  tenantId: bigint
  userId: bigint
}

# columns and relationships of "class_group_teacher_subjects"
type ClassGroupTeacherSubjects {
  # An object relationship
  classGroupTeacher: ClassGroupTeacher!
  classGroupTeacherId: bigint!

  # An object relationship
  subject: Subject!
  subjectId: bigint!
}

# aggregated selection of "class_group_teacher_subjects"
type ClassGroupTeacherSubjectsAggregate {
  aggregate: ClassGroupTeacherSubjectsAggregateFields
  nodes: [ClassGroupTeacherSubjects!]!
}

input ClassGroupTeacherSubjectsAggregateBoolExp {
  count: classGroupTeacherSubjectsAggregateBoolExpCount
}

input classGroupTeacherSubjectsAggregateBoolExpCount {
  arguments: [ClassGroupTeacherSubjectsSelectColumn!]
  distinct: Boolean
  filter: ClassGroupTeacherSubjectsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "class_group_teacher_subjects"
type ClassGroupTeacherSubjectsAggregateFields {
  avg: ClassGroupTeacherSubjectsAvgFields
  count(columns: [ClassGroupTeacherSubjectsSelectColumn!], distinct: Boolean): Int!
  max: ClassGroupTeacherSubjectsMaxFields
  min: ClassGroupTeacherSubjectsMinFields
  stddev: ClassGroupTeacherSubjectsStddevFields
  stddevPop: ClassGroupTeacherSubjectsStddevPopFields
  stddevSamp: ClassGroupTeacherSubjectsStddevSampFields
  sum: ClassGroupTeacherSubjectsSumFields
  varPop: ClassGroupTeacherSubjectsVarPopFields
  varSamp: ClassGroupTeacherSubjectsVarSampFields
  variance: ClassGroupTeacherSubjectsVarianceFields
}

# order by aggregate values of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsAggregateOrderBy {
  avg: ClassGroupTeacherSubjectsAvgOrderBy
  count: OrderBy
  max: ClassGroupTeacherSubjectsMaxOrderBy
  min: ClassGroupTeacherSubjectsMinOrderBy
  stddev: ClassGroupTeacherSubjectsStddevOrderBy
  stddevPop: ClassGroupTeacherSubjectsStddevPopOrderBy
  stddevSamp: ClassGroupTeacherSubjectsStddevSampOrderBy
  sum: ClassGroupTeacherSubjectsSumOrderBy
  varPop: ClassGroupTeacherSubjectsVarPopOrderBy
  varSamp: ClassGroupTeacherSubjectsVarSampOrderBy
  variance: ClassGroupTeacherSubjectsVarianceOrderBy
}

# input type for inserting array relation for remote table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsArrRelInsertInput {
  data: [ClassGroupTeacherSubjectsInsertInput!]!

  # upsert condition
  onConflict: ClassGroupTeacherSubjectsOnConflict
}

# aggregate avg on columns
type ClassGroupTeacherSubjectsAvgFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by avg() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsAvgOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# Boolean expression to filter rows from the table "class_group_teacher_subjects".
# All fields are combined with a logical 'AND'.
input ClassGroupTeacherSubjectsBoolExp {
  _and: [ClassGroupTeacherSubjectsBoolExp!]
  _not: ClassGroupTeacherSubjectsBoolExp
  _or: [ClassGroupTeacherSubjectsBoolExp!]
  classGroupTeacher: ClassGroupTeacherBoolExp
  classGroupTeacherId: BigintComparisonExp
  subject: SubjectBoolExp
  subjectId: BigintComparisonExp
}

# unique or primary key constraints on table "class_group_teacher_subjects"
enum ClassGroupTeacherSubjectsConstraint {
  # unique or primary key constraint on columns "class_group_teacher_id", "subject_id"
  class_group_teacher_subjects_pkey
}

# input type for incrementing numeric columns in table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsIncInput {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# input type for inserting data into table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsInsertInput {
  classGroupTeacher: ClassGroupTeacherObjRelInsertInput
  classGroupTeacherId: bigint
  subject: SubjectObjRelInsertInput
  subjectId: bigint
}

# aggregate max on columns
type ClassGroupTeacherSubjectsMaxFields {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# order by max() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsMaxOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate min on columns
type ClassGroupTeacherSubjectsMinFields {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# order by min() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsMinOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# response of any mutation on the table "class_group_teacher_subjects"
type ClassGroupTeacherSubjectsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ClassGroupTeacherSubjects!]!
}

# on_conflict condition type for table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsOnConflict {
  constraint: ClassGroupTeacherSubjectsConstraint!
  updateColumns: [ClassGroupTeacherSubjectsUpdateColumn!]! = []
  where: ClassGroupTeacherSubjectsBoolExp
}

# Ordering options when selecting data from "class_group_teacher_subjects".
input ClassGroupTeacherSubjectsOrderBy {
  classGroupTeacher: ClassGroupTeacherOrderBy
  classGroupTeacherId: OrderBy
  subject: SubjectOrderBy
  subjectId: OrderBy
}

# primary key columns input for table: class_group_teacher_subjects
input ClassGroupTeacherSubjectsPkColumnsInput {
  classGroupTeacherId: bigint!
  subjectId: bigint!
}

# select columns of table "class_group_teacher_subjects"
enum ClassGroupTeacherSubjectsSelectColumn {
  # column name
  classGroupTeacherId

  # column name
  subjectId
}

# input type for updating data in table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsSetInput {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# aggregate stddev on columns
type ClassGroupTeacherSubjectsStddevFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by stddev() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsStddevOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate stddevPop on columns
type ClassGroupTeacherSubjectsStddevPopFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by stddevPop() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsStddevPopOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate stddevSamp on columns
type ClassGroupTeacherSubjectsStddevSampFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by stddevSamp() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsStddevSampOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# Streaming cursor of the table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ClassGroupTeacherSubjectsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ClassGroupTeacherSubjectsStreamCursorValueInput {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# aggregate sum on columns
type ClassGroupTeacherSubjectsSumFields {
  classGroupTeacherId: bigint
  subjectId: bigint
}

# order by sum() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsSumOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# update columns of table "class_group_teacher_subjects"
enum ClassGroupTeacherSubjectsUpdateColumn {
  # column name
  classGroupTeacherId

  # column name
  subjectId
}

input ClassGroupTeacherSubjectsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ClassGroupTeacherSubjectsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ClassGroupTeacherSubjectsSetInput

  # filter the rows which have to be updated
  where: ClassGroupTeacherSubjectsBoolExp!
}

# aggregate variance on columns
type ClassGroupTeacherSubjectsVarianceFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by variance() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsVarianceOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate varPop on columns
type ClassGroupTeacherSubjectsVarPopFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by varPop() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsVarPopOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate varSamp on columns
type ClassGroupTeacherSubjectsVarSampFields {
  classGroupTeacherId: Float
  subjectId: Float
}

# order by varSamp() on columns of table "class_group_teacher_subjects"
input ClassGroupTeacherSubjectsVarSampOrderBy {
  classGroupTeacherId: OrderBy
  subjectId: OrderBy
}

# aggregate sum on columns
type ClassGroupTeacherSumFields {
  classGroupId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "class_group_teacher"
input ClassGroupTeacherSumOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "class_group_teacher"
enum ClassGroupTeacherUpdateColumn {
  # column name
  classGroupId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  endDate

  # column name
  hiddenAt

  # column name
  id

  # column name
  startDate

  # column name
  tenantId

  # column name
  userId
}

input ClassGroupTeacherUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ClassGroupTeacherIncInput

  # sets the columns of the filtered rows to the given values
  _set: ClassGroupTeacherSetInput

  # filter the rows which have to be updated
  where: ClassGroupTeacherBoolExp!
}

# aggregate variance on columns
type ClassGroupTeacherVarianceFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "class_group_teacher"
input ClassGroupTeacherVarianceOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type ClassGroupTeacherVarPopFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "class_group_teacher"
input ClassGroupTeacherVarPopOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type ClassGroupTeacherVarSampFields {
  classGroupId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "class_group_teacher"
input ClassGroupTeacherVarSampOrderBy {
  classGroupId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "class_group"
enum ClassGroupUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type
}

input ClassGroupUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ClassGroupIncInput

  # sets the columns of the filtered rows to the given values
  _set: ClassGroupSetInput

  # filter the rows which have to be updated
  where: ClassGroupBoolExp!
}

# aggregate variance on columns
type ClassGroupVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "class_group"
input ClassGroupVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ClassGroupVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "class_group"
input ClassGroupVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ClassGroupVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "class_group"
input ClassGroupVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "cohort"
type Cohort {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  year: smallint!
}

# aggregated selection of "cohort"
type CohortAggregate {
  aggregate: CohortAggregateFields
  nodes: [Cohort!]!
}

input CohortAggregateBoolExp {
  count: cohortAggregateBoolExpCount
}

input cohortAggregateBoolExpCount {
  arguments: [CohortSelectColumn!]
  distinct: Boolean
  filter: CohortBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "cohort"
type CohortAggregateFields {
  avg: CohortAvgFields
  count(columns: [CohortSelectColumn!], distinct: Boolean): Int!
  max: CohortMaxFields
  min: CohortMinFields
  stddev: CohortStddevFields
  stddevPop: CohortStddevPopFields
  stddevSamp: CohortStddevSampFields
  sum: CohortSumFields
  varPop: CohortVarPopFields
  varSamp: CohortVarSampFields
  variance: CohortVarianceFields
}

# order by aggregate values of table "cohort"
input CohortAggregateOrderBy {
  avg: CohortAvgOrderBy
  count: OrderBy
  max: CohortMaxOrderBy
  min: CohortMinOrderBy
  stddev: CohortStddevOrderBy
  stddevPop: CohortStddevPopOrderBy
  stddevSamp: CohortStddevSampOrderBy
  sum: CohortSumOrderBy
  varPop: CohortVarPopOrderBy
  varSamp: CohortVarSampOrderBy
  variance: CohortVarianceOrderBy
}

# input type for inserting array relation for remote table "cohort"
input CohortArrRelInsertInput {
  data: [CohortInsertInput!]!

  # upsert condition
  onConflict: CohortOnConflict
}

# aggregate avg on columns
type CohortAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by avg() on columns of table "cohort"
input CohortAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# Boolean expression to filter rows from the table "cohort". All fields are combined with a logical 'AND'.
input CohortBoolExp {
  _and: [CohortBoolExp!]
  _not: CohortBoolExp
  _or: [CohortBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  year: SmallintComparisonExp
}

# unique or primary key constraints on table "cohort"
enum CohortConstraint {
  # unique or primary key constraint on columns "id"
  cohort_pkey
}

# input type for incrementing numeric columns in table "cohort"
input CohortIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
  year: smallint
}

# input type for inserting data into table "cohort"
input CohortInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  year: smallint
}

# aggregate max on columns
type CohortMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  year: smallint
}

# order by max() on columns of table "cohort"
input CohortMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# aggregate min on columns
type CohortMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  year: smallint
}

# order by min() on columns of table "cohort"
input CohortMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# response of any mutation on the table "cohort"
type CohortMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Cohort!]!
}

# input type for inserting object relation for remote table "cohort"
input CohortObjRelInsertInput {
  data: CohortInsertInput!

  # upsert condition
  onConflict: CohortOnConflict
}

# on_conflict condition type for table "cohort"
input CohortOnConflict {
  constraint: CohortConstraint!
  updateColumns: [CohortUpdateColumn!]! = []
  where: CohortBoolExp
}

# Ordering options when selecting data from "cohort".
input CohortOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  year: OrderBy
}

# primary key columns input for table: cohort
input CohortPkColumnsInput {
  id: bigint!
}

# select columns of table "cohort"
enum CohortSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  year
}

# input type for updating data in table "cohort"
input CohortSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  year: smallint
}

# aggregate stddev on columns
type CohortStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by stddev() on columns of table "cohort"
input CohortStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# aggregate stddevPop on columns
type CohortStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by stddevPop() on columns of table "cohort"
input CohortStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# aggregate stddevSamp on columns
type CohortStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by stddevSamp() on columns of table "cohort"
input CohortStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# Streaming cursor of the table "cohort"
input CohortStreamCursorInput {
  # Stream column input with initial value
  initialValue: CohortStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CohortStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  year: smallint
}

# aggregate sum on columns
type CohortSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
  year: smallint
}

# order by sum() on columns of table "cohort"
input CohortSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# update columns of table "cohort"
enum CohortUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  year
}

input CohortUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CohortIncInput

  # sets the columns of the filtered rows to the given values
  _set: CohortSetInput

  # filter the rows which have to be updated
  where: CohortBoolExp!
}

# aggregate variance on columns
type CohortVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by variance() on columns of table "cohort"
input CohortVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# aggregate varPop on columns
type CohortVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by varPop() on columns of table "cohort"
input CohortVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# aggregate varSamp on columns
type CohortVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
  year: Float
}

# order by varSamp() on columns of table "cohort"
input CohortVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  year: OrderBy
}

# columns and relationships of "content"
type Content {
  # An array relationship
  children(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # An aggregate relationship
  childrenAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!

  # An array relationship
  contentAttachments(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): [ContentAttachments!]!

  # An aggregate relationship
  contentAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): ContentAttachmentsAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event

  # An array relationship
  favorites(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # An aggregate relationship
  favoritesAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isAnonymous: Boolean!

  # An object relationship
  issue: Issue

  # An object relationship
  parent: Content
  parentId: bigint

  # An array relationship
  reactions(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # An aggregate relationship
  reactionsAggregate(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): ReactionAggregate!

  # An array relationship
  replies(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # An aggregate relationship
  repliesAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!

  # An object relationship
  replyingTo: Content
  replyingToId: bigint

  # An array relationship
  reports(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # An aggregate relationship
  reportsAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # An object relationship
  team: Team
  teamId: bigint

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  text: String!

  # An object relationship
  thread: Thread

  # An array relationship
  validations(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # An aggregate relationship
  validationsAggregate(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): ValidationAggregate!

  # An array relationship
  votes(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!

  # An aggregate relationship
  votesAggregate(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): VoteAggregate!
}

# aggregated selection of "content"
type ContentAggregate {
  aggregate: ContentAggregateFields
  nodes: [Content!]!
}

input ContentAggregateBoolExp {
  bool_and: contentAggregateBoolExpBool_and
  bool_or: contentAggregateBoolExpBool_or
  count: contentAggregateBoolExpCount
}

input contentAggregateBoolExpBool_and {
  arguments: ContentSelectColumnContentAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ContentBoolExp
  predicate: BooleanComparisonExp!
}

input contentAggregateBoolExpBool_or {
  arguments: ContentSelectColumnContentAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ContentBoolExp
  predicate: BooleanComparisonExp!
}

input contentAggregateBoolExpCount {
  arguments: [ContentSelectColumn!]
  distinct: Boolean
  filter: ContentBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "content"
type ContentAggregateFields {
  avg: ContentAvgFields
  count(columns: [ContentSelectColumn!], distinct: Boolean): Int!
  max: ContentMaxFields
  min: ContentMinFields
  stddev: ContentStddevFields
  stddevPop: ContentStddevPopFields
  stddevSamp: ContentStddevSampFields
  sum: ContentSumFields
  varPop: ContentVarPopFields
  varSamp: ContentVarSampFields
  variance: ContentVarianceFields
}

# order by aggregate values of table "content"
input ContentAggregateOrderBy {
  avg: ContentAvgOrderBy
  count: OrderBy
  max: ContentMaxOrderBy
  min: ContentMinOrderBy
  stddev: ContentStddevOrderBy
  stddevPop: ContentStddevPopOrderBy
  stddevSamp: ContentStddevSampOrderBy
  sum: ContentSumOrderBy
  varPop: ContentVarPopOrderBy
  varSamp: ContentVarSampOrderBy
  variance: ContentVarianceOrderBy
}

# input type for inserting array relation for remote table "content"
input ContentArrRelInsertInput {
  data: [ContentInsertInput!]!

  # upsert condition
  onConflict: ContentOnConflict
}

# columns and relationships of "content_attachments"
type ContentAttachments {
  # An object relationship
  content: Content!
  contentId: bigint!

  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!
}

# aggregated selection of "content_attachments"
type ContentAttachmentsAggregate {
  aggregate: ContentAttachmentsAggregateFields
  nodes: [ContentAttachments!]!
}

input ContentAttachmentsAggregateBoolExp {
  count: contentAttachmentsAggregateBoolExpCount
}

input contentAttachmentsAggregateBoolExpCount {
  arguments: [ContentAttachmentsSelectColumn!]
  distinct: Boolean
  filter: ContentAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "content_attachments"
type ContentAttachmentsAggregateFields {
  avg: ContentAttachmentsAvgFields
  count(columns: [ContentAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: ContentAttachmentsMaxFields
  min: ContentAttachmentsMinFields
  stddev: ContentAttachmentsStddevFields
  stddevPop: ContentAttachmentsStddevPopFields
  stddevSamp: ContentAttachmentsStddevSampFields
  sum: ContentAttachmentsSumFields
  varPop: ContentAttachmentsVarPopFields
  varSamp: ContentAttachmentsVarSampFields
  variance: ContentAttachmentsVarianceFields
}

# order by aggregate values of table "content_attachments"
input ContentAttachmentsAggregateOrderBy {
  avg: ContentAttachmentsAvgOrderBy
  count: OrderBy
  max: ContentAttachmentsMaxOrderBy
  min: ContentAttachmentsMinOrderBy
  stddev: ContentAttachmentsStddevOrderBy
  stddevPop: ContentAttachmentsStddevPopOrderBy
  stddevSamp: ContentAttachmentsStddevSampOrderBy
  sum: ContentAttachmentsSumOrderBy
  varPop: ContentAttachmentsVarPopOrderBy
  varSamp: ContentAttachmentsVarSampOrderBy
  variance: ContentAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "content_attachments"
input ContentAttachmentsArrRelInsertInput {
  data: [ContentAttachmentsInsertInput!]!

  # upsert condition
  onConflict: ContentAttachmentsOnConflict
}

# aggregate avg on columns
type ContentAttachmentsAvgFields {
  contentId: Float
  fileUploadId: Float
}

# order by avg() on columns of table "content_attachments"
input ContentAttachmentsAvgOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# Boolean expression to filter rows from the table "content_attachments". All fields are combined with a logical 'AND'.
input ContentAttachmentsBoolExp {
  _and: [ContentAttachmentsBoolExp!]
  _not: ContentAttachmentsBoolExp
  _or: [ContentAttachmentsBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
}

# unique or primary key constraints on table "content_attachments"
enum ContentAttachmentsConstraint {
  # unique or primary key constraint on columns "file_upload_id", "content_id"
  content_attachments_pkey
}

# input type for incrementing numeric columns in table "content_attachments"
input ContentAttachmentsIncInput {
  contentId: bigint
  fileUploadId: bigint
}

# input type for inserting data into table "content_attachments"
input ContentAttachmentsInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
}

# aggregate max on columns
type ContentAttachmentsMaxFields {
  contentId: bigint
  fileUploadId: bigint
}

# order by max() on columns of table "content_attachments"
input ContentAttachmentsMaxOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate min on columns
type ContentAttachmentsMinFields {
  contentId: bigint
  fileUploadId: bigint
}

# order by min() on columns of table "content_attachments"
input ContentAttachmentsMinOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# response of any mutation on the table "content_attachments"
type ContentAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ContentAttachments!]!
}

# on_conflict condition type for table "content_attachments"
input ContentAttachmentsOnConflict {
  constraint: ContentAttachmentsConstraint!
  updateColumns: [ContentAttachmentsUpdateColumn!]! = []
  where: ContentAttachmentsBoolExp
}

# Ordering options when selecting data from "content_attachments".
input ContentAttachmentsOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
}

# primary key columns input for table: content_attachments
input ContentAttachmentsPkColumnsInput {
  contentId: bigint!
  fileUploadId: bigint!
}

# select columns of table "content_attachments"
enum ContentAttachmentsSelectColumn {
  # column name
  contentId

  # column name
  fileUploadId
}

# input type for updating data in table "content_attachments"
input ContentAttachmentsSetInput {
  contentId: bigint
  fileUploadId: bigint
}

# aggregate stddev on columns
type ContentAttachmentsStddevFields {
  contentId: Float
  fileUploadId: Float
}

# order by stddev() on columns of table "content_attachments"
input ContentAttachmentsStddevOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevPop on columns
type ContentAttachmentsStddevPopFields {
  contentId: Float
  fileUploadId: Float
}

# order by stddevPop() on columns of table "content_attachments"
input ContentAttachmentsStddevPopOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevSamp on columns
type ContentAttachmentsStddevSampFields {
  contentId: Float
  fileUploadId: Float
}

# order by stddevSamp() on columns of table "content_attachments"
input ContentAttachmentsStddevSampOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# Streaming cursor of the table "content_attachments"
input ContentAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ContentAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ContentAttachmentsStreamCursorValueInput {
  contentId: bigint
  fileUploadId: bigint
}

# aggregate sum on columns
type ContentAttachmentsSumFields {
  contentId: bigint
  fileUploadId: bigint
}

# order by sum() on columns of table "content_attachments"
input ContentAttachmentsSumOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# update columns of table "content_attachments"
enum ContentAttachmentsUpdateColumn {
  # column name
  contentId

  # column name
  fileUploadId
}

input ContentAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ContentAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ContentAttachmentsSetInput

  # filter the rows which have to be updated
  where: ContentAttachmentsBoolExp!
}

# aggregate variance on columns
type ContentAttachmentsVarianceFields {
  contentId: Float
  fileUploadId: Float
}

# order by variance() on columns of table "content_attachments"
input ContentAttachmentsVarianceOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varPop on columns
type ContentAttachmentsVarPopFields {
  contentId: Float
  fileUploadId: Float
}

# order by varPop() on columns of table "content_attachments"
input ContentAttachmentsVarPopOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varSamp on columns
type ContentAttachmentsVarSampFields {
  contentId: Float
  fileUploadId: Float
}

# order by varSamp() on columns of table "content_attachments"
input ContentAttachmentsVarSampOrderBy {
  contentId: OrderBy
  fileUploadId: OrderBy
}

# aggregate avg on columns
type ContentAvgFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "content"
input ContentAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "content". All fields are combined with a logical 'AND'.
input ContentBoolExp {
  _and: [ContentBoolExp!]
  _not: ContentBoolExp
  _or: [ContentBoolExp!]
  children: ContentBoolExp
  childrenAggregate: ContentAggregateBoolExp
  contentAttachments: ContentAttachmentsBoolExp
  contentAttachmentsAggregate: ContentAttachmentsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  favorites: FavoriteBoolExp
  favoritesAggregate: FavoriteAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAnonymous: BooleanComparisonExp
  issue: IssueBoolExp
  parent: ContentBoolExp
  parentId: BigintComparisonExp
  reactions: ReactionBoolExp
  reactionsAggregate: ReactionAggregateBoolExp
  replies: ContentBoolExp
  repliesAggregate: ContentAggregateBoolExp
  replyingTo: ContentBoolExp
  replyingToId: BigintComparisonExp
  reports: ReportBoolExp
  reportsAggregate: ReportAggregateBoolExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  text: StringComparisonExp
  thread: ThreadBoolExp
  validations: ValidationBoolExp
  validationsAggregate: ValidationAggregateBoolExp
  votes: VoteBoolExp
  votesAggregate: VoteAggregateBoolExp
}

# unique or primary key constraints on table "content"
enum ContentConstraint {
  # unique or primary key constraint on columns "id"
  content_pkey
}

# input type for incrementing numeric columns in table "content"
input ContentIncInput {
  createdById: bigint
  id: bigint
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "content"
input ContentInsertInput {
  children: ContentArrRelInsertInput
  contentAttachments: ContentAttachmentsArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  favorites: FavoriteArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAnonymous: Boolean
  issue: IssueObjRelInsertInput
  parent: ContentObjRelInsertInput
  parentId: bigint
  reactions: ReactionArrRelInsertInput
  replies: ContentArrRelInsertInput
  replyingTo: ContentObjRelInsertInput
  replyingToId: bigint
  reports: ReportArrRelInsertInput
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  text: String
  thread: ThreadObjRelInsertInput
  validations: ValidationArrRelInsertInput
  votes: VoteArrRelInsertInput
}

# aggregate max on columns
type ContentMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
  text: String
}

# order by max() on columns of table "content"
input ContentMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  text: OrderBy
}

# aggregate min on columns
type ContentMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
  text: String
}

# order by min() on columns of table "content"
input ContentMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  text: OrderBy
}

# response of any mutation on the table "content"
type ContentMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Content!]!
}

# input type for inserting object relation for remote table "content"
input ContentObjRelInsertInput {
  data: ContentInsertInput!

  # upsert condition
  onConflict: ContentOnConflict
}

# on_conflict condition type for table "content"
input ContentOnConflict {
  constraint: ContentConstraint!
  updateColumns: [ContentUpdateColumn!]! = []
  where: ContentBoolExp
}

# Ordering options when selecting data from "content".
input ContentOrderBy {
  childrenAggregate: ContentAggregateOrderBy
  contentAttachmentsAggregate: ContentAttachmentsAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  favoritesAggregate: FavoriteAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAnonymous: OrderBy
  issue: IssueOrderBy
  parent: ContentOrderBy
  parentId: OrderBy
  reactionsAggregate: ReactionAggregateOrderBy
  repliesAggregate: ContentAggregateOrderBy
  replyingTo: ContentOrderBy
  replyingToId: OrderBy
  reportsAggregate: ReportAggregateOrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  text: OrderBy
  thread: ThreadOrderBy
  validationsAggregate: ValidationAggregateOrderBy
  votesAggregate: VoteAggregateOrderBy
}

# primary key columns input for table: content
input ContentPkColumnsInput {
  id: bigint!
}

# select columns of table "content"
enum ContentSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAnonymous

  # column name
  parentId

  # column name
  replyingToId

  # column name
  teamId

  # column name
  tenantId

  # column name
  text
}

# select "contentAggregateBoolExpBool_andArgumentsColumns" columns of table "content"
enum ContentSelectColumnContentAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAnonymous
}

# select "contentAggregateBoolExpBool_orArgumentsColumns" columns of table "content"
enum ContentSelectColumnContentAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAnonymous
}

# input type for updating data in table "content"
input ContentSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAnonymous: Boolean
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
  text: String
}

# aggregate stddev on columns
type ContentStddevFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "content"
input ContentStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ContentStddevPopFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "content"
input ContentStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ContentStddevSampFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "content"
input ContentStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "content"
input ContentStreamCursorInput {
  # Stream column input with initial value
  initialValue: ContentStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ContentStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAnonymous: Boolean
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
  text: String
}

# aggregate sum on columns
type ContentSumFields {
  createdById: bigint
  id: bigint
  parentId: bigint
  replyingToId: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "content"
input ContentSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "content"
enum ContentUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAnonymous

  # column name
  parentId

  # column name
  replyingToId

  # column name
  teamId

  # column name
  tenantId

  # column name
  text
}

input ContentUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ContentIncInput

  # sets the columns of the filtered rows to the given values
  _set: ContentSetInput

  # filter the rows which have to be updated
  where: ContentBoolExp!
}

# aggregate variance on columns
type ContentVarianceFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "content"
input ContentVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ContentVarPopFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "content"
input ContentVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ContentVarSampFields {
  createdById: Float
  id: Float
  parentId: Float
  replyingToId: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "content"
input ContentVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  replyingToId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# ordering argument of a cursor
enum CursorOrdering {
  # ascending ordering of the cursor
  ASC

  # descending ordering of the cursor
  DESC
}

# columns and relationships of "document"
type Document {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  fileId: bigint

  # An object relationship
  fileUpload: FileUpload
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An object relationship
  subject: Subject
  subjectId: bigint

  # An object relationship
  team: Team
  teamId: bigint

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
  yearVersion: smallint
}

# aggregated selection of "document"
type DocumentAggregate {
  aggregate: DocumentAggregateFields
  nodes: [Document!]!
}

input DocumentAggregateBoolExp {
  count: documentAggregateBoolExpCount
}

input documentAggregateBoolExpCount {
  arguments: [DocumentSelectColumn!]
  distinct: Boolean
  filter: DocumentBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "document"
type DocumentAggregateFields {
  avg: DocumentAvgFields
  count(columns: [DocumentSelectColumn!], distinct: Boolean): Int!
  max: DocumentMaxFields
  min: DocumentMinFields
  stddev: DocumentStddevFields
  stddevPop: DocumentStddevPopFields
  stddevSamp: DocumentStddevSampFields
  sum: DocumentSumFields
  varPop: DocumentVarPopFields
  varSamp: DocumentVarSampFields
  variance: DocumentVarianceFields
}

# order by aggregate values of table "document"
input DocumentAggregateOrderBy {
  avg: DocumentAvgOrderBy
  count: OrderBy
  max: DocumentMaxOrderBy
  min: DocumentMinOrderBy
  stddev: DocumentStddevOrderBy
  stddevPop: DocumentStddevPopOrderBy
  stddevSamp: DocumentStddevSampOrderBy
  sum: DocumentSumOrderBy
  varPop: DocumentVarPopOrderBy
  varSamp: DocumentVarSampOrderBy
  variance: DocumentVarianceOrderBy
}

# input type for inserting array relation for remote table "document"
input DocumentArrRelInsertInput {
  data: [DocumentInsertInput!]!

  # upsert condition
  onConflict: DocumentOnConflict
}

# aggregate avg on columns
type DocumentAvgFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by avg() on columns of table "document"
input DocumentAvgOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# Boolean expression to filter rows from the table "document". All fields are combined with a logical 'AND'.
input DocumentBoolExp {
  _and: [DocumentBoolExp!]
  _not: DocumentBoolExp
  _or: [DocumentBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  fileId: BigintComparisonExp
  fileUpload: FileUploadBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  subject: SubjectBoolExp
  subjectId: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
  yearVersion: SmallintComparisonExp
}

# unique or primary key constraints on table "document"
enum DocumentConstraint {
  # unique or primary key constraint on columns "file_id"
  document_file_id_unique

  # unique or primary key constraint on columns "id"
  document_pkey
}

# input type for incrementing numeric columns in table "document"
input DocumentIncInput {
  createdById: bigint
  fileId: bigint
  id: bigint
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  yearVersion: smallint
}

# input type for inserting data into table "document"
input DocumentInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  fileUpload: FileUploadObjRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  name: String
  subject: SubjectObjRelInsertInput
  subjectId: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
  yearVersion: smallint
}

# aggregate max on columns
type DocumentMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  type: String
  yearVersion: smallint
}

# order by max() on columns of table "document"
input DocumentMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  fileId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# aggregate min on columns
type DocumentMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  type: String
  yearVersion: smallint
}

# order by min() on columns of table "document"
input DocumentMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  fileId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# response of any mutation on the table "document"
type DocumentMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Document!]!
}

# input type for inserting object relation for remote table "document"
input DocumentObjRelInsertInput {
  data: DocumentInsertInput!

  # upsert condition
  onConflict: DocumentOnConflict
}

# on_conflict condition type for table "document"
input DocumentOnConflict {
  constraint: DocumentConstraint!
  updateColumns: [DocumentUpdateColumn!]! = []
  where: DocumentBoolExp
}

# Ordering options when selecting data from "document".
input DocumentOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  fileId: OrderBy
  fileUpload: FileUploadOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  subject: SubjectOrderBy
  subjectId: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# primary key columns input for table: document
input DocumentPkColumnsInput {
  id: bigint!
}

# select columns of table "document"
enum DocumentSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  fileId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  subjectId

  # column name
  teamId

  # column name
  tenantId

  # column name
  type

  # column name
  yearVersion
}

# input type for updating data in table "document"
input DocumentSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  type: String
  yearVersion: smallint
}

# aggregate stddev on columns
type DocumentStddevFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by stddev() on columns of table "document"
input DocumentStddevOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# aggregate stddevPop on columns
type DocumentStddevPopFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by stddevPop() on columns of table "document"
input DocumentStddevPopOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# aggregate stddevSamp on columns
type DocumentStddevSampFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by stddevSamp() on columns of table "document"
input DocumentStddevSampOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# Streaming cursor of the table "document"
input DocumentStreamCursorInput {
  # Stream column input with initial value
  initialValue: DocumentStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input DocumentStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  type: String
  yearVersion: smallint
}

# aggregate sum on columns
type DocumentSumFields {
  createdById: bigint
  fileId: bigint
  id: bigint
  subjectId: bigint
  teamId: bigint
  tenantId: bigint
  yearVersion: smallint
}

# order by sum() on columns of table "document"
input DocumentSumOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# update columns of table "document"
enum DocumentUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  fileId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  subjectId

  # column name
  teamId

  # column name
  tenantId

  # column name
  type

  # column name
  yearVersion
}

input DocumentUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: DocumentIncInput

  # sets the columns of the filtered rows to the given values
  _set: DocumentSetInput

  # filter the rows which have to be updated
  where: DocumentBoolExp!
}

# aggregate variance on columns
type DocumentVarianceFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by variance() on columns of table "document"
input DocumentVarianceOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# aggregate varPop on columns
type DocumentVarPopFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by varPop() on columns of table "document"
input DocumentVarPopOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# aggregate varSamp on columns
type DocumentVarSampFields {
  createdById: Float
  fileId: Float
  id: Float
  subjectId: Float
  teamId: Float
  tenantId: Float
  yearVersion: Float
}

# order by varSamp() on columns of table "document"
input DocumentVarSampOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  subjectId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  yearVersion: OrderBy
}

# columns and relationships of "event"
type Event {
  # An object relationship
  address: Address
  addressId: bigint
  approvalSubmissionId: bigint

  # An object relationship
  banner: FileUpload
  bannerId: bigint

  # An object relationship
  content: Content!
  contentId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz!

  # An object relationship
  eventApprovalStep: EventApprovalStep

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  eventManages(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # An aggregate relationship
  eventManagesAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): [EventSupervisors!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): EventSupervisorsAggregate!

  # An array relationship
  eventTags(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): [EventTags!]!

  # An aggregate relationship
  eventTagsAggregate(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): EventTagsAggregate!

  # An array relationship
  finances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  financesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An object relationship
  form: Form

  # An object relationship
  formSubmission: FormSubmission
  hiddenAt: timestamptz
  id: bigint!
  isAutoAcceptingJoins: Boolean!
  isPrivate: Boolean!
  isTemplate: Boolean!
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  meta(
    # JSON select path
    path: String
  ): jsonb!
  name: String!
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float!
  price: Float!

  # An object relationship
  project: Project
  projectId: bigint
  slug: String!
  start: timestamptz!
  state: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "event"
type EventAggregate {
  aggregate: EventAggregateFields
  nodes: [Event!]!
}

input EventAggregateBoolExp {
  bool_and: eventAggregateBoolExpBool_and
  bool_or: eventAggregateBoolExpBool_or
  count: eventAggregateBoolExpCount
}

input eventAggregateBoolExpBool_and {
  arguments: EventSelectColumnEventAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}

input eventAggregateBoolExpBool_or {
  arguments: EventSelectColumnEventAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}

input eventAggregateBoolExpCount {
  arguments: [EventSelectColumn!]
  distinct: Boolean
  filter: EventBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event"
type EventAggregateFields {
  avg: EventAvgFields
  count(columns: [EventSelectColumn!], distinct: Boolean): Int!
  max: EventMaxFields
  min: EventMinFields
  stddev: EventStddevFields
  stddevPop: EventStddevPopFields
  stddevSamp: EventStddevSampFields
  sum: EventSumFields
  varPop: EventVarPopFields
  varSamp: EventVarSampFields
  variance: EventVarianceFields
}

# order by aggregate values of table "event"
input EventAggregateOrderBy {
  avg: EventAvgOrderBy
  count: OrderBy
  max: EventMaxOrderBy
  min: EventMinOrderBy
  stddev: EventStddevOrderBy
  stddevPop: EventStddevPopOrderBy
  stddevSamp: EventStddevSampOrderBy
  sum: EventSumOrderBy
  varPop: EventVarPopOrderBy
  varSamp: EventVarSampOrderBy
  variance: EventVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input EventAppendInput {
  meta: jsonb
}

# columns and relationships of "event_approval"
type EventApproval {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event

  # An object relationship
  eventApprovalStep: EventApprovalStep
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isApproved: Boolean!
  message: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "event_approval"
type EventApprovalAggregate {
  aggregate: EventApprovalAggregateFields
  nodes: [EventApproval!]!
}

input EventApprovalAggregateBoolExp {
  bool_and: eventApprovalAggregateBoolExpBool_and
  bool_or: eventApprovalAggregateBoolExpBool_or
  count: eventApprovalAggregateBoolExpCount
}

input eventApprovalAggregateBoolExpBool_and {
  arguments: EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: BooleanComparisonExp!
}

input eventApprovalAggregateBoolExpBool_or {
  arguments: EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: BooleanComparisonExp!
}

input eventApprovalAggregateBoolExpCount {
  arguments: [EventApprovalSelectColumn!]
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval"
type EventApprovalAggregateFields {
  avg: EventApprovalAvgFields
  count(columns: [EventApprovalSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalMaxFields
  min: EventApprovalMinFields
  stddev: EventApprovalStddevFields
  stddevPop: EventApprovalStddevPopFields
  stddevSamp: EventApprovalStddevSampFields
  sum: EventApprovalSumFields
  varPop: EventApprovalVarPopFields
  varSamp: EventApprovalVarSampFields
  variance: EventApprovalVarianceFields
}

# order by aggregate values of table "event_approval"
input EventApprovalAggregateOrderBy {
  avg: EventApprovalAvgOrderBy
  count: OrderBy
  max: EventApprovalMaxOrderBy
  min: EventApprovalMinOrderBy
  stddev: EventApprovalStddevOrderBy
  stddevPop: EventApprovalStddevPopOrderBy
  stddevSamp: EventApprovalStddevSampOrderBy
  sum: EventApprovalSumOrderBy
  varPop: EventApprovalVarPopOrderBy
  varSamp: EventApprovalVarSampOrderBy
  variance: EventApprovalVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval"
input EventApprovalArrRelInsertInput {
  data: [EventApprovalInsertInput!]!

  # upsert condition
  onConflict: EventApprovalOnConflict
}

# aggregate avg on columns
type EventApprovalAvgFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "event_approval"
input EventApprovalAvgOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "event_approval". All fields are combined with a logical 'AND'.
input EventApprovalBoolExp {
  _and: [EventApprovalBoolExp!]
  _not: EventApprovalBoolExp
  _or: [EventApprovalBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  eventId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isApproved: BooleanComparisonExp
  message: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval"
enum EventApprovalConstraint {
  # unique or primary key constraint on columns "id"
  event_approval_pkey
}

# input type for incrementing numeric columns in table "event_approval"
input EventApprovalIncInput {
  createdById: bigint
  eventApprovalStepId: bigint
  eventId: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "event_approval"
input EventApprovalInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type EventApprovalMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  message: String
  tenantId: bigint
}

# order by max() on columns of table "event_approval"
input EventApprovalMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  message: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type EventApprovalMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  message: String
  tenantId: bigint
}

# order by min() on columns of table "event_approval"
input EventApprovalMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  message: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "event_approval"
type EventApprovalMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApproval!]!
}

# on_conflict condition type for table "event_approval"
input EventApprovalOnConflict {
  constraint: EventApprovalConstraint!
  updateColumns: [EventApprovalUpdateColumn!]! = []
  where: EventApprovalBoolExp
}

# Ordering options when selecting data from "event_approval".
input EventApprovalOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isApproved: OrderBy
  message: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: event_approval
input EventApprovalPkColumnsInput {
  id: bigint!
}

# select columns of table "event_approval"
enum EventApprovalSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventApprovalStepId

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isApproved

  # column name
  message

  # column name
  tenantId
}

# select "eventApprovalAggregateBoolExpBool_andArgumentsColumns" columns of table "event_approval"
enum EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isApproved
}

# select "eventApprovalAggregateBoolExpBool_orArgumentsColumns" columns of table "event_approval"
enum EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isApproved
}

# input type for updating data in table "event_approval"
input EventApprovalSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenantId: bigint
}

# aggregate stddev on columns
type EventApprovalStddevFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "event_approval"
input EventApprovalStddevOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStddevPopFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "event_approval"
input EventApprovalStddevPopOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStddevSampFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "event_approval"
input EventApprovalStddevSampOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "event_approval_step"
type EventApprovalStep {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  lastStepEvents(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  lastStepEventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!
  name: String!

  # An array relationship
  nextSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  nextStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # An object relationship
  previousStep: EventApprovalStep
  previousStepId: bigint

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "event_approval_step"
type EventApprovalStepAggregate {
  aggregate: EventApprovalStepAggregateFields
  nodes: [EventApprovalStep!]!
}

input EventApprovalStepAggregateBoolExp {
  count: eventApprovalStepAggregateBoolExpCount
}

input eventApprovalStepAggregateBoolExpCount {
  arguments: [EventApprovalStepSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step"
type EventApprovalStepAggregateFields {
  avg: EventApprovalStepAvgFields
  count(columns: [EventApprovalStepSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepMaxFields
  min: EventApprovalStepMinFields
  stddev: EventApprovalStepStddevFields
  stddevPop: EventApprovalStepStddevPopFields
  stddevSamp: EventApprovalStepStddevSampFields
  sum: EventApprovalStepSumFields
  varPop: EventApprovalStepVarPopFields
  varSamp: EventApprovalStepVarSampFields
  variance: EventApprovalStepVarianceFields
}

# order by aggregate values of table "event_approval_step"
input EventApprovalStepAggregateOrderBy {
  avg: EventApprovalStepAvgOrderBy
  count: OrderBy
  max: EventApprovalStepMaxOrderBy
  min: EventApprovalStepMinOrderBy
  stddev: EventApprovalStepStddevOrderBy
  stddevPop: EventApprovalStepStddevPopOrderBy
  stddevSamp: EventApprovalStepStddevSampOrderBy
  sum: EventApprovalStepSumOrderBy
  varPop: EventApprovalStepVarPopOrderBy
  varSamp: EventApprovalStepVarSampOrderBy
  variance: EventApprovalStepVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step"
input EventApprovalStepArrRelInsertInput {
  data: [EventApprovalStepInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepOnConflict
}

# aggregate avg on columns
type EventApprovalStepAvgFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by avg() on columns of table "event_approval_step"
input EventApprovalStepAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "event_approval_step". All fields are combined with a logical 'AND'.
input EventApprovalStepBoolExp {
  _and: [EventApprovalStepBoolExp!]
  _not: EventApprovalStepBoolExp
  _or: [EventApprovalStepBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventApprovalStepNotifiees: EventApprovalStepNotifieesBoolExp
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateBoolExp
  eventApprovalStepValidators: EventApprovalStepValidatorsBoolExp
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateBoolExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastStepEvents: EventBoolExp
  lastStepEventsAggregate: EventAggregateBoolExp
  name: StringComparisonExp
  nextSteps: EventApprovalStepBoolExp
  nextStepsAggregate: EventApprovalStepAggregateBoolExp
  previousStep: EventApprovalStepBoolExp
  previousStepId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step"
enum EventApprovalStepConstraint {
  # unique or primary key constraint on columns "id"
  event_approval_step_pkey
}

# input type for incrementing numeric columns in table "event_approval_step"
input EventApprovalStepIncInput {
  createdById: bigint
  id: bigint
  previousStepId: bigint
  tenantId: bigint
}

# input type for inserting data into table "event_approval_step"
input EventApprovalStepInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventApprovalStepNotifiees: EventApprovalStepNotifieesArrRelInsertInput
  eventApprovalStepValidators: EventApprovalStepValidatorsArrRelInsertInput
  eventApprovals: EventApprovalArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  lastStepEvents: EventArrRelInsertInput
  name: String
  nextSteps: EventApprovalStepArrRelInsertInput
  previousStep: EventApprovalStepObjRelInsertInput
  previousStepId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type EventApprovalStepMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  previousStepId: bigint
  tenantId: bigint
}

# order by max() on columns of table "event_approval_step"
input EventApprovalStepMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type EventApprovalStepMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  previousStepId: bigint
  tenantId: bigint
}

# order by min() on columns of table "event_approval_step"
input EventApprovalStepMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "event_approval_step"
type EventApprovalStepMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStep!]!
}

# columns and relationships of "event_approval_step_notifiees"
type EventApprovalStepNotifiees {
  # An object relationship
  eventApprovalStep: EventApprovalStep!
  eventApprovalStepId: bigint!

  # An object relationship
  individual: Individual!
  individualId: bigint!
}

# aggregated selection of "event_approval_step_notifiees"
type EventApprovalStepNotifieesAggregate {
  aggregate: EventApprovalStepNotifieesAggregateFields
  nodes: [EventApprovalStepNotifiees!]!
}

input EventApprovalStepNotifieesAggregateBoolExp {
  count: eventApprovalStepNotifieesAggregateBoolExpCount
}

input eventApprovalStepNotifieesAggregateBoolExpCount {
  arguments: [EventApprovalStepNotifieesSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepNotifieesBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step_notifiees"
type EventApprovalStepNotifieesAggregateFields {
  avg: EventApprovalStepNotifieesAvgFields
  count(columns: [EventApprovalStepNotifieesSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepNotifieesMaxFields
  min: EventApprovalStepNotifieesMinFields
  stddev: EventApprovalStepNotifieesStddevFields
  stddevPop: EventApprovalStepNotifieesStddevPopFields
  stddevSamp: EventApprovalStepNotifieesStddevSampFields
  sum: EventApprovalStepNotifieesSumFields
  varPop: EventApprovalStepNotifieesVarPopFields
  varSamp: EventApprovalStepNotifieesVarSampFields
  variance: EventApprovalStepNotifieesVarianceFields
}

# order by aggregate values of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesAggregateOrderBy {
  avg: EventApprovalStepNotifieesAvgOrderBy
  count: OrderBy
  max: EventApprovalStepNotifieesMaxOrderBy
  min: EventApprovalStepNotifieesMinOrderBy
  stddev: EventApprovalStepNotifieesStddevOrderBy
  stddevPop: EventApprovalStepNotifieesStddevPopOrderBy
  stddevSamp: EventApprovalStepNotifieesStddevSampOrderBy
  sum: EventApprovalStepNotifieesSumOrderBy
  varPop: EventApprovalStepNotifieesVarPopOrderBy
  varSamp: EventApprovalStepNotifieesVarSampOrderBy
  variance: EventApprovalStepNotifieesVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step_notifiees"
input EventApprovalStepNotifieesArrRelInsertInput {
  data: [EventApprovalStepNotifieesInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepNotifieesOnConflict
}

# aggregate avg on columns
type EventApprovalStepNotifieesAvgFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by avg() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesAvgOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# Boolean expression to filter rows from the table
# "event_approval_step_notifiees". All fields are combined with a logical 'AND'.
input EventApprovalStepNotifieesBoolExp {
  _and: [EventApprovalStepNotifieesBoolExp!]
  _not: EventApprovalStepNotifieesBoolExp
  _or: [EventApprovalStepNotifieesBoolExp!]
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  individual: IndividualBoolExp
  individualId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesConstraint {
  # unique or primary key constraint on columns "event_approval_step_id", "individual_id"
  event_approval_step_notifiees_pkey
}

# input type for incrementing numeric columns in table "event_approval_step_notifiees"
input EventApprovalStepNotifieesIncInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# input type for inserting data into table "event_approval_step_notifiees"
input EventApprovalStepNotifieesInsertInput {
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  individual: IndividualObjRelInsertInput
  individualId: bigint
}

# aggregate max on columns
type EventApprovalStepNotifieesMaxFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by max() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesMaxOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate min on columns
type EventApprovalStepNotifieesMinFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by min() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesMinOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# response of any mutation on the table "event_approval_step_notifiees"
type EventApprovalStepNotifieesMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStepNotifiees!]!
}

# on_conflict condition type for table "event_approval_step_notifiees"
input EventApprovalStepNotifieesOnConflict {
  constraint: EventApprovalStepNotifieesConstraint!
  updateColumns: [EventApprovalStepNotifieesUpdateColumn!]! = []
  where: EventApprovalStepNotifieesBoolExp
}

# Ordering options when selecting data from "event_approval_step_notifiees".
input EventApprovalStepNotifieesOrderBy {
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  individual: IndividualOrderBy
  individualId: OrderBy
}

# primary key columns input for table: event_approval_step_notifiees
input EventApprovalStepNotifieesPkColumnsInput {
  eventApprovalStepId: bigint!
  individualId: bigint!
}

# select columns of table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesSelectColumn {
  # column name
  eventApprovalStepId

  # column name
  individualId
}

# input type for updating data in table "event_approval_step_notifiees"
input EventApprovalStepNotifieesSetInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# aggregate stddev on columns
type EventApprovalStepNotifieesStddevFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddev() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepNotifieesStddevPopFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddevPop() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevPopOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepNotifieesStddevSampFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddevSamp() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevSampOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# Streaming cursor of the table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepNotifieesStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepNotifieesStreamCursorValueInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# aggregate sum on columns
type EventApprovalStepNotifieesSumFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by sum() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesSumOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# update columns of table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesUpdateColumn {
  # column name
  eventApprovalStepId

  # column name
  individualId
}

input EventApprovalStepNotifieesUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepNotifieesIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepNotifieesSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepNotifieesBoolExp!
}

# aggregate variance on columns
type EventApprovalStepNotifieesVarianceFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by variance() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarianceOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepNotifieesVarPopFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by varPop() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarPopOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepNotifieesVarSampFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by varSamp() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarSampOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# input type for inserting object relation for remote table "event_approval_step"
input EventApprovalStepObjRelInsertInput {
  data: EventApprovalStepInsertInput!

  # upsert condition
  onConflict: EventApprovalStepOnConflict
}

# on_conflict condition type for table "event_approval_step"
input EventApprovalStepOnConflict {
  constraint: EventApprovalStepConstraint!
  updateColumns: [EventApprovalStepUpdateColumn!]! = []
  where: EventApprovalStepBoolExp
}

# Ordering options when selecting data from "event_approval_step".
input EventApprovalStepOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateOrderBy
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateOrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastStepEventsAggregate: EventAggregateOrderBy
  name: OrderBy
  nextStepsAggregate: EventApprovalStepAggregateOrderBy
  previousStep: EventApprovalStepOrderBy
  previousStepId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: event_approval_step
input EventApprovalStepPkColumnsInput {
  id: bigint!
}

# select columns of table "event_approval_step"
enum EventApprovalStepSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  previousStepId

  # column name
  tenantId
}

# input type for updating data in table "event_approval_step"
input EventApprovalStepSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  previousStepId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type EventApprovalStepStddevFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by stddev() on columns of table "event_approval_step"
input EventApprovalStepStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepStddevPopFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "event_approval_step"
input EventApprovalStepStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepStddevSampFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "event_approval_step"
input EventApprovalStepStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "event_approval_step"
input EventApprovalStepStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  previousStepId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type EventApprovalStepSumFields {
  createdById: bigint
  id: bigint
  previousStepId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "event_approval_step"
input EventApprovalStepSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# update columns of table "event_approval_step"
enum EventApprovalStepUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  previousStepId

  # column name
  tenantId
}

input EventApprovalStepUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepBoolExp!
}

# columns and relationships of "event_approval_step_validators"
type EventApprovalStepValidators {
  # An object relationship
  eventApprovalStep: EventApprovalStep!
  eventApprovalStepId: bigint!

  # An object relationship
  individual: Individual!
  individualId: bigint!
}

# aggregated selection of "event_approval_step_validators"
type EventApprovalStepValidatorsAggregate {
  aggregate: EventApprovalStepValidatorsAggregateFields
  nodes: [EventApprovalStepValidators!]!
}

input EventApprovalStepValidatorsAggregateBoolExp {
  count: eventApprovalStepValidatorsAggregateBoolExpCount
}

input eventApprovalStepValidatorsAggregateBoolExpCount {
  arguments: [EventApprovalStepValidatorsSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepValidatorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step_validators"
type EventApprovalStepValidatorsAggregateFields {
  avg: EventApprovalStepValidatorsAvgFields
  count(columns: [EventApprovalStepValidatorsSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepValidatorsMaxFields
  min: EventApprovalStepValidatorsMinFields
  stddev: EventApprovalStepValidatorsStddevFields
  stddevPop: EventApprovalStepValidatorsStddevPopFields
  stddevSamp: EventApprovalStepValidatorsStddevSampFields
  sum: EventApprovalStepValidatorsSumFields
  varPop: EventApprovalStepValidatorsVarPopFields
  varSamp: EventApprovalStepValidatorsVarSampFields
  variance: EventApprovalStepValidatorsVarianceFields
}

# order by aggregate values of table "event_approval_step_validators"
input EventApprovalStepValidatorsAggregateOrderBy {
  avg: EventApprovalStepValidatorsAvgOrderBy
  count: OrderBy
  max: EventApprovalStepValidatorsMaxOrderBy
  min: EventApprovalStepValidatorsMinOrderBy
  stddev: EventApprovalStepValidatorsStddevOrderBy
  stddevPop: EventApprovalStepValidatorsStddevPopOrderBy
  stddevSamp: EventApprovalStepValidatorsStddevSampOrderBy
  sum: EventApprovalStepValidatorsSumOrderBy
  varPop: EventApprovalStepValidatorsVarPopOrderBy
  varSamp: EventApprovalStepValidatorsVarSampOrderBy
  variance: EventApprovalStepValidatorsVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step_validators"
input EventApprovalStepValidatorsArrRelInsertInput {
  data: [EventApprovalStepValidatorsInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepValidatorsOnConflict
}

# aggregate avg on columns
type EventApprovalStepValidatorsAvgFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by avg() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsAvgOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# Boolean expression to filter rows from the table
# "event_approval_step_validators". All fields are combined with a logical 'AND'.
input EventApprovalStepValidatorsBoolExp {
  _and: [EventApprovalStepValidatorsBoolExp!]
  _not: EventApprovalStepValidatorsBoolExp
  _or: [EventApprovalStepValidatorsBoolExp!]
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  individual: IndividualBoolExp
  individualId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step_validators"
enum EventApprovalStepValidatorsConstraint {
  # unique or primary key constraint on columns "event_approval_step_id", "individual_id"
  event_approval_step_validators_pkey
}

# input type for incrementing numeric columns in table "event_approval_step_validators"
input EventApprovalStepValidatorsIncInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# input type for inserting data into table "event_approval_step_validators"
input EventApprovalStepValidatorsInsertInput {
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  individual: IndividualObjRelInsertInput
  individualId: bigint
}

# aggregate max on columns
type EventApprovalStepValidatorsMaxFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by max() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsMaxOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate min on columns
type EventApprovalStepValidatorsMinFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by min() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsMinOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# response of any mutation on the table "event_approval_step_validators"
type EventApprovalStepValidatorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStepValidators!]!
}

# on_conflict condition type for table "event_approval_step_validators"
input EventApprovalStepValidatorsOnConflict {
  constraint: EventApprovalStepValidatorsConstraint!
  updateColumns: [EventApprovalStepValidatorsUpdateColumn!]! = []
  where: EventApprovalStepValidatorsBoolExp
}

# Ordering options when selecting data from "event_approval_step_validators".
input EventApprovalStepValidatorsOrderBy {
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  individual: IndividualOrderBy
  individualId: OrderBy
}

# primary key columns input for table: event_approval_step_validators
input EventApprovalStepValidatorsPkColumnsInput {
  eventApprovalStepId: bigint!
  individualId: bigint!
}

# select columns of table "event_approval_step_validators"
enum EventApprovalStepValidatorsSelectColumn {
  # column name
  eventApprovalStepId

  # column name
  individualId
}

# input type for updating data in table "event_approval_step_validators"
input EventApprovalStepValidatorsSetInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# aggregate stddev on columns
type EventApprovalStepValidatorsStddevFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddev() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepValidatorsStddevPopFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddevPop() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevPopOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepValidatorsStddevSampFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by stddevSamp() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevSampOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# Streaming cursor of the table "event_approval_step_validators"
input EventApprovalStepValidatorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepValidatorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepValidatorsStreamCursorValueInput {
  eventApprovalStepId: bigint
  individualId: bigint
}

# aggregate sum on columns
type EventApprovalStepValidatorsSumFields {
  eventApprovalStepId: bigint
  individualId: bigint
}

# order by sum() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsSumOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# update columns of table "event_approval_step_validators"
enum EventApprovalStepValidatorsUpdateColumn {
  # column name
  eventApprovalStepId

  # column name
  individualId
}

input EventApprovalStepValidatorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepValidatorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepValidatorsSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepValidatorsBoolExp!
}

# aggregate variance on columns
type EventApprovalStepValidatorsVarianceFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by variance() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarianceOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepValidatorsVarPopFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by varPop() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarPopOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepValidatorsVarSampFields {
  eventApprovalStepId: Float
  individualId: Float
}

# order by varSamp() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarSampOrderBy {
  eventApprovalStepId: OrderBy
  individualId: OrderBy
}

# aggregate variance on columns
type EventApprovalStepVarianceFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by variance() on columns of table "event_approval_step"
input EventApprovalStepVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepVarPopFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by varPop() on columns of table "event_approval_step"
input EventApprovalStepVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepVarSampFields {
  createdById: Float
  id: Float
  previousStepId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "event_approval_step"
input EventApprovalStepVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  previousStepId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "event_approval"
input EventApprovalStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenantId: bigint
}

# aggregate sum on columns
type EventApprovalSumFields {
  createdById: bigint
  eventApprovalStepId: bigint
  eventId: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "event_approval"
input EventApprovalSumOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "event_approval"
enum EventApprovalUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventApprovalStepId

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isApproved

  # column name
  message

  # column name
  tenantId
}

input EventApprovalUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalSetInput

  # filter the rows which have to be updated
  where: EventApprovalBoolExp!
}

# aggregate variance on columns
type EventApprovalVarianceFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "event_approval"
input EventApprovalVarianceOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type EventApprovalVarPopFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "event_approval"
input EventApprovalVarPopOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalVarSampFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "event_approval"
input EventApprovalVarSampOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# input type for inserting array relation for remote table "event"
input EventArrRelInsertInput {
  data: [EventInsertInput!]!

  # upsert condition
  onConflict: EventOnConflict
}

# aggregate avg on columns
type EventAvgFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by avg() on columns of table "event"
input EventAvgOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input EventBoolExp {
  _and: [EventBoolExp!]
  _not: EventBoolExp
  _or: [EventBoolExp!]
  address: AddressBoolExp
  addressId: BigintComparisonExp
  approvalSubmissionId: BigintComparisonExp
  banner: FileUploadBoolExp
  bannerId: BigintComparisonExp
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  end: TimestamptzComparisonExp
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  eventManages: EventManageBoolExp
  eventManagesAggregate: EventManageAggregateBoolExp
  eventSupervisors: EventSupervisorsBoolExp
  eventSupervisorsAggregate: EventSupervisorsAggregateBoolExp
  eventTags: EventTagsBoolExp
  eventTagsAggregate: EventTagsAggregateBoolExp
  finances: FinanceBoolExp
  financesAggregate: FinanceAggregateBoolExp
  form: FormBoolExp
  formSubmission: FormSubmissionBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAutoAcceptingJoins: BooleanComparisonExp
  isPrivate: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  joinFormId: BigintComparisonExp
  lastEventApprovalStepId: BigintComparisonExp
  maxParticipants: SmallintComparisonExp
  meta: JsonbComparisonExp
  name: StringComparisonExp
  onlineMeetingLink: StringComparisonExp
  onlineMeetingPlace: StringComparisonExp
  pointsPresence: FloatComparisonExp
  price: FloatComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  slug: StringComparisonExp
  start: TimestamptzComparisonExp
  state: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "event"
enum EventConstraint {
  # unique or primary key constraint on columns "approval_submission_id"
  event_approval_submission_id_unique

  # unique or primary key constraint on columns "content_id"
  event_content_id_unique

  # unique or primary key constraint on columns "id"
  event_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input EventDeleteAtPathInput {
  meta: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input EventDeleteElemInput {
  meta: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input EventDeleteKeyInput {
  meta: String
}

# input type for incrementing numeric columns in table "event"
input EventIncInput {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  pointsPresence: Float
  price: Float
  projectId: bigint
  tenantId: bigint
}

# input type for inserting data into table "event"
input EventInsertInput {
  address: AddressObjRelInsertInput
  addressId: bigint
  approvalSubmissionId: bigint
  banner: FileUploadObjRelInsertInput
  bannerId: bigint
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovals: EventApprovalArrRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  eventManages: EventManageArrRelInsertInput
  eventSupervisors: EventSupervisorsArrRelInsertInput
  eventTags: EventTagsArrRelInsertInput
  finances: FinanceArrRelInsertInput
  form: FormObjRelInsertInput
  formSubmission: FormSubmissionObjRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float
  price: Float
  project: ProjectObjRelInsertInput
  projectId: bigint
  slug: String
  start: timestamptz
  state: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# columns and relationships of "event_join"
type EventJoin {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event!
  eventId: bigint!

  # An object relationship
  eventManage: EventManage

  # An object relationship
  formSubmission: FormSubmission
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint!
  joinedForId: bigint

  # An object relationship
  joiner: User!
  joinerId: bigint!

  # An object relationship
  linkedMissionJoin: MissionJoin

  # An object relationship
  missionJoin: MissionJoin
  missionJoinId: bigint
  presence: Boolean
  presenceSettledAt: timestamptz

  # An object relationship
  presenceSettledBy: Individual
  presenceSettledById: bigint
  presenceSettledVia: String

  # An object relationship
  qrCode: FileUpload
  qrCodeId: bigint
  settledAt: timestamptz

  # An object relationship
  settledBy: Individual
  settledById: bigint
  state: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "event_join"
type EventJoinAggregate {
  aggregate: EventJoinAggregateFields
  nodes: [EventJoin!]!
}

input EventJoinAggregateBoolExp {
  bool_and: eventJoinAggregateBoolExpBool_and
  bool_or: eventJoinAggregateBoolExpBool_or
  count: eventJoinAggregateBoolExpCount
}

input eventJoinAggregateBoolExpBool_and {
  arguments: EventJoinSelectColumnEventJoinAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: BooleanComparisonExp!
}

input eventJoinAggregateBoolExpBool_or {
  arguments: EventJoinSelectColumnEventJoinAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: BooleanComparisonExp!
}

input eventJoinAggregateBoolExpCount {
  arguments: [EventJoinSelectColumn!]
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_join"
type EventJoinAggregateFields {
  avg: EventJoinAvgFields
  count(columns: [EventJoinSelectColumn!], distinct: Boolean): Int!
  max: EventJoinMaxFields
  min: EventJoinMinFields
  stddev: EventJoinStddevFields
  stddevPop: EventJoinStddevPopFields
  stddevSamp: EventJoinStddevSampFields
  sum: EventJoinSumFields
  varPop: EventJoinVarPopFields
  varSamp: EventJoinVarSampFields
  variance: EventJoinVarianceFields
}

# order by aggregate values of table "event_join"
input EventJoinAggregateOrderBy {
  avg: EventJoinAvgOrderBy
  count: OrderBy
  max: EventJoinMaxOrderBy
  min: EventJoinMinOrderBy
  stddev: EventJoinStddevOrderBy
  stddevPop: EventJoinStddevPopOrderBy
  stddevSamp: EventJoinStddevSampOrderBy
  sum: EventJoinSumOrderBy
  varPop: EventJoinVarPopOrderBy
  varSamp: EventJoinVarSampOrderBy
  variance: EventJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "event_join"
input EventJoinArrRelInsertInput {
  data: [EventJoinInsertInput!]!

  # upsert condition
  onConflict: EventJoinOnConflict
}

# aggregate avg on columns
type EventJoinAvgFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by avg() on columns of table "event_join"
input EventJoinAvgOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "event_join". All fields are combined with a logical 'AND'.
input EventJoinBoolExp {
  _and: [EventJoinBoolExp!]
  _not: EventJoinBoolExp
  _or: [EventJoinBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  eventManage: EventManageBoolExp
  formSubmission: FormSubmissionBoolExp
  formSubmissionId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  joinedForId: BigintComparisonExp
  joiner: UserBoolExp
  joinerId: BigintComparisonExp
  linkedMissionJoin: MissionJoinBoolExp
  missionJoin: MissionJoinBoolExp
  missionJoinId: BigintComparisonExp
  presence: BooleanComparisonExp
  presenceSettledAt: TimestamptzComparisonExp
  presenceSettledBy: IndividualBoolExp
  presenceSettledById: BigintComparisonExp
  presenceSettledVia: StringComparisonExp
  qrCode: FileUploadBoolExp
  qrCodeId: BigintComparisonExp
  settledAt: TimestamptzComparisonExp
  settledBy: IndividualBoolExp
  settledById: BigintComparisonExp
  state: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "event_join"
enum EventJoinConstraint {
  # unique or primary key constraint on columns "id"
  event_join_pkey
}

# input type for incrementing numeric columns in table "event_join"
input EventJoinIncInput {
  createdById: bigint
  eventId: bigint
  formSubmissionId: bigint
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presenceSettledById: bigint
  qrCodeId: bigint
  settledById: bigint
  tenantId: bigint
}

# input type for inserting data into table "event_join"
input EventJoinInsertInput {
  actions: ActionArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventId: bigint
  eventManage: EventManageObjRelInsertInput
  formSubmission: FormSubmissionObjRelInsertInput
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedForId: bigint
  joiner: UserObjRelInsertInput
  joinerId: bigint
  linkedMissionJoin: MissionJoinObjRelInsertInput
  missionJoin: MissionJoinObjRelInsertInput
  missionJoinId: bigint
  presence: Boolean
  presenceSettledAt: timestamptz
  presenceSettledBy: IndividualObjRelInsertInput
  presenceSettledById: bigint
  presenceSettledVia: String
  qrCode: FileUploadObjRelInsertInput
  qrCodeId: bigint
  settledAt: timestamptz
  settledBy: IndividualObjRelInsertInput
  settledById: bigint
  state: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type EventJoinMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presenceSettledAt: timestamptz
  presenceSettledById: bigint
  presenceSettledVia: String
  qrCodeId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by max() on columns of table "event_join"
input EventJoinMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledAt: OrderBy
  presenceSettledById: OrderBy
  presenceSettledVia: OrderBy
  qrCodeId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type EventJoinMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presenceSettledAt: timestamptz
  presenceSettledById: bigint
  presenceSettledVia: String
  qrCodeId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by min() on columns of table "event_join"
input EventJoinMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledAt: OrderBy
  presenceSettledById: OrderBy
  presenceSettledVia: OrderBy
  qrCodeId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "event_join"
type EventJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventJoin!]!
}

# input type for inserting object relation for remote table "event_join"
input EventJoinObjRelInsertInput {
  data: EventJoinInsertInput!

  # upsert condition
  onConflict: EventJoinOnConflict
}

# on_conflict condition type for table "event_join"
input EventJoinOnConflict {
  constraint: EventJoinConstraint!
  updateColumns: [EventJoinUpdateColumn!]! = []
  where: EventJoinBoolExp
}

# Ordering options when selecting data from "event_join".
input EventJoinOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  eventManage: EventManageOrderBy
  formSubmission: FormSubmissionOrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joiner: UserOrderBy
  joinerId: OrderBy
  linkedMissionJoin: MissionJoinOrderBy
  missionJoin: MissionJoinOrderBy
  missionJoinId: OrderBy
  presence: OrderBy
  presenceSettledAt: OrderBy
  presenceSettledBy: IndividualOrderBy
  presenceSettledById: OrderBy
  presenceSettledVia: OrderBy
  qrCode: FileUploadOrderBy
  qrCodeId: OrderBy
  settledAt: OrderBy
  settledBy: IndividualOrderBy
  settledById: OrderBy
  state: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: event_join
input EventJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "event_join"
enum EventJoinSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedForId

  # column name
  joinerId

  # column name
  missionJoinId

  # column name
  presence

  # column name
  presenceSettledAt

  # column name
  presenceSettledById

  # column name
  presenceSettledVia

  # column name
  qrCodeId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

# select "eventJoinAggregateBoolExpBool_andArgumentsColumns" columns of table "event_join"
enum EventJoinSelectColumnEventJoinAggregateBoolExpBool_andArgumentsColumns {
  # column name
  presence
}

# select "eventJoinAggregateBoolExpBool_orArgumentsColumns" columns of table "event_join"
enum EventJoinSelectColumnEventJoinAggregateBoolExpBool_orArgumentsColumns {
  # column name
  presence
}

# input type for updating data in table "event_join"
input EventJoinSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presence: Boolean
  presenceSettledAt: timestamptz
  presenceSettledById: bigint
  presenceSettledVia: String
  qrCodeId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate stddev on columns
type EventJoinStddevFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by stddev() on columns of table "event_join"
input EventJoinStddevOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type EventJoinStddevPopFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "event_join"
input EventJoinStddevPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type EventJoinStddevSampFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "event_join"
input EventJoinStddevSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "event_join"
input EventJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventJoinStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presence: Boolean
  presenceSettledAt: timestamptz
  presenceSettledById: bigint
  presenceSettledVia: String
  qrCodeId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate sum on columns
type EventJoinSumFields {
  createdById: bigint
  eventId: bigint
  formSubmissionId: bigint
  id: bigint
  joinedForId: bigint
  joinerId: bigint
  missionJoinId: bigint
  presenceSettledById: bigint
  qrCodeId: bigint
  settledById: bigint
  tenantId: bigint
}

# order by sum() on columns of table "event_join"
input EventJoinSumOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# update columns of table "event_join"
enum EventJoinUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedForId

  # column name
  joinerId

  # column name
  missionJoinId

  # column name
  presence

  # column name
  presenceSettledAt

  # column name
  presenceSettledById

  # column name
  presenceSettledVia

  # column name
  qrCodeId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

input EventJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventJoinSetInput

  # filter the rows which have to be updated
  where: EventJoinBoolExp!
}

# aggregate variance on columns
type EventJoinVarianceFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by variance() on columns of table "event_join"
input EventJoinVarianceOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type EventJoinVarPopFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by varPop() on columns of table "event_join"
input EventJoinVarPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type EventJoinVarSampFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedForId: Float
  joinerId: Float
  missionJoinId: Float
  presenceSettledById: Float
  qrCodeId: Float
  settledById: Float
  tenantId: Float
}

# order by varSamp() on columns of table "event_join"
input EventJoinVarSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedForId: OrderBy
  joinerId: OrderBy
  missionJoinId: OrderBy
  presenceSettledById: OrderBy
  qrCodeId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "event_manage"
type EventManage {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  event: Event!
  eventId: bigint!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "event_manage"
type EventManageAggregate {
  aggregate: EventManageAggregateFields
  nodes: [EventManage!]!
}

input EventManageAggregateBoolExp {
  count: eventManageAggregateBoolExpCount
}

input eventManageAggregateBoolExpCount {
  arguments: [EventManageSelectColumn!]
  distinct: Boolean
  filter: EventManageBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_manage"
type EventManageAggregateFields {
  avg: EventManageAvgFields
  count(columns: [EventManageSelectColumn!], distinct: Boolean): Int!
  max: EventManageMaxFields
  min: EventManageMinFields
  stddev: EventManageStddevFields
  stddevPop: EventManageStddevPopFields
  stddevSamp: EventManageStddevSampFields
  sum: EventManageSumFields
  varPop: EventManageVarPopFields
  varSamp: EventManageVarSampFields
  variance: EventManageVarianceFields
}

# order by aggregate values of table "event_manage"
input EventManageAggregateOrderBy {
  avg: EventManageAvgOrderBy
  count: OrderBy
  max: EventManageMaxOrderBy
  min: EventManageMinOrderBy
  stddev: EventManageStddevOrderBy
  stddevPop: EventManageStddevPopOrderBy
  stddevSamp: EventManageStddevSampOrderBy
  sum: EventManageSumOrderBy
  varPop: EventManageVarPopOrderBy
  varSamp: EventManageVarSampOrderBy
  variance: EventManageVarianceOrderBy
}

# input type for inserting array relation for remote table "event_manage"
input EventManageArrRelInsertInput {
  data: [EventManageInsertInput!]!

  # upsert condition
  onConflict: EventManageOnConflict
}

# aggregate avg on columns
type EventManageAvgFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "event_manage"
input EventManageAvgOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "event_manage". All fields are combined with a logical 'AND'.
input EventManageBoolExp {
  _and: [EventManageBoolExp!]
  _not: EventManageBoolExp
  _or: [EventManageBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "event_manage"
enum EventManageConstraint {
  # unique or primary key constraint on columns "id"
  event_manage_pkey
}

# input type for incrementing numeric columns in table "event_manage"
input EventManageIncInput {
  createdById: bigint
  eventId: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "event_manage"
input EventManageInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  event: EventObjRelInsertInput
  eventId: bigint
  eventJoins: EventJoinArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  missions: MissionArrRelInsertInput
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type EventManageMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "event_manage"
input EventManageMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type EventManageMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "event_manage"
input EventManageMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "event_manage"
type EventManageMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventManage!]!
}

# input type for inserting object relation for remote table "event_manage"
input EventManageObjRelInsertInput {
  data: EventManageInsertInput!

  # upsert condition
  onConflict: EventManageOnConflict
}

# on_conflict condition type for table "event_manage"
input EventManageOnConflict {
  constraint: EventManageConstraint!
  updateColumns: [EventManageUpdateColumn!]! = []
  where: EventManageBoolExp
}

# Ordering options when selecting data from "event_manage".
input EventManageOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  missionsAggregate: MissionAggregateOrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: event_manage
input EventManagePkColumnsInput {
  id: bigint!
}

# select columns of table "event_manage"
enum EventManageSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "event_manage"
input EventManageSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type EventManageStddevFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "event_manage"
input EventManageStddevOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type EventManageStddevPopFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "event_manage"
input EventManageStddevPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type EventManageStddevSampFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "event_manage"
input EventManageStddevSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "event_manage"
input EventManageStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventManageStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventManageStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type EventManageSumFields {
  createdById: bigint
  eventId: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "event_manage"
input EventManageSumOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "event_manage"
enum EventManageUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

input EventManageUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventManageIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventManageSetInput

  # filter the rows which have to be updated
  where: EventManageBoolExp!
}

# aggregate variance on columns
type EventManageVarianceFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "event_manage"
input EventManageVarianceOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type EventManageVarPopFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "event_manage"
input EventManageVarPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type EventManageVarSampFields {
  createdById: Float
  eventId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "event_manage"
input EventManageVarSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate max on columns
type EventMaxFields {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  name: String
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float
  price: Float
  projectId: bigint
  slug: String
  start: timestamptz
  state: String
  tenantId: bigint
}

# order by max() on columns of table "event"
input EventMaxOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  end: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  name: OrderBy
  onlineMeetingLink: OrderBy
  onlineMeetingPlace: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type EventMinFields {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  name: String
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float
  price: Float
  projectId: bigint
  slug: String
  start: timestamptz
  state: String
  tenantId: bigint
}

# order by min() on columns of table "event"
input EventMinOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  end: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  name: OrderBy
  onlineMeetingLink: OrderBy
  onlineMeetingPlace: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "event"
type EventMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Event!]!
}

# input type for inserting object relation for remote table "event"
input EventObjRelInsertInput {
  data: EventInsertInput!

  # upsert condition
  onConflict: EventOnConflict
}

# on_conflict condition type for table "event"
input EventOnConflict {
  constraint: EventConstraint!
  updateColumns: [EventUpdateColumn!]! = []
  where: EventBoolExp
}

# Ordering options when selecting data from "event".
input EventOrderBy {
  address: AddressOrderBy
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  banner: FileUploadOrderBy
  bannerId: OrderBy
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  end: OrderBy
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventManagesAggregate: EventManageAggregateOrderBy
  eventSupervisorsAggregate: EventSupervisorsAggregateOrderBy
  eventTagsAggregate: EventTagsAggregateOrderBy
  financesAggregate: FinanceAggregateOrderBy
  form: FormOrderBy
  formSubmission: FormSubmissionOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAutoAcceptingJoins: OrderBy
  isPrivate: OrderBy
  isTemplate: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  meta: OrderBy
  name: OrderBy
  onlineMeetingLink: OrderBy
  onlineMeetingPlace: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: event
input EventPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input EventPrependInput {
  meta: jsonb
}

# select columns of table "event"
enum EventSelectColumn {
  # column name
  addressId

  # column name
  approvalSubmissionId

  # column name
  bannerId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  end

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  joinFormId

  # column name
  lastEventApprovalStepId

  # column name
  maxParticipants

  # column name
  meta

  # column name
  name

  # column name
  onlineMeetingLink

  # column name
  onlineMeetingPlace

  # column name
  pointsPresence

  # column name
  price

  # column name
  projectId

  # column name
  slug

  # column name
  start

  # column name
  state

  # column name
  tenantId
}

# select "eventAggregateBoolExpBool_andArgumentsColumns" columns of table "event"
enum EventSelectColumnEventAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate
}

# select "eventAggregateBoolExpBool_orArgumentsColumns" columns of table "event"
enum EventSelectColumnEventAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate
}

# input type for updating data in table "event"
input EventSetInput {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float
  price: Float
  projectId: bigint
  slug: String
  start: timestamptz
  state: String
  tenantId: bigint
}

# aggregate stddev on columns
type EventStddevFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by stddev() on columns of table "event"
input EventStddevOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type EventStddevPopFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "event"
input EventStddevPopOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type EventStddevSampFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "event"
input EventStddevSampOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "event"
input EventStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventStreamCursorValueInput {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  end: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  onlineMeetingLink: String
  onlineMeetingPlace: String
  pointsPresence: Float
  price: Float
  projectId: bigint
  slug: String
  start: timestamptz
  state: String
  tenantId: bigint
}

# aggregate sum on columns
type EventSumFields {
  addressId: bigint
  approvalSubmissionId: bigint
  bannerId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  joinFormId: bigint
  lastEventApprovalStepId: bigint
  maxParticipants: smallint
  pointsPresence: Float
  price: Float
  projectId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "event"
input EventSumOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "event_supervisors"
type EventSupervisors {
  # An object relationship
  event: Event!
  eventId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "event_supervisors"
type EventSupervisorsAggregate {
  aggregate: EventSupervisorsAggregateFields
  nodes: [EventSupervisors!]!
}

input EventSupervisorsAggregateBoolExp {
  count: eventSupervisorsAggregateBoolExpCount
}

input eventSupervisorsAggregateBoolExpCount {
  arguments: [EventSupervisorsSelectColumn!]
  distinct: Boolean
  filter: EventSupervisorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_supervisors"
type EventSupervisorsAggregateFields {
  avg: EventSupervisorsAvgFields
  count(columns: [EventSupervisorsSelectColumn!], distinct: Boolean): Int!
  max: EventSupervisorsMaxFields
  min: EventSupervisorsMinFields
  stddev: EventSupervisorsStddevFields
  stddevPop: EventSupervisorsStddevPopFields
  stddevSamp: EventSupervisorsStddevSampFields
  sum: EventSupervisorsSumFields
  varPop: EventSupervisorsVarPopFields
  varSamp: EventSupervisorsVarSampFields
  variance: EventSupervisorsVarianceFields
}

# order by aggregate values of table "event_supervisors"
input EventSupervisorsAggregateOrderBy {
  avg: EventSupervisorsAvgOrderBy
  count: OrderBy
  max: EventSupervisorsMaxOrderBy
  min: EventSupervisorsMinOrderBy
  stddev: EventSupervisorsStddevOrderBy
  stddevPop: EventSupervisorsStddevPopOrderBy
  stddevSamp: EventSupervisorsStddevSampOrderBy
  sum: EventSupervisorsSumOrderBy
  varPop: EventSupervisorsVarPopOrderBy
  varSamp: EventSupervisorsVarSampOrderBy
  variance: EventSupervisorsVarianceOrderBy
}

# input type for inserting array relation for remote table "event_supervisors"
input EventSupervisorsArrRelInsertInput {
  data: [EventSupervisorsInsertInput!]!

  # upsert condition
  onConflict: EventSupervisorsOnConflict
}

# aggregate avg on columns
type EventSupervisorsAvgFields {
  eventId: Float
  userId: Float
}

# order by avg() on columns of table "event_supervisors"
input EventSupervisorsAvgOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "event_supervisors". All fields are combined with a logical 'AND'.
input EventSupervisorsBoolExp {
  _and: [EventSupervisorsBoolExp!]
  _not: EventSupervisorsBoolExp
  _or: [EventSupervisorsBoolExp!]
  event: EventBoolExp
  eventId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "event_supervisors"
enum EventSupervisorsConstraint {
  # unique or primary key constraint on columns "event_id", "user_id"
  event_supervisors_pkey
}

# input type for incrementing numeric columns in table "event_supervisors"
input EventSupervisorsIncInput {
  eventId: bigint
  userId: bigint
}

# input type for inserting data into table "event_supervisors"
input EventSupervisorsInsertInput {
  event: EventObjRelInsertInput
  eventId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type EventSupervisorsMaxFields {
  eventId: bigint
  userId: bigint
}

# order by max() on columns of table "event_supervisors"
input EventSupervisorsMaxOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type EventSupervisorsMinFields {
  eventId: bigint
  userId: bigint
}

# order by min() on columns of table "event_supervisors"
input EventSupervisorsMinOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "event_supervisors"
type EventSupervisorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventSupervisors!]!
}

# on_conflict condition type for table "event_supervisors"
input EventSupervisorsOnConflict {
  constraint: EventSupervisorsConstraint!
  updateColumns: [EventSupervisorsUpdateColumn!]! = []
  where: EventSupervisorsBoolExp
}

# Ordering options when selecting data from "event_supervisors".
input EventSupervisorsOrderBy {
  event: EventOrderBy
  eventId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: event_supervisors
input EventSupervisorsPkColumnsInput {
  eventId: bigint!
  userId: bigint!
}

# select columns of table "event_supervisors"
enum EventSupervisorsSelectColumn {
  # column name
  eventId

  # column name
  userId
}

# input type for updating data in table "event_supervisors"
input EventSupervisorsSetInput {
  eventId: bigint
  userId: bigint
}

# aggregate stddev on columns
type EventSupervisorsStddevFields {
  eventId: Float
  userId: Float
}

# order by stddev() on columns of table "event_supervisors"
input EventSupervisorsStddevOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type EventSupervisorsStddevPopFields {
  eventId: Float
  userId: Float
}

# order by stddevPop() on columns of table "event_supervisors"
input EventSupervisorsStddevPopOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type EventSupervisorsStddevSampFields {
  eventId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "event_supervisors"
input EventSupervisorsStddevSampOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "event_supervisors"
input EventSupervisorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventSupervisorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventSupervisorsStreamCursorValueInput {
  eventId: bigint
  userId: bigint
}

# aggregate sum on columns
type EventSupervisorsSumFields {
  eventId: bigint
  userId: bigint
}

# order by sum() on columns of table "event_supervisors"
input EventSupervisorsSumOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# update columns of table "event_supervisors"
enum EventSupervisorsUpdateColumn {
  # column name
  eventId

  # column name
  userId
}

input EventSupervisorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventSupervisorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventSupervisorsSetInput

  # filter the rows which have to be updated
  where: EventSupervisorsBoolExp!
}

# aggregate variance on columns
type EventSupervisorsVarianceFields {
  eventId: Float
  userId: Float
}

# order by variance() on columns of table "event_supervisors"
input EventSupervisorsVarianceOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type EventSupervisorsVarPopFields {
  eventId: Float
  userId: Float
}

# order by varPop() on columns of table "event_supervisors"
input EventSupervisorsVarPopOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type EventSupervisorsVarSampFields {
  eventId: Float
  userId: Float
}

# order by varSamp() on columns of table "event_supervisors"
input EventSupervisorsVarSampOrderBy {
  eventId: OrderBy
  userId: OrderBy
}

# columns and relationships of "event_tags"
type EventTags {
  # An object relationship
  event: Event!
  eventId: bigint!

  # An object relationship
  tag: Tag!
  tagId: bigint!
}

# aggregated selection of "event_tags"
type EventTagsAggregate {
  aggregate: EventTagsAggregateFields
  nodes: [EventTags!]!
}

input EventTagsAggregateBoolExp {
  count: eventTagsAggregateBoolExpCount
}

input eventTagsAggregateBoolExpCount {
  arguments: [EventTagsSelectColumn!]
  distinct: Boolean
  filter: EventTagsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_tags"
type EventTagsAggregateFields {
  avg: EventTagsAvgFields
  count(columns: [EventTagsSelectColumn!], distinct: Boolean): Int!
  max: EventTagsMaxFields
  min: EventTagsMinFields
  stddev: EventTagsStddevFields
  stddevPop: EventTagsStddevPopFields
  stddevSamp: EventTagsStddevSampFields
  sum: EventTagsSumFields
  varPop: EventTagsVarPopFields
  varSamp: EventTagsVarSampFields
  variance: EventTagsVarianceFields
}

# order by aggregate values of table "event_tags"
input EventTagsAggregateOrderBy {
  avg: EventTagsAvgOrderBy
  count: OrderBy
  max: EventTagsMaxOrderBy
  min: EventTagsMinOrderBy
  stddev: EventTagsStddevOrderBy
  stddevPop: EventTagsStddevPopOrderBy
  stddevSamp: EventTagsStddevSampOrderBy
  sum: EventTagsSumOrderBy
  varPop: EventTagsVarPopOrderBy
  varSamp: EventTagsVarSampOrderBy
  variance: EventTagsVarianceOrderBy
}

# input type for inserting array relation for remote table "event_tags"
input EventTagsArrRelInsertInput {
  data: [EventTagsInsertInput!]!

  # upsert condition
  onConflict: EventTagsOnConflict
}

# aggregate avg on columns
type EventTagsAvgFields {
  eventId: Float
  tagId: Float
}

# order by avg() on columns of table "event_tags"
input EventTagsAvgOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# Boolean expression to filter rows from the table "event_tags". All fields are combined with a logical 'AND'.
input EventTagsBoolExp {
  _and: [EventTagsBoolExp!]
  _not: EventTagsBoolExp
  _or: [EventTagsBoolExp!]
  event: EventBoolExp
  eventId: BigintComparisonExp
  tag: TagBoolExp
  tagId: BigintComparisonExp
}

# unique or primary key constraints on table "event_tags"
enum EventTagsConstraint {
  # unique or primary key constraint on columns "event_id", "tag_id"
  event_tags_pkey
}

# input type for incrementing numeric columns in table "event_tags"
input EventTagsIncInput {
  eventId: bigint
  tagId: bigint
}

# input type for inserting data into table "event_tags"
input EventTagsInsertInput {
  event: EventObjRelInsertInput
  eventId: bigint
  tag: TagObjRelInsertInput
  tagId: bigint
}

# aggregate max on columns
type EventTagsMaxFields {
  eventId: bigint
  tagId: bigint
}

# order by max() on columns of table "event_tags"
input EventTagsMaxOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# aggregate min on columns
type EventTagsMinFields {
  eventId: bigint
  tagId: bigint
}

# order by min() on columns of table "event_tags"
input EventTagsMinOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# response of any mutation on the table "event_tags"
type EventTagsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventTags!]!
}

# on_conflict condition type for table "event_tags"
input EventTagsOnConflict {
  constraint: EventTagsConstraint!
  updateColumns: [EventTagsUpdateColumn!]! = []
  where: EventTagsBoolExp
}

# Ordering options when selecting data from "event_tags".
input EventTagsOrderBy {
  event: EventOrderBy
  eventId: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
}

# primary key columns input for table: event_tags
input EventTagsPkColumnsInput {
  eventId: bigint!
  tagId: bigint!
}

# select columns of table "event_tags"
enum EventTagsSelectColumn {
  # column name
  eventId

  # column name
  tagId
}

# input type for updating data in table "event_tags"
input EventTagsSetInput {
  eventId: bigint
  tagId: bigint
}

# aggregate stddev on columns
type EventTagsStddevFields {
  eventId: Float
  tagId: Float
}

# order by stddev() on columns of table "event_tags"
input EventTagsStddevOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# aggregate stddevPop on columns
type EventTagsStddevPopFields {
  eventId: Float
  tagId: Float
}

# order by stddevPop() on columns of table "event_tags"
input EventTagsStddevPopOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# aggregate stddevSamp on columns
type EventTagsStddevSampFields {
  eventId: Float
  tagId: Float
}

# order by stddevSamp() on columns of table "event_tags"
input EventTagsStddevSampOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# Streaming cursor of the table "event_tags"
input EventTagsStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventTagsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventTagsStreamCursorValueInput {
  eventId: bigint
  tagId: bigint
}

# aggregate sum on columns
type EventTagsSumFields {
  eventId: bigint
  tagId: bigint
}

# order by sum() on columns of table "event_tags"
input EventTagsSumOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# update columns of table "event_tags"
enum EventTagsUpdateColumn {
  # column name
  eventId

  # column name
  tagId
}

input EventTagsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventTagsIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventTagsSetInput

  # filter the rows which have to be updated
  where: EventTagsBoolExp!
}

# aggregate variance on columns
type EventTagsVarianceFields {
  eventId: Float
  tagId: Float
}

# order by variance() on columns of table "event_tags"
input EventTagsVarianceOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# aggregate varPop on columns
type EventTagsVarPopFields {
  eventId: Float
  tagId: Float
}

# order by varPop() on columns of table "event_tags"
input EventTagsVarPopOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# aggregate varSamp on columns
type EventTagsVarSampFields {
  eventId: Float
  tagId: Float
}

# order by varSamp() on columns of table "event_tags"
input EventTagsVarSampOrderBy {
  eventId: OrderBy
  tagId: OrderBy
}

# update columns of table "event"
enum EventUpdateColumn {
  # column name
  addressId

  # column name
  approvalSubmissionId

  # column name
  bannerId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  end

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  joinFormId

  # column name
  lastEventApprovalStepId

  # column name
  maxParticipants

  # column name
  meta

  # column name
  name

  # column name
  onlineMeetingLink

  # column name
  onlineMeetingPlace

  # column name
  pointsPresence

  # column name
  price

  # column name
  projectId

  # column name
  slug

  # column name
  start

  # column name
  state

  # column name
  tenantId
}

input EventUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: EventAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: EventDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: EventDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: EventDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: EventIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: EventPrependInput

  # sets the columns of the filtered rows to the given values
  _set: EventSetInput

  # filter the rows which have to be updated
  where: EventBoolExp!
}

# aggregate variance on columns
type EventVarianceFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by variance() on columns of table "event"
input EventVarianceOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type EventVarPopFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by varPop() on columns of table "event"
input EventVarPopOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type EventVarSampFields {
  addressId: Float
  approvalSubmissionId: Float
  bannerId: Float
  contentId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  lastEventApprovalStepId: Float
  maxParticipants: Float
  pointsPresence: Float
  price: Float
  projectId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "event"
input EventVarSampOrderBy {
  addressId: OrderBy
  approvalSubmissionId: OrderBy
  bannerId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  lastEventApprovalStepId: OrderBy
  maxParticipants: OrderBy
  pointsPresence: OrderBy
  price: OrderBy
  projectId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "expense"
type Expense {
  # An object relationship
  bankInfo: BankInfo!
  bankInfoId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!
  expenseReportId: bigint!

  # An object relationship
  fileUpload: FileUpload!

  # An object relationship
  finance: Finance
  hiddenAt: timestamptz
  id: bigint!
  lastNotifiedAt: timestamptz
  settledAt: timestamptz

  # An object relationship
  settledBy: Individual
  settledById: bigint
  state: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "expense"
type ExpenseAggregate {
  aggregate: ExpenseAggregateFields
  nodes: [Expense!]!
}

input ExpenseAggregateBoolExp {
  count: expenseAggregateBoolExpCount
}

input expenseAggregateBoolExpCount {
  arguments: [ExpenseSelectColumn!]
  distinct: Boolean
  filter: ExpenseBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense"
type ExpenseAggregateFields {
  avg: ExpenseAvgFields
  count(columns: [ExpenseSelectColumn!], distinct: Boolean): Int!
  max: ExpenseMaxFields
  min: ExpenseMinFields
  stddev: ExpenseStddevFields
  stddevPop: ExpenseStddevPopFields
  stddevSamp: ExpenseStddevSampFields
  sum: ExpenseSumFields
  varPop: ExpenseVarPopFields
  varSamp: ExpenseVarSampFields
  variance: ExpenseVarianceFields
}

# order by aggregate values of table "expense"
input ExpenseAggregateOrderBy {
  avg: ExpenseAvgOrderBy
  count: OrderBy
  max: ExpenseMaxOrderBy
  min: ExpenseMinOrderBy
  stddev: ExpenseStddevOrderBy
  stddevPop: ExpenseStddevPopOrderBy
  stddevSamp: ExpenseStddevSampOrderBy
  sum: ExpenseSumOrderBy
  varPop: ExpenseVarPopOrderBy
  varSamp: ExpenseVarSampOrderBy
  variance: ExpenseVarianceOrderBy
}

# input type for inserting array relation for remote table "expense"
input ExpenseArrRelInsertInput {
  data: [ExpenseInsertInput!]!

  # upsert condition
  onConflict: ExpenseOnConflict
}

# aggregate avg on columns
type ExpenseAvgFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by avg() on columns of table "expense"
input ExpenseAvgOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "expense". All fields are combined with a logical 'AND'.
input ExpenseBoolExp {
  _and: [ExpenseBoolExp!]
  _not: ExpenseBoolExp
  _or: [ExpenseBoolExp!]
  bankInfo: BankInfoBoolExp
  bankInfoId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  expenseReportId: BigintComparisonExp
  fileUpload: FileUploadBoolExp
  finance: FinanceBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastNotifiedAt: TimestamptzComparisonExp
  settledAt: TimestamptzComparisonExp
  settledBy: IndividualBoolExp
  settledById: BigintComparisonExp
  state: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "expense"
enum ExpenseConstraint {
  # unique or primary key constraint on columns "id"
  expense_pkey
}

# input type for incrementing numeric columns in table "expense"
input ExpenseIncInput {
  bankInfoId: bigint
  createdById: bigint
  expenseReportId: bigint
  id: bigint
  settledById: bigint
  tenantId: bigint
}

# input type for inserting data into table "expense"
input ExpenseInsertInput {
  bankInfo: BankInfoObjRelInsertInput
  bankInfoId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseItems: ExpenseItemArrRelInsertInput
  expenseReportId: bigint
  fileUpload: FileUploadObjRelInsertInput
  finance: FinanceObjRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  settledAt: timestamptz
  settledBy: IndividualObjRelInsertInput
  settledById: bigint
  state: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# columns and relationships of "expense_item"
type ExpenseItem {
  # An object relationship
  address: Address
  addressId: bigint
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  expense: Expense
  expenseId: bigint

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  payedAt: timestamptz
  quantity: smallint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  unitCost: Float!
}

# aggregated selection of "expense_item"
type ExpenseItemAggregate {
  aggregate: ExpenseItemAggregateFields
  nodes: [ExpenseItem!]!
}

input ExpenseItemAggregateBoolExp {
  count: expenseItemAggregateBoolExpCount
}

input expenseItemAggregateBoolExpCount {
  arguments: [ExpenseItemSelectColumn!]
  distinct: Boolean
  filter: ExpenseItemBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense_item"
type ExpenseItemAggregateFields {
  avg: ExpenseItemAvgFields
  count(columns: [ExpenseItemSelectColumn!], distinct: Boolean): Int!
  max: ExpenseItemMaxFields
  min: ExpenseItemMinFields
  stddev: ExpenseItemStddevFields
  stddevPop: ExpenseItemStddevPopFields
  stddevSamp: ExpenseItemStddevSampFields
  sum: ExpenseItemSumFields
  varPop: ExpenseItemVarPopFields
  varSamp: ExpenseItemVarSampFields
  variance: ExpenseItemVarianceFields
}

# order by aggregate values of table "expense_item"
input ExpenseItemAggregateOrderBy {
  avg: ExpenseItemAvgOrderBy
  count: OrderBy
  max: ExpenseItemMaxOrderBy
  min: ExpenseItemMinOrderBy
  stddev: ExpenseItemStddevOrderBy
  stddevPop: ExpenseItemStddevPopOrderBy
  stddevSamp: ExpenseItemStddevSampOrderBy
  sum: ExpenseItemSumOrderBy
  varPop: ExpenseItemVarPopOrderBy
  varSamp: ExpenseItemVarSampOrderBy
  variance: ExpenseItemVarianceOrderBy
}

# input type for inserting array relation for remote table "expense_item"
input ExpenseItemArrRelInsertInput {
  data: [ExpenseItemInsertInput!]!

  # upsert condition
  onConflict: ExpenseItemOnConflict
}

# columns and relationships of "expense_item_attachments"
type ExpenseItemAttachments {
  # An object relationship
  expenseItem: ExpenseItem!
  expenseItemId: bigint!

  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!
}

# aggregated selection of "expense_item_attachments"
type ExpenseItemAttachmentsAggregate {
  aggregate: ExpenseItemAttachmentsAggregateFields
  nodes: [ExpenseItemAttachments!]!
}

input ExpenseItemAttachmentsAggregateBoolExp {
  count: expenseItemAttachmentsAggregateBoolExpCount
}

input expenseItemAttachmentsAggregateBoolExpCount {
  arguments: [ExpenseItemAttachmentsSelectColumn!]
  distinct: Boolean
  filter: ExpenseItemAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense_item_attachments"
type ExpenseItemAttachmentsAggregateFields {
  avg: ExpenseItemAttachmentsAvgFields
  count(columns: [ExpenseItemAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: ExpenseItemAttachmentsMaxFields
  min: ExpenseItemAttachmentsMinFields
  stddev: ExpenseItemAttachmentsStddevFields
  stddevPop: ExpenseItemAttachmentsStddevPopFields
  stddevSamp: ExpenseItemAttachmentsStddevSampFields
  sum: ExpenseItemAttachmentsSumFields
  varPop: ExpenseItemAttachmentsVarPopFields
  varSamp: ExpenseItemAttachmentsVarSampFields
  variance: ExpenseItemAttachmentsVarianceFields
}

# order by aggregate values of table "expense_item_attachments"
input ExpenseItemAttachmentsAggregateOrderBy {
  avg: ExpenseItemAttachmentsAvgOrderBy
  count: OrderBy
  max: ExpenseItemAttachmentsMaxOrderBy
  min: ExpenseItemAttachmentsMinOrderBy
  stddev: ExpenseItemAttachmentsStddevOrderBy
  stddevPop: ExpenseItemAttachmentsStddevPopOrderBy
  stddevSamp: ExpenseItemAttachmentsStddevSampOrderBy
  sum: ExpenseItemAttachmentsSumOrderBy
  varPop: ExpenseItemAttachmentsVarPopOrderBy
  varSamp: ExpenseItemAttachmentsVarSampOrderBy
  variance: ExpenseItemAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "expense_item_attachments"
input ExpenseItemAttachmentsArrRelInsertInput {
  data: [ExpenseItemAttachmentsInsertInput!]!

  # upsert condition
  onConflict: ExpenseItemAttachmentsOnConflict
}

# aggregate avg on columns
type ExpenseItemAttachmentsAvgFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by avg() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsAvgOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# Boolean expression to filter rows from the table "expense_item_attachments". All fields are combined with a logical 'AND'.
input ExpenseItemAttachmentsBoolExp {
  _and: [ExpenseItemAttachmentsBoolExp!]
  _not: ExpenseItemAttachmentsBoolExp
  _or: [ExpenseItemAttachmentsBoolExp!]
  expenseItem: ExpenseItemBoolExp
  expenseItemId: BigintComparisonExp
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
}

# unique or primary key constraints on table "expense_item_attachments"
enum ExpenseItemAttachmentsConstraint {
  # unique or primary key constraint on columns "file_upload_id", "expense_item_id"
  expense_item_attachments_pkey
}

# input type for incrementing numeric columns in table "expense_item_attachments"
input ExpenseItemAttachmentsIncInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# input type for inserting data into table "expense_item_attachments"
input ExpenseItemAttachmentsInsertInput {
  expenseItem: ExpenseItemObjRelInsertInput
  expenseItemId: bigint
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
}

# aggregate max on columns
type ExpenseItemAttachmentsMaxFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by max() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsMaxOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate min on columns
type ExpenseItemAttachmentsMinFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by min() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsMinOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# response of any mutation on the table "expense_item_attachments"
type ExpenseItemAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ExpenseItemAttachments!]!
}

# on_conflict condition type for table "expense_item_attachments"
input ExpenseItemAttachmentsOnConflict {
  constraint: ExpenseItemAttachmentsConstraint!
  updateColumns: [ExpenseItemAttachmentsUpdateColumn!]! = []
  where: ExpenseItemAttachmentsBoolExp
}

# Ordering options when selecting data from "expense_item_attachments".
input ExpenseItemAttachmentsOrderBy {
  expenseItem: ExpenseItemOrderBy
  expenseItemId: OrderBy
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
}

# primary key columns input for table: expense_item_attachments
input ExpenseItemAttachmentsPkColumnsInput {
  expenseItemId: bigint!
  fileUploadId: bigint!
}

# select columns of table "expense_item_attachments"
enum ExpenseItemAttachmentsSelectColumn {
  # column name
  expenseItemId

  # column name
  fileUploadId
}

# input type for updating data in table "expense_item_attachments"
input ExpenseItemAttachmentsSetInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# aggregate stddev on columns
type ExpenseItemAttachmentsStddevFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddev() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevPop on columns
type ExpenseItemAttachmentsStddevPopFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddevPop() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevPopOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseItemAttachmentsStddevSampFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddevSamp() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevSampOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# Streaming cursor of the table "expense_item_attachments"
input ExpenseItemAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseItemAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseItemAttachmentsStreamCursorValueInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# aggregate sum on columns
type ExpenseItemAttachmentsSumFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by sum() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsSumOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# update columns of table "expense_item_attachments"
enum ExpenseItemAttachmentsUpdateColumn {
  # column name
  expenseItemId

  # column name
  fileUploadId
}

input ExpenseItemAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseItemAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseItemAttachmentsSetInput

  # filter the rows which have to be updated
  where: ExpenseItemAttachmentsBoolExp!
}

# aggregate variance on columns
type ExpenseItemAttachmentsVarianceFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by variance() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarianceOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varPop on columns
type ExpenseItemAttachmentsVarPopFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by varPop() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarPopOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varSamp on columns
type ExpenseItemAttachmentsVarSampFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by varSamp() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarSampOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate avg on columns
type ExpenseItemAvgFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by avg() on columns of table "expense_item"
input ExpenseItemAvgOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# Boolean expression to filter rows from the table "expense_item". All fields are combined with a logical 'AND'.
input ExpenseItemBoolExp {
  _and: [ExpenseItemBoolExp!]
  _not: ExpenseItemBoolExp
  _or: [ExpenseItemBoolExp!]
  address: AddressBoolExp
  addressId: BigintComparisonExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  expense: ExpenseBoolExp
  expenseId: BigintComparisonExp
  expenseItemAttachments: ExpenseItemAttachmentsBoolExp
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  payedAt: TimestamptzComparisonExp
  quantity: SmallintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  unitCost: FloatComparisonExp
}

# unique or primary key constraints on table "expense_item"
enum ExpenseItemConstraint {
  # unique or primary key constraint on columns "id"
  expense_item_pkey
}

# input type for incrementing numeric columns in table "expense_item"
input ExpenseItemIncInput {
  addressId: bigint
  createdById: bigint
  expenseId: bigint
  id: bigint
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# input type for inserting data into table "expense_item"
input ExpenseItemInsertInput {
  address: AddressObjRelInsertInput
  addressId: bigint
  category: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expense: ExpenseObjRelInsertInput
  expenseId: bigint
  expenseItemAttachments: ExpenseItemAttachmentsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  unitCost: Float
}

# aggregate max on columns
type ExpenseItemMaxFields {
  addressId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# order by max() on columns of table "expense_item"
input ExpenseItemMaxOrderBy {
  addressId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate min on columns
type ExpenseItemMinFields {
  addressId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# order by min() on columns of table "expense_item"
input ExpenseItemMinOrderBy {
  addressId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# response of any mutation on the table "expense_item"
type ExpenseItemMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ExpenseItem!]!
}

# input type for inserting object relation for remote table "expense_item"
input ExpenseItemObjRelInsertInput {
  data: ExpenseItemInsertInput!

  # upsert condition
  onConflict: ExpenseItemOnConflict
}

# on_conflict condition type for table "expense_item"
input ExpenseItemOnConflict {
  constraint: ExpenseItemConstraint!
  updateColumns: [ExpenseItemUpdateColumn!]! = []
  where: ExpenseItemBoolExp
}

# Ordering options when selecting data from "expense_item".
input ExpenseItemOrderBy {
  address: AddressOrderBy
  addressId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expense: ExpenseOrderBy
  expenseId: OrderBy
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# primary key columns input for table: expense_item
input ExpenseItemPkColumnsInput {
  id: bigint!
}

# select columns of table "expense_item"
enum ExpenseItemSelectColumn {
  # column name
  addressId

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  payedAt

  # column name
  quantity

  # column name
  tenantId

  # column name
  unitCost
}

# input type for updating data in table "expense_item"
input ExpenseItemSetInput {
  addressId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# aggregate stddev on columns
type ExpenseItemStddevFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by stddev() on columns of table "expense_item"
input ExpenseItemStddevOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate stddevPop on columns
type ExpenseItemStddevPopFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by stddevPop() on columns of table "expense_item"
input ExpenseItemStddevPopOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseItemStddevSampFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by stddevSamp() on columns of table "expense_item"
input ExpenseItemStddevSampOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# Streaming cursor of the table "expense_item"
input ExpenseItemStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseItemStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseItemStreamCursorValueInput {
  addressId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# aggregate sum on columns
type ExpenseItemSumFields {
  addressId: bigint
  createdById: bigint
  expenseId: bigint
  id: bigint
  quantity: smallint
  tenantId: bigint
  unitCost: Float
}

# order by sum() on columns of table "expense_item"
input ExpenseItemSumOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# update columns of table "expense_item"
enum ExpenseItemUpdateColumn {
  # column name
  addressId

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  payedAt

  # column name
  quantity

  # column name
  tenantId

  # column name
  unitCost
}

input ExpenseItemUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseItemIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseItemSetInput

  # filter the rows which have to be updated
  where: ExpenseItemBoolExp!
}

# aggregate variance on columns
type ExpenseItemVarianceFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by variance() on columns of table "expense_item"
input ExpenseItemVarianceOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate varPop on columns
type ExpenseItemVarPopFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by varPop() on columns of table "expense_item"
input ExpenseItemVarPopOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate varSamp on columns
type ExpenseItemVarSampFields {
  addressId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantId: Float
  unitCost: Float
}

# order by varSamp() on columns of table "expense_item"
input ExpenseItemVarSampOrderBy {
  addressId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantId: OrderBy
  unitCost: OrderBy
}

# aggregate max on columns
type ExpenseMaxFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by max() on columns of table "expense"
input ExpenseMaxOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseReportId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type ExpenseMinFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by min() on columns of table "expense"
input ExpenseMinOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseReportId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "expense"
type ExpenseMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Expense!]!
}

# input type for inserting object relation for remote table "expense"
input ExpenseObjRelInsertInput {
  data: ExpenseInsertInput!

  # upsert condition
  onConflict: ExpenseOnConflict
}

# on_conflict condition type for table "expense"
input ExpenseOnConflict {
  constraint: ExpenseConstraint!
  updateColumns: [ExpenseUpdateColumn!]! = []
  where: ExpenseBoolExp
}

# Ordering options when selecting data from "expense".
input ExpenseOrderBy {
  bankInfo: BankInfoOrderBy
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  expenseReportId: OrderBy
  fileUpload: FileUploadOrderBy
  finance: FinanceOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  settledAt: OrderBy
  settledBy: IndividualOrderBy
  settledById: OrderBy
  state: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: expense
input ExpensePkColumnsInput {
  id: bigint!
}

# select columns of table "expense"
enum ExpenseSelectColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseReportId

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastNotifiedAt

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

# input type for updating data in table "expense"
input ExpenseSetInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate stddev on columns
type ExpenseStddevFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by stddev() on columns of table "expense"
input ExpenseStddevOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ExpenseStddevPopFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "expense"
input ExpenseStddevPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseStddevSampFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "expense"
input ExpenseStddevSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "expense"
input ExpenseStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseStreamCursorValueInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate sum on columns
type ExpenseSumFields {
  bankInfoId: bigint
  createdById: bigint
  expenseReportId: bigint
  id: bigint
  settledById: bigint
  tenantId: bigint
}

# order by sum() on columns of table "expense"
input ExpenseSumOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# update columns of table "expense"
enum ExpenseUpdateColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseReportId

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastNotifiedAt

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

input ExpenseUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseSetInput

  # filter the rows which have to be updated
  where: ExpenseBoolExp!
}

# aggregate variance on columns
type ExpenseVarianceFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by variance() on columns of table "expense"
input ExpenseVarianceOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ExpenseVarPopFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by varPop() on columns of table "expense"
input ExpenseVarPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ExpenseVarSampFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  settledById: Float
  tenantId: Float
}

# order by varSamp() on columns of table "expense"
input ExpenseVarSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "favorite"
type Favorite {
  # An object relationship
  actor: Actor
  actorId: bigint

  # An object relationship
  content: Content
  contentId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "favorite"
type FavoriteAggregate {
  aggregate: FavoriteAggregateFields
  nodes: [Favorite!]!
}

input FavoriteAggregateBoolExp {
  count: favoriteAggregateBoolExpCount
}

input favoriteAggregateBoolExpCount {
  arguments: [FavoriteSelectColumn!]
  distinct: Boolean
  filter: FavoriteBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "favorite"
type FavoriteAggregateFields {
  avg: FavoriteAvgFields
  count(columns: [FavoriteSelectColumn!], distinct: Boolean): Int!
  max: FavoriteMaxFields
  min: FavoriteMinFields
  stddev: FavoriteStddevFields
  stddevPop: FavoriteStddevPopFields
  stddevSamp: FavoriteStddevSampFields
  sum: FavoriteSumFields
  varPop: FavoriteVarPopFields
  varSamp: FavoriteVarSampFields
  variance: FavoriteVarianceFields
}

# order by aggregate values of table "favorite"
input FavoriteAggregateOrderBy {
  avg: FavoriteAvgOrderBy
  count: OrderBy
  max: FavoriteMaxOrderBy
  min: FavoriteMinOrderBy
  stddev: FavoriteStddevOrderBy
  stddevPop: FavoriteStddevPopOrderBy
  stddevSamp: FavoriteStddevSampOrderBy
  sum: FavoriteSumOrderBy
  varPop: FavoriteVarPopOrderBy
  varSamp: FavoriteVarSampOrderBy
  variance: FavoriteVarianceOrderBy
}

# input type for inserting array relation for remote table "favorite"
input FavoriteArrRelInsertInput {
  data: [FavoriteInsertInput!]!

  # upsert condition
  onConflict: FavoriteOnConflict
}

# aggregate avg on columns
type FavoriteAvgFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "favorite"
input FavoriteAvgOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "favorite". All fields are combined with a logical 'AND'.
input FavoriteBoolExp {
  _and: [FavoriteBoolExp!]
  _not: FavoriteBoolExp
  _or: [FavoriteBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "favorite"
enum FavoriteConstraint {
  # unique or primary key constraint on columns "id"
  favorite_pkey
}

# input type for incrementing numeric columns in table "favorite"
input FavoriteIncInput {
  actorId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "favorite"
input FavoriteInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type FavoriteMaxFields {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
}

# order by max() on columns of table "favorite"
input FavoriteMaxOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type FavoriteMinFields {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
}

# order by min() on columns of table "favorite"
input FavoriteMinOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "favorite"
type FavoriteMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Favorite!]!
}

# on_conflict condition type for table "favorite"
input FavoriteOnConflict {
  constraint: FavoriteConstraint!
  updateColumns: [FavoriteUpdateColumn!]! = []
  where: FavoriteBoolExp
}

# Ordering options when selecting data from "favorite".
input FavoriteOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: favorite
input FavoritePkColumnsInput {
  id: bigint!
}

# select columns of table "favorite"
enum FavoriteSelectColumn {
  # column name
  actorId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId
}

# input type for updating data in table "favorite"
input FavoriteSetInput {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
}

# aggregate stddev on columns
type FavoriteStddevFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "favorite"
input FavoriteStddevOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FavoriteStddevPopFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "favorite"
input FavoriteStddevPopOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FavoriteStddevSampFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "favorite"
input FavoriteStddevSampOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "favorite"
input FavoriteStreamCursorInput {
  # Stream column input with initial value
  initialValue: FavoriteStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FavoriteStreamCursorValueInput {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
}

# aggregate sum on columns
type FavoriteSumFields {
  actorId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "favorite"
input FavoriteSumOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "favorite"
enum FavoriteUpdateColumn {
  # column name
  actorId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId
}

input FavoriteUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FavoriteIncInput

  # sets the columns of the filtered rows to the given values
  _set: FavoriteSetInput

  # filter the rows which have to be updated
  where: FavoriteBoolExp!
}

# aggregate variance on columns
type FavoriteVarianceFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "favorite"
input FavoriteVarianceOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FavoriteVarPopFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "favorite"
input FavoriteVarPopOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FavoriteVarSampFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "favorite"
input FavoriteVarSampOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "file_upload"
type FileUpload {
  # An object relationship
  actorImage: ActorImage

  # An object relationship
  address: Address

  # An array relationship
  contentAttachments(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): [ContentAttachments!]!

  # An aggregate relationship
  contentAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): ContentAttachmentsAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  document: Document

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!
  fileLastModifiedAt: timestamptz!

  # An array relationship
  financeAttachments(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): [FinanceAttachments!]!

  # An aggregate relationship
  financeAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): FinanceAttachmentsAggregate!

  # An array relationship
  generatedDocumentGrantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  generatedDocumentGrantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # An array relationship
  grantUnlockAttachments(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): [GrantUnlockAttachments!]!

  # An aggregate relationship
  grantUnlockAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): GrantUnlockAttachmentsAggregate!

  # An array relationship
  grantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  grantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  signatureGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  signatureGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  size: Int!

  # An array relationship
  tags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  tagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An array relationship
  teams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  teamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
  url: String!
}

# aggregated selection of "file_upload"
type FileUploadAggregate {
  aggregate: FileUploadAggregateFields
  nodes: [FileUpload!]!
}

input FileUploadAggregateBoolExp {
  count: fileUploadAggregateBoolExpCount
}

input fileUploadAggregateBoolExpCount {
  arguments: [FileUploadSelectColumn!]
  distinct: Boolean
  filter: FileUploadBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "file_upload"
type FileUploadAggregateFields {
  avg: FileUploadAvgFields
  count(columns: [FileUploadSelectColumn!], distinct: Boolean): Int!
  max: FileUploadMaxFields
  min: FileUploadMinFields
  stddev: FileUploadStddevFields
  stddevPop: FileUploadStddevPopFields
  stddevSamp: FileUploadStddevSampFields
  sum: FileUploadSumFields
  varPop: FileUploadVarPopFields
  varSamp: FileUploadVarSampFields
  variance: FileUploadVarianceFields
}

# order by aggregate values of table "file_upload"
input FileUploadAggregateOrderBy {
  avg: FileUploadAvgOrderBy
  count: OrderBy
  max: FileUploadMaxOrderBy
  min: FileUploadMinOrderBy
  stddev: FileUploadStddevOrderBy
  stddevPop: FileUploadStddevPopOrderBy
  stddevSamp: FileUploadStddevSampOrderBy
  sum: FileUploadSumOrderBy
  varPop: FileUploadVarPopOrderBy
  varSamp: FileUploadVarSampOrderBy
  variance: FileUploadVarianceOrderBy
}

# input type for inserting array relation for remote table "file_upload"
input FileUploadArrRelInsertInput {
  data: [FileUploadInsertInput!]!

  # upsert condition
  onConflict: FileUploadOnConflict
}

# aggregate avg on columns
type FileUploadAvgFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by avg() on columns of table "file_upload"
input FileUploadAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "file_upload". All fields are combined with a logical 'AND'.
input FileUploadBoolExp {
  _and: [FileUploadBoolExp!]
  _not: FileUploadBoolExp
  _or: [FileUploadBoolExp!]
  actorImage: ActorImageBoolExp
  address: AddressBoolExp
  contentAttachments: ContentAttachmentsBoolExp
  contentAttachmentsAggregate: ContentAttachmentsAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  document: DocumentBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  expenseItemAttachments: ExpenseItemAttachmentsBoolExp
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateBoolExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  fileLastModifiedAt: TimestamptzComparisonExp
  financeAttachments: FinanceAttachmentsBoolExp
  financeAttachmentsAggregate: FinanceAttachmentsAggregateBoolExp
  generatedDocumentGrantUnlocks: GrantUnlockBoolExp
  generatedDocumentGrantUnlocksAggregate: GrantUnlockAggregateBoolExp
  grantAttachments: GrantAttachmentsBoolExp
  grantAttachmentsAggregate: GrantAttachmentsAggregateBoolExp
  grantUnlockAttachments: GrantUnlockAttachmentsBoolExp
  grantUnlockAttachmentsAggregate: GrantUnlockAttachmentsAggregateBoolExp
  grantUnlocks: GrantUnlockBoolExp
  grantUnlocksAggregate: GrantUnlockAggregateBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  signatureGrants: GrantBoolExp
  signatureGrantsAggregate: GrantAggregateBoolExp
  size: IntComparisonExp
  tags: TagBoolExp
  tagsAggregate: TagAggregateBoolExp
  teams: TeamBoolExp
  teamsAggregate: TeamAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
  url: StringComparisonExp
}

# unique or primary key constraints on table "file_upload"
enum FileUploadConstraint {
  # unique or primary key constraint on columns "id"
  file_upload_pkey
}

# input type for incrementing numeric columns in table "file_upload"
input FileUploadIncInput {
  createdById: bigint
  id: bigint
  size: Int
  tenantId: bigint
}

# input type for inserting data into table "file_upload"
input FileUploadInsertInput {
  actorImage: ActorImageObjRelInsertInput
  address: AddressObjRelInsertInput
  contentAttachments: ContentAttachmentsArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  document: DocumentObjRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  events: EventArrRelInsertInput
  expenseItemAttachments: ExpenseItemAttachmentsArrRelInsertInput
  expenses: ExpenseArrRelInsertInput
  fileLastModifiedAt: timestamptz
  financeAttachments: FinanceAttachmentsArrRelInsertInput
  generatedDocumentGrantUnlocks: GrantUnlockArrRelInsertInput
  grantAttachments: GrantAttachmentsArrRelInsertInput
  grantUnlockAttachments: GrantUnlockAttachmentsArrRelInsertInput
  grantUnlocks: GrantUnlockArrRelInsertInput
  grants: GrantArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  name: String
  projects: ProjectArrRelInsertInput
  signatureGrants: GrantArrRelInsertInput
  size: Int
  tags: TagArrRelInsertInput
  teams: TeamArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
  url: String
}

# aggregate max on columns
type FileUploadMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantId: bigint
  type: String
  url: String
}

# order by max() on columns of table "file_upload"
input FileUploadMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fileLastModifiedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  size: OrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# aggregate min on columns
type FileUploadMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantId: bigint
  type: String
  url: String
}

# order by min() on columns of table "file_upload"
input FileUploadMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fileLastModifiedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  size: OrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# response of any mutation on the table "file_upload"
type FileUploadMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FileUpload!]!
}

# input type for inserting object relation for remote table "file_upload"
input FileUploadObjRelInsertInput {
  data: FileUploadInsertInput!

  # upsert condition
  onConflict: FileUploadOnConflict
}

# on_conflict condition type for table "file_upload"
input FileUploadOnConflict {
  constraint: FileUploadConstraint!
  updateColumns: [FileUploadUpdateColumn!]! = []
  where: FileUploadBoolExp
}

# Ordering options when selecting data from "file_upload".
input FileUploadOrderBy {
  actorImage: ActorImageOrderBy
  address: AddressOrderBy
  contentAttachmentsAggregate: ContentAttachmentsAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  document: DocumentOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventsAggregate: EventAggregateOrderBy
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateOrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  fileLastModifiedAt: OrderBy
  financeAttachmentsAggregate: FinanceAttachmentsAggregateOrderBy
  generatedDocumentGrantUnlocksAggregate: GrantUnlockAggregateOrderBy
  grantAttachmentsAggregate: GrantAttachmentsAggregateOrderBy
  grantUnlockAttachmentsAggregate: GrantUnlockAttachmentsAggregateOrderBy
  grantUnlocksAggregate: GrantUnlockAggregateOrderBy
  grantsAggregate: GrantAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  projectsAggregate: ProjectAggregateOrderBy
  signatureGrantsAggregate: GrantAggregateOrderBy
  size: OrderBy
  tagsAggregate: TagAggregateOrderBy
  teamsAggregate: TeamAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# primary key columns input for table: file_upload
input FileUploadPkColumnsInput {
  id: bigint!
}

# select columns of table "file_upload"
enum FileUploadSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fileLastModifiedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  size

  # column name
  tenantId

  # column name
  type

  # column name
  url
}

# input type for updating data in table "file_upload"
input FileUploadSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantId: bigint
  type: String
  url: String
}

# aggregate stddev on columns
type FileUploadStddevFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by stddev() on columns of table "file_upload"
input FileUploadStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FileUploadStddevPopFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "file_upload"
input FileUploadStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FileUploadStddevSampFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "file_upload"
input FileUploadStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "file_upload"
input FileUploadStreamCursorInput {
  # Stream column input with initial value
  initialValue: FileUploadStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FileUploadStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantId: bigint
  type: String
  url: String
}

# aggregate sum on columns
type FileUploadSumFields {
  createdById: bigint
  id: bigint
  size: Int
  tenantId: bigint
}

# order by sum() on columns of table "file_upload"
input FileUploadSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# update columns of table "file_upload"
enum FileUploadUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fileLastModifiedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  size

  # column name
  tenantId

  # column name
  type

  # column name
  url
}

input FileUploadUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FileUploadIncInput

  # sets the columns of the filtered rows to the given values
  _set: FileUploadSetInput

  # filter the rows which have to be updated
  where: FileUploadBoolExp!
}

# aggregate variance on columns
type FileUploadVarianceFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by variance() on columns of table "file_upload"
input FileUploadVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FileUploadVarPopFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by varPop() on columns of table "file_upload"
input FileUploadVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FileUploadVarSampFields {
  createdById: Float
  id: Float
  size: Float
  tenantId: Float
}

# order by varSamp() on columns of table "file_upload"
input FileUploadVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "finance"
type Finance {
  # An object relationship
  address: Address
  addressId: bigint
  addressType: String!
  amount: Float!
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  event: Event
  eventId: bigint

  # An object relationship
  expense: Expense
  expenseId: bigint

  # An array relationship
  financeAttachments(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): [FinanceAttachments!]!

  # An aggregate relationship
  financeAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): FinanceAttachmentsAggregate!

  # An array relationship
  grantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  grantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!
  hiddenAt: timestamptz
  id: bigint!
  method: String!
  name: String!
  payedAt: timestamptz!

  # An object relationship
  payedBy: Actor
  payedById: bigint
  payedByType: String!

  # An object relationship
  project: Project
  projectId: bigint

  # An object relationship
  receivedBy: Actor!
  receivedById: bigint!
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "finance"
type FinanceAggregate {
  aggregate: FinanceAggregateFields
  nodes: [Finance!]!
}

input FinanceAggregateBoolExp {
  count: financeAggregateBoolExpCount
}

input financeAggregateBoolExpCount {
  arguments: [FinanceSelectColumn!]
  distinct: Boolean
  filter: FinanceBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "finance"
type FinanceAggregateFields {
  avg: FinanceAvgFields
  count(columns: [FinanceSelectColumn!], distinct: Boolean): Int!
  max: FinanceMaxFields
  min: FinanceMinFields
  stddev: FinanceStddevFields
  stddevPop: FinanceStddevPopFields
  stddevSamp: FinanceStddevSampFields
  sum: FinanceSumFields
  varPop: FinanceVarPopFields
  varSamp: FinanceVarSampFields
  variance: FinanceVarianceFields
}

# order by aggregate values of table "finance"
input FinanceAggregateOrderBy {
  avg: FinanceAvgOrderBy
  count: OrderBy
  max: FinanceMaxOrderBy
  min: FinanceMinOrderBy
  stddev: FinanceStddevOrderBy
  stddevPop: FinanceStddevPopOrderBy
  stddevSamp: FinanceStddevSampOrderBy
  sum: FinanceSumOrderBy
  varPop: FinanceVarPopOrderBy
  varSamp: FinanceVarSampOrderBy
  variance: FinanceVarianceOrderBy
}

# input type for inserting array relation for remote table "finance"
input FinanceArrRelInsertInput {
  data: [FinanceInsertInput!]!

  # upsert condition
  onConflict: FinanceOnConflict
}

# columns and relationships of "finance_attachments"
type FinanceAttachments {
  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  finance: Finance!
  financeId: bigint!
}

# aggregated selection of "finance_attachments"
type FinanceAttachmentsAggregate {
  aggregate: FinanceAttachmentsAggregateFields
  nodes: [FinanceAttachments!]!
}

input FinanceAttachmentsAggregateBoolExp {
  count: financeAttachmentsAggregateBoolExpCount
}

input financeAttachmentsAggregateBoolExpCount {
  arguments: [FinanceAttachmentsSelectColumn!]
  distinct: Boolean
  filter: FinanceAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "finance_attachments"
type FinanceAttachmentsAggregateFields {
  avg: FinanceAttachmentsAvgFields
  count(columns: [FinanceAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: FinanceAttachmentsMaxFields
  min: FinanceAttachmentsMinFields
  stddev: FinanceAttachmentsStddevFields
  stddevPop: FinanceAttachmentsStddevPopFields
  stddevSamp: FinanceAttachmentsStddevSampFields
  sum: FinanceAttachmentsSumFields
  varPop: FinanceAttachmentsVarPopFields
  varSamp: FinanceAttachmentsVarSampFields
  variance: FinanceAttachmentsVarianceFields
}

# order by aggregate values of table "finance_attachments"
input FinanceAttachmentsAggregateOrderBy {
  avg: FinanceAttachmentsAvgOrderBy
  count: OrderBy
  max: FinanceAttachmentsMaxOrderBy
  min: FinanceAttachmentsMinOrderBy
  stddev: FinanceAttachmentsStddevOrderBy
  stddevPop: FinanceAttachmentsStddevPopOrderBy
  stddevSamp: FinanceAttachmentsStddevSampOrderBy
  sum: FinanceAttachmentsSumOrderBy
  varPop: FinanceAttachmentsVarPopOrderBy
  varSamp: FinanceAttachmentsVarSampOrderBy
  variance: FinanceAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "finance_attachments"
input FinanceAttachmentsArrRelInsertInput {
  data: [FinanceAttachmentsInsertInput!]!

  # upsert condition
  onConflict: FinanceAttachmentsOnConflict
}

# aggregate avg on columns
type FinanceAttachmentsAvgFields {
  fileUploadId: Float
  financeId: Float
}

# order by avg() on columns of table "finance_attachments"
input FinanceAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# Boolean expression to filter rows from the table "finance_attachments". All fields are combined with a logical 'AND'.
input FinanceAttachmentsBoolExp {
  _and: [FinanceAttachmentsBoolExp!]
  _not: FinanceAttachmentsBoolExp
  _or: [FinanceAttachmentsBoolExp!]
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  finance: FinanceBoolExp
  financeId: BigintComparisonExp
}

# unique or primary key constraints on table "finance_attachments"
enum FinanceAttachmentsConstraint {
  # unique or primary key constraint on columns "file_upload_id", "finance_id"
  finance_attachments_pkey
}

# input type for incrementing numeric columns in table "finance_attachments"
input FinanceAttachmentsIncInput {
  fileUploadId: bigint
  financeId: bigint
}

# input type for inserting data into table "finance_attachments"
input FinanceAttachmentsInsertInput {
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
  finance: FinanceObjRelInsertInput
  financeId: bigint
}

# aggregate max on columns
type FinanceAttachmentsMaxFields {
  fileUploadId: bigint
  financeId: bigint
}

# order by max() on columns of table "finance_attachments"
input FinanceAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate min on columns
type FinanceAttachmentsMinFields {
  fileUploadId: bigint
  financeId: bigint
}

# order by min() on columns of table "finance_attachments"
input FinanceAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# response of any mutation on the table "finance_attachments"
type FinanceAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FinanceAttachments!]!
}

# on_conflict condition type for table "finance_attachments"
input FinanceAttachmentsOnConflict {
  constraint: FinanceAttachmentsConstraint!
  updateColumns: [FinanceAttachmentsUpdateColumn!]! = []
  where: FinanceAttachmentsBoolExp
}

# Ordering options when selecting data from "finance_attachments".
input FinanceAttachmentsOrderBy {
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
  finance: FinanceOrderBy
  financeId: OrderBy
}

# primary key columns input for table: finance_attachments
input FinanceAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  financeId: bigint!
}

# select columns of table "finance_attachments"
enum FinanceAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  financeId
}

# input type for updating data in table "finance_attachments"
input FinanceAttachmentsSetInput {
  fileUploadId: bigint
  financeId: bigint
}

# aggregate stddev on columns
type FinanceAttachmentsStddevFields {
  fileUploadId: Float
  financeId: Float
}

# order by stddev() on columns of table "finance_attachments"
input FinanceAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate stddevPop on columns
type FinanceAttachmentsStddevPopFields {
  fileUploadId: Float
  financeId: Float
}

# order by stddevPop() on columns of table "finance_attachments"
input FinanceAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate stddevSamp on columns
type FinanceAttachmentsStddevSampFields {
  fileUploadId: Float
  financeId: Float
}

# order by stddevSamp() on columns of table "finance_attachments"
input FinanceAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# Streaming cursor of the table "finance_attachments"
input FinanceAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: FinanceAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FinanceAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  financeId: bigint
}

# aggregate sum on columns
type FinanceAttachmentsSumFields {
  fileUploadId: bigint
  financeId: bigint
}

# order by sum() on columns of table "finance_attachments"
input FinanceAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# update columns of table "finance_attachments"
enum FinanceAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  financeId
}

input FinanceAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FinanceAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: FinanceAttachmentsSetInput

  # filter the rows which have to be updated
  where: FinanceAttachmentsBoolExp!
}

# aggregate variance on columns
type FinanceAttachmentsVarianceFields {
  fileUploadId: Float
  financeId: Float
}

# order by variance() on columns of table "finance_attachments"
input FinanceAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate varPop on columns
type FinanceAttachmentsVarPopFields {
  fileUploadId: Float
  financeId: Float
}

# order by varPop() on columns of table "finance_attachments"
input FinanceAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate varSamp on columns
type FinanceAttachmentsVarSampFields {
  fileUploadId: Float
  financeId: Float
}

# order by varSamp() on columns of table "finance_attachments"
input FinanceAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  financeId: OrderBy
}

# aggregate avg on columns
type FinanceAvgFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "finance"
input FinanceAvgOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "finance". All fields are combined with a logical 'AND'.
input FinanceBoolExp {
  _and: [FinanceBoolExp!]
  _not: FinanceBoolExp
  _or: [FinanceBoolExp!]
  address: AddressBoolExp
  addressId: BigintComparisonExp
  addressType: StringComparisonExp
  amount: FloatComparisonExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  expense: ExpenseBoolExp
  expenseId: BigintComparisonExp
  financeAttachments: FinanceAttachmentsBoolExp
  financeAttachmentsAggregate: FinanceAttachmentsAggregateBoolExp
  grantUnlocks: GrantUnlockBoolExp
  grantUnlocksAggregate: GrantUnlockAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  method: StringComparisonExp
  name: StringComparisonExp
  payedAt: TimestamptzComparisonExp
  payedBy: ActorBoolExp
  payedById: BigintComparisonExp
  payedByType: StringComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  receivedBy: ActorBoolExp
  receivedById: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "finance"
enum FinanceConstraint {
  # unique or primary key constraint on columns "expense_id"
  finance_expense_id_unique

  # unique or primary key constraint on columns "id"
  finance_pkey
}

# input type for incrementing numeric columns in table "finance"
input FinanceIncInput {
  addressId: bigint
  amount: Float
  createdById: bigint
  eventId: bigint
  expenseId: bigint
  id: bigint
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "finance"
input FinanceInsertInput {
  address: AddressObjRelInsertInput
  addressId: bigint
  addressType: String
  amount: Float
  category: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  event: EventObjRelInsertInput
  eventId: bigint
  expense: ExpenseObjRelInsertInput
  expenseId: bigint
  financeAttachments: FinanceAttachmentsArrRelInsertInput
  grantUnlocks: GrantUnlockArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  method: String
  name: String
  payedAt: timestamptz
  payedBy: ActorObjRelInsertInput
  payedById: bigint
  payedByType: String
  project: ProjectObjRelInsertInput
  projectId: bigint
  receivedBy: ActorObjRelInsertInput
  receivedById: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type FinanceMaxFields {
  addressId: bigint
  addressType: String
  amount: Float
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  method: String
  name: String
  payedAt: timestamptz
  payedById: bigint
  payedByType: String
  projectId: bigint
  receivedById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "finance"
input FinanceMaxOrderBy {
  addressId: OrderBy
  addressType: OrderBy
  amount: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  method: OrderBy
  name: OrderBy
  payedAt: OrderBy
  payedById: OrderBy
  payedByType: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type FinanceMinFields {
  addressId: bigint
  addressType: String
  amount: Float
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  method: String
  name: String
  payedAt: timestamptz
  payedById: bigint
  payedByType: String
  projectId: bigint
  receivedById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "finance"
input FinanceMinOrderBy {
  addressId: OrderBy
  addressType: OrderBy
  amount: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  method: OrderBy
  name: OrderBy
  payedAt: OrderBy
  payedById: OrderBy
  payedByType: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "finance"
type FinanceMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Finance!]!
}

# input type for inserting object relation for remote table "finance"
input FinanceObjRelInsertInput {
  data: FinanceInsertInput!

  # upsert condition
  onConflict: FinanceOnConflict
}

# on_conflict condition type for table "finance"
input FinanceOnConflict {
  constraint: FinanceConstraint!
  updateColumns: [FinanceUpdateColumn!]! = []
  where: FinanceBoolExp
}

# Ordering options when selecting data from "finance".
input FinanceOrderBy {
  address: AddressOrderBy
  addressId: OrderBy
  addressType: OrderBy
  amount: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  expense: ExpenseOrderBy
  expenseId: OrderBy
  financeAttachmentsAggregate: FinanceAttachmentsAggregateOrderBy
  grantUnlocksAggregate: GrantUnlockAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  method: OrderBy
  name: OrderBy
  payedAt: OrderBy
  payedBy: ActorOrderBy
  payedById: OrderBy
  payedByType: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  receivedBy: ActorOrderBy
  receivedById: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: finance
input FinancePkColumnsInput {
  id: bigint!
}

# select columns of table "finance"
enum FinanceSelectColumn {
  # column name
  addressId

  # column name
  addressType

  # column name
  amount

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  method

  # column name
  name

  # column name
  payedAt

  # column name
  payedById

  # column name
  payedByType

  # column name
  projectId

  # column name
  receivedById

  # column name
  state

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "finance"
input FinanceSetInput {
  addressId: bigint
  addressType: String
  amount: Float
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  method: String
  name: String
  payedAt: timestamptz
  payedById: bigint
  payedByType: String
  projectId: bigint
  receivedById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type FinanceStddevFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "finance"
input FinanceStddevOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FinanceStddevPopFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "finance"
input FinanceStddevPopOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FinanceStddevSampFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "finance"
input FinanceStddevSampOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "finance"
input FinanceStreamCursorInput {
  # Stream column input with initial value
  initialValue: FinanceStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FinanceStreamCursorValueInput {
  addressId: bigint
  addressType: String
  amount: Float
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  method: String
  name: String
  payedAt: timestamptz
  payedById: bigint
  payedByType: String
  projectId: bigint
  receivedById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type FinanceSumFields {
  addressId: bigint
  amount: Float
  createdById: bigint
  eventId: bigint
  expenseId: bigint
  id: bigint
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "finance"
input FinanceSumOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "finance"
enum FinanceUpdateColumn {
  # column name
  addressId

  # column name
  addressType

  # column name
  amount

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  method

  # column name
  name

  # column name
  payedAt

  # column name
  payedById

  # column name
  payedByType

  # column name
  projectId

  # column name
  receivedById

  # column name
  state

  # column name
  teamId

  # column name
  tenantId
}

input FinanceUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FinanceIncInput

  # sets the columns of the filtered rows to the given values
  _set: FinanceSetInput

  # filter the rows which have to be updated
  where: FinanceBoolExp!
}

# aggregate variance on columns
type FinanceVarianceFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "finance"
input FinanceVarianceOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FinanceVarPopFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "finance"
input FinanceVarPopOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FinanceVarSampFields {
  addressId: Float
  amount: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "finance"
input FinanceVarSampOrderBy {
  addressId: OrderBy
  amount: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
input FloatComparisonExp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _isNull: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

# columns and relationships of "follow"
type Follow {
  # An object relationship
  actor: Actor!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "follow"
type FollowAggregate {
  aggregate: FollowAggregateFields
  nodes: [Follow!]!
}

input FollowAggregateBoolExp {
  count: followAggregateBoolExpCount
}

input followAggregateBoolExpCount {
  arguments: [FollowSelectColumn!]
  distinct: Boolean
  filter: FollowBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "follow"
type FollowAggregateFields {
  avg: FollowAvgFields
  count(columns: [FollowSelectColumn!], distinct: Boolean): Int!
  max: FollowMaxFields
  min: FollowMinFields
  stddev: FollowStddevFields
  stddevPop: FollowStddevPopFields
  stddevSamp: FollowStddevSampFields
  sum: FollowSumFields
  varPop: FollowVarPopFields
  varSamp: FollowVarSampFields
  variance: FollowVarianceFields
}

# order by aggregate values of table "follow"
input FollowAggregateOrderBy {
  avg: FollowAvgOrderBy
  count: OrderBy
  max: FollowMaxOrderBy
  min: FollowMinOrderBy
  stddev: FollowStddevOrderBy
  stddevPop: FollowStddevPopOrderBy
  stddevSamp: FollowStddevSampOrderBy
  sum: FollowSumOrderBy
  varPop: FollowVarPopOrderBy
  varSamp: FollowVarSampOrderBy
  variance: FollowVarianceOrderBy
}

# input type for inserting array relation for remote table "follow"
input FollowArrRelInsertInput {
  data: [FollowInsertInput!]!

  # upsert condition
  onConflict: FollowOnConflict
}

# aggregate avg on columns
type FollowAvgFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "follow"
input FollowAvgOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "follow". All fields are combined with a logical 'AND'.
input FollowBoolExp {
  _and: [FollowBoolExp!]
  _not: FollowBoolExp
  _or: [FollowBoolExp!]
  actor: ActorBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  followedActorId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "follow"
enum FollowConstraint {
  # unique or primary key constraint on columns "id"
  follow_pkey
}

# input type for incrementing numeric columns in table "follow"
input FollowIncInput {
  createdById: bigint
  followedActorId: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "follow"
input FollowInsertInput {
  actor: ActorObjRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type FollowMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "follow"
input FollowMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type FollowMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "follow"
input FollowMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "follow"
type FollowMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Follow!]!
}

# on_conflict condition type for table "follow"
input FollowOnConflict {
  constraint: FollowConstraint!
  updateColumns: [FollowUpdateColumn!]! = []
  where: FollowBoolExp
}

# Ordering options when selecting data from "follow".
input FollowOrderBy {
  actor: ActorOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: follow
input FollowPkColumnsInput {
  id: bigint!
}

# select columns of table "follow"
enum FollowSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  followedActorId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

# input type for updating data in table "follow"
input FollowSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type FollowStddevFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "follow"
input FollowStddevOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FollowStddevPopFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "follow"
input FollowStddevPopOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FollowStddevSampFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "follow"
input FollowStddevSampOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "follow"
input FollowStreamCursorInput {
  # Stream column input with initial value
  initialValue: FollowStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FollowStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# aggregate sum on columns
type FollowSumFields {
  createdById: bigint
  followedActorId: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "follow"
input FollowSumOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "follow"
enum FollowUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  followedActorId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId
}

input FollowUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FollowIncInput

  # sets the columns of the filtered rows to the given values
  _set: FollowSetInput

  # filter the rows which have to be updated
  where: FollowBoolExp!
}

# aggregate variance on columns
type FollowVarianceFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "follow"
input FollowVarianceOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FollowVarPopFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "follow"
input FollowVarPopOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FollowVarSampFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "follow"
input FollowVarSampOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "form"
type Form {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  formSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  formSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isAllowingEditingAnswers: Boolean!
  isAllowingMultipleAnswers: Boolean!
  isEnabled: Boolean!
  isRequired: Boolean!
  name: String!
  schema(
    # JSON select path
    path: String
  ): jsonb!

  # An object relationship
  team: Team
  teamId: bigint

  # An object relationship
  tenant: Tenant!

  # An object relationship
  tenantById: Tenant
  tenantId: bigint!
  type: String!
}

# aggregated selection of "form"
type FormAggregate {
  aggregate: FormAggregateFields
  nodes: [Form!]!
}

input FormAggregateBoolExp {
  bool_and: formAggregateBoolExpBool_and
  bool_or: formAggregateBoolExpBool_or
  count: formAggregateBoolExpCount
}

input formAggregateBoolExpBool_and {
  arguments: FormSelectColumnFormAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: FormBoolExp
  predicate: BooleanComparisonExp!
}

input formAggregateBoolExpBool_or {
  arguments: FormSelectColumnFormAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: FormBoolExp
  predicate: BooleanComparisonExp!
}

input formAggregateBoolExpCount {
  arguments: [FormSelectColumn!]
  distinct: Boolean
  filter: FormBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "form"
type FormAggregateFields {
  avg: FormAvgFields
  count(columns: [FormSelectColumn!], distinct: Boolean): Int!
  max: FormMaxFields
  min: FormMinFields
  stddev: FormStddevFields
  stddevPop: FormStddevPopFields
  stddevSamp: FormStddevSampFields
  sum: FormSumFields
  varPop: FormVarPopFields
  varSamp: FormVarSampFields
  variance: FormVarianceFields
}

# order by aggregate values of table "form"
input FormAggregateOrderBy {
  avg: FormAvgOrderBy
  count: OrderBy
  max: FormMaxOrderBy
  min: FormMinOrderBy
  stddev: FormStddevOrderBy
  stddevPop: FormStddevPopOrderBy
  stddevSamp: FormStddevSampOrderBy
  sum: FormSumOrderBy
  varPop: FormVarPopOrderBy
  varSamp: FormVarSampOrderBy
  variance: FormVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input FormAppendInput {
  schema: jsonb
}

# input type for inserting array relation for remote table "form"
input FormArrRelInsertInput {
  data: [FormInsertInput!]!

  # upsert condition
  onConflict: FormOnConflict
}

# aggregate avg on columns
type FormAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "form"
input FormAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "form". All fields are combined with a logical 'AND'.
input FormBoolExp {
  _and: [FormBoolExp!]
  _not: FormBoolExp
  _or: [FormBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  formSubmissions: FormSubmissionBoolExp
  formSubmissionsAggregate: FormSubmissionAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAllowingEditingAnswers: BooleanComparisonExp
  isAllowingMultipleAnswers: BooleanComparisonExp
  isEnabled: BooleanComparisonExp
  isRequired: BooleanComparisonExp
  name: StringComparisonExp
  schema: JsonbComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantById: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "form"
enum FormConstraint {
  # unique or primary key constraint on columns "id"
  form_pkey

  # unique or primary key constraint on columns "team_id"
  form_team_id_unique
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input FormDeleteAtPathInput {
  schema: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input FormDeleteElemInput {
  schema: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input FormDeleteKeyInput {
  schema: String
}

# input type for incrementing numeric columns in table "form"
input FormIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "form"
input FormInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  events: EventArrRelInsertInput
  formSubmissions: FormSubmissionArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isRequired: Boolean
  name: String
  schema: jsonb
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantById: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type FormMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by max() on columns of table "form"
input FormMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type FormMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by min() on columns of table "form"
input FormMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "form"
type FormMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Form!]!
}

# input type for inserting object relation for remote table "form"
input FormObjRelInsertInput {
  data: FormInsertInput!

  # upsert condition
  onConflict: FormOnConflict
}

# on_conflict condition type for table "form"
input FormOnConflict {
  constraint: FormConstraint!
  updateColumns: [FormUpdateColumn!]! = []
  where: FormBoolExp
}

# Ordering options when selecting data from "form".
input FormOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventsAggregate: EventAggregateOrderBy
  formSubmissionsAggregate: FormSubmissionAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAllowingEditingAnswers: OrderBy
  isAllowingMultipleAnswers: OrderBy
  isEnabled: OrderBy
  isRequired: OrderBy
  name: OrderBy
  schema: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantById: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: form
input FormPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input FormPrependInput {
  schema: jsonb
}

# select columns of table "form"
enum FormSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isRequired

  # column name
  name

  # column name
  schema

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

# select "formAggregateBoolExpBool_andArgumentsColumns" columns of table "form"
enum FormSelectColumnFormAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isRequired
}

# select "formAggregateBoolExpBool_orArgumentsColumns" columns of table "form"
enum FormSelectColumnFormAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isRequired
}

# input type for updating data in table "form"
input FormSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isRequired: Boolean
  name: String
  schema: jsonb
  teamId: bigint
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type FormStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "form"
input FormStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FormStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "form"
input FormStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FormStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "form"
input FormStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "form"
input FormStreamCursorInput {
  # Stream column input with initial value
  initialValue: FormStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FormStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isRequired: Boolean
  name: String
  schema: jsonb
  teamId: bigint
  tenantId: bigint
  type: String
}

# columns and relationships of "form_submission"
type FormSubmission {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An object relationship
  form: Form!
  formId: bigint!
  hiddenAt: timestamptz
  id: bigint!
  submission(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "form_submission"
type FormSubmissionAggregate {
  aggregate: FormSubmissionAggregateFields
  nodes: [FormSubmission!]!
}

input FormSubmissionAggregateBoolExp {
  count: formSubmissionAggregateBoolExpCount
}

input formSubmissionAggregateBoolExpCount {
  arguments: [FormSubmissionSelectColumn!]
  distinct: Boolean
  filter: FormSubmissionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "form_submission"
type FormSubmissionAggregateFields {
  avg: FormSubmissionAvgFields
  count(columns: [FormSubmissionSelectColumn!], distinct: Boolean): Int!
  max: FormSubmissionMaxFields
  min: FormSubmissionMinFields
  stddev: FormSubmissionStddevFields
  stddevPop: FormSubmissionStddevPopFields
  stddevSamp: FormSubmissionStddevSampFields
  sum: FormSubmissionSumFields
  varPop: FormSubmissionVarPopFields
  varSamp: FormSubmissionVarSampFields
  variance: FormSubmissionVarianceFields
}

# order by aggregate values of table "form_submission"
input FormSubmissionAggregateOrderBy {
  avg: FormSubmissionAvgOrderBy
  count: OrderBy
  max: FormSubmissionMaxOrderBy
  min: FormSubmissionMinOrderBy
  stddev: FormSubmissionStddevOrderBy
  stddevPop: FormSubmissionStddevPopOrderBy
  stddevSamp: FormSubmissionStddevSampOrderBy
  sum: FormSubmissionSumOrderBy
  varPop: FormSubmissionVarPopOrderBy
  varSamp: FormSubmissionVarSampOrderBy
  variance: FormSubmissionVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input FormSubmissionAppendInput {
  submission: jsonb
}

# input type for inserting array relation for remote table "form_submission"
input FormSubmissionArrRelInsertInput {
  data: [FormSubmissionInsertInput!]!

  # upsert condition
  onConflict: FormSubmissionOnConflict
}

# aggregate avg on columns
type FormSubmissionAvgFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "form_submission"
input FormSubmissionAvgOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "form_submission". All fields are combined with a logical 'AND'.
input FormSubmissionBoolExp {
  _and: [FormSubmissionBoolExp!]
  _not: FormSubmissionBoolExp
  _or: [FormSubmissionBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  form: FormBoolExp
  formId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  submission: JsonbComparisonExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "form_submission"
enum FormSubmissionConstraint {
  # unique or primary key constraint on columns "id"
  form_submission_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input FormSubmissionDeleteAtPathInput {
  submission: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input FormSubmissionDeleteElemInput {
  submission: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input FormSubmissionDeleteKeyInput {
  submission: String
}

# input type for incrementing numeric columns in table "form_submission"
input FormSubmissionIncInput {
  createdById: bigint
  formId: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "form_submission"
input FormSubmissionInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  form: FormObjRelInsertInput
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  teamJoins: TeamJoinArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type FormSubmissionMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by max() on columns of table "form_submission"
input FormSubmissionMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type FormSubmissionMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
}

# order by min() on columns of table "form_submission"
input FormSubmissionMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "form_submission"
type FormSubmissionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FormSubmission!]!
}

# input type for inserting object relation for remote table "form_submission"
input FormSubmissionObjRelInsertInput {
  data: FormSubmissionInsertInput!

  # upsert condition
  onConflict: FormSubmissionOnConflict
}

# on_conflict condition type for table "form_submission"
input FormSubmissionOnConflict {
  constraint: FormSubmissionConstraint!
  updateColumns: [FormSubmissionUpdateColumn!]! = []
  where: FormSubmissionBoolExp
}

# Ordering options when selecting data from "form_submission".
input FormSubmissionOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  form: FormOrderBy
  formId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  submission: OrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: form_submission
input FormSubmissionPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input FormSubmissionPrependInput {
  submission: jsonb
}

# select columns of table "form_submission"
enum FormSubmissionSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formId

  # column name
  hiddenAt

  # column name
  id

  # column name
  submission

  # column name
  tenantId
}

# input type for updating data in table "form_submission"
input FormSubmissionSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  tenantId: bigint
}

# aggregate stddev on columns
type FormSubmissionStddevFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "form_submission"
input FormSubmissionStddevOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type FormSubmissionStddevPopFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "form_submission"
input FormSubmissionStddevPopOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type FormSubmissionStddevSampFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "form_submission"
input FormSubmissionStddevSampOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "form_submission"
input FormSubmissionStreamCursorInput {
  # Stream column input with initial value
  initialValue: FormSubmissionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FormSubmissionStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  tenantId: bigint
}

# aggregate sum on columns
type FormSubmissionSumFields {
  createdById: bigint
  formId: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "form_submission"
input FormSubmissionSumOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "form_submission"
enum FormSubmissionUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formId

  # column name
  hiddenAt

  # column name
  id

  # column name
  submission

  # column name
  tenantId
}

input FormSubmissionUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: FormSubmissionAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: FormSubmissionDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: FormSubmissionDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: FormSubmissionDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: FormSubmissionIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: FormSubmissionPrependInput

  # sets the columns of the filtered rows to the given values
  _set: FormSubmissionSetInput

  # filter the rows which have to be updated
  where: FormSubmissionBoolExp!
}

# aggregate variance on columns
type FormSubmissionVarianceFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "form_submission"
input FormSubmissionVarianceOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FormSubmissionVarPopFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "form_submission"
input FormSubmissionVarPopOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FormSubmissionVarSampFields {
  createdById: Float
  formId: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "form_submission"
input FormSubmissionVarSampOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate sum on columns
type FormSumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "form"
input FormSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "form"
enum FormUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isRequired

  # column name
  name

  # column name
  schema

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

input FormUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: FormAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: FormDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: FormDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: FormDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: FormIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: FormPrependInput

  # sets the columns of the filtered rows to the given values
  _set: FormSetInput

  # filter the rows which have to be updated
  where: FormBoolExp!
}

# aggregate variance on columns
type FormVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "form"
input FormVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type FormVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "form"
input FormVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type FormVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "form"
input FormVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "grant"
type Grant {
  amountAsked: Float!
  amountGiven: Float!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  generatedDocument: FileUpload
  generatedDocumentId: bigint

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # An array relationship
  grantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  grantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An object relationship
  signature: FileUpload
  signatureId: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  validatedAt: timestamptz

  # An object relationship
  validatedBy: Individual
  validatedById: bigint
}

# aggregated selection of "grant"
type GrantAggregate {
  aggregate: GrantAggregateFields
  nodes: [Grant!]!
}

input GrantAggregateBoolExp {
  count: grantAggregateBoolExpCount
}

input grantAggregateBoolExpCount {
  arguments: [GrantSelectColumn!]
  distinct: Boolean
  filter: GrantBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant"
type GrantAggregateFields {
  avg: GrantAvgFields
  count(columns: [GrantSelectColumn!], distinct: Boolean): Int!
  max: GrantMaxFields
  min: GrantMinFields
  stddev: GrantStddevFields
  stddevPop: GrantStddevPopFields
  stddevSamp: GrantStddevSampFields
  sum: GrantSumFields
  varPop: GrantVarPopFields
  varSamp: GrantVarSampFields
  variance: GrantVarianceFields
}

# order by aggregate values of table "grant"
input GrantAggregateOrderBy {
  avg: GrantAvgOrderBy
  count: OrderBy
  max: GrantMaxOrderBy
  min: GrantMinOrderBy
  stddev: GrantStddevOrderBy
  stddevPop: GrantStddevPopOrderBy
  stddevSamp: GrantStddevSampOrderBy
  sum: GrantSumOrderBy
  varPop: GrantVarPopOrderBy
  varSamp: GrantVarSampOrderBy
  variance: GrantVarianceOrderBy
}

# input type for inserting array relation for remote table "grant"
input GrantArrRelInsertInput {
  data: [GrantInsertInput!]!

  # upsert condition
  onConflict: GrantOnConflict
}

# columns and relationships of "grant_attachments"
type GrantAttachments {
  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  grant: Grant!
  grantId: bigint!
}

# aggregated selection of "grant_attachments"
type GrantAttachmentsAggregate {
  aggregate: GrantAttachmentsAggregateFields
  nodes: [GrantAttachments!]!
}

input GrantAttachmentsAggregateBoolExp {
  count: grantAttachmentsAggregateBoolExpCount
}

input grantAttachmentsAggregateBoolExpCount {
  arguments: [GrantAttachmentsSelectColumn!]
  distinct: Boolean
  filter: GrantAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_attachments"
type GrantAttachmentsAggregateFields {
  avg: GrantAttachmentsAvgFields
  count(columns: [GrantAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: GrantAttachmentsMaxFields
  min: GrantAttachmentsMinFields
  stddev: GrantAttachmentsStddevFields
  stddevPop: GrantAttachmentsStddevPopFields
  stddevSamp: GrantAttachmentsStddevSampFields
  sum: GrantAttachmentsSumFields
  varPop: GrantAttachmentsVarPopFields
  varSamp: GrantAttachmentsVarSampFields
  variance: GrantAttachmentsVarianceFields
}

# order by aggregate values of table "grant_attachments"
input GrantAttachmentsAggregateOrderBy {
  avg: GrantAttachmentsAvgOrderBy
  count: OrderBy
  max: GrantAttachmentsMaxOrderBy
  min: GrantAttachmentsMinOrderBy
  stddev: GrantAttachmentsStddevOrderBy
  stddevPop: GrantAttachmentsStddevPopOrderBy
  stddevSamp: GrantAttachmentsStddevSampOrderBy
  sum: GrantAttachmentsSumOrderBy
  varPop: GrantAttachmentsVarPopOrderBy
  varSamp: GrantAttachmentsVarSampOrderBy
  variance: GrantAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_attachments"
input GrantAttachmentsArrRelInsertInput {
  data: [GrantAttachmentsInsertInput!]!

  # upsert condition
  onConflict: GrantAttachmentsOnConflict
}

# aggregate avg on columns
type GrantAttachmentsAvgFields {
  fileUploadId: Float
  grantId: Float
}

# order by avg() on columns of table "grant_attachments"
input GrantAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# Boolean expression to filter rows from the table "grant_attachments". All fields are combined with a logical 'AND'.
input GrantAttachmentsBoolExp {
  _and: [GrantAttachmentsBoolExp!]
  _not: GrantAttachmentsBoolExp
  _or: [GrantAttachmentsBoolExp!]
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  grant: GrantBoolExp
  grantId: BigintComparisonExp
}

# unique or primary key constraints on table "grant_attachments"
enum GrantAttachmentsConstraint {
  # unique or primary key constraint on columns "file_upload_id", "grant_id"
  grant_attachments_pkey
}

# input type for incrementing numeric columns in table "grant_attachments"
input GrantAttachmentsIncInput {
  fileUploadId: bigint
  grantId: bigint
}

# input type for inserting data into table "grant_attachments"
input GrantAttachmentsInsertInput {
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
  grant: GrantObjRelInsertInput
  grantId: bigint
}

# aggregate max on columns
type GrantAttachmentsMaxFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by max() on columns of table "grant_attachments"
input GrantAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate min on columns
type GrantAttachmentsMinFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by min() on columns of table "grant_attachments"
input GrantAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# response of any mutation on the table "grant_attachments"
type GrantAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantAttachments!]!
}

# on_conflict condition type for table "grant_attachments"
input GrantAttachmentsOnConflict {
  constraint: GrantAttachmentsConstraint!
  updateColumns: [GrantAttachmentsUpdateColumn!]! = []
  where: GrantAttachmentsBoolExp
}

# Ordering options when selecting data from "grant_attachments".
input GrantAttachmentsOrderBy {
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
  grant: GrantOrderBy
  grantId: OrderBy
}

# primary key columns input for table: grant_attachments
input GrantAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  grantId: bigint!
}

# select columns of table "grant_attachments"
enum GrantAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  grantId
}

# input type for updating data in table "grant_attachments"
input GrantAttachmentsSetInput {
  fileUploadId: bigint
  grantId: bigint
}

# aggregate stddev on columns
type GrantAttachmentsStddevFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddev() on columns of table "grant_attachments"
input GrantAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate stddevPop on columns
type GrantAttachmentsStddevPopFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddevPop() on columns of table "grant_attachments"
input GrantAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate stddevSamp on columns
type GrantAttachmentsStddevSampFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddevSamp() on columns of table "grant_attachments"
input GrantAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# Streaming cursor of the table "grant_attachments"
input GrantAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  grantId: bigint
}

# aggregate sum on columns
type GrantAttachmentsSumFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by sum() on columns of table "grant_attachments"
input GrantAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# update columns of table "grant_attachments"
enum GrantAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  grantId
}

input GrantAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantAttachmentsSetInput

  # filter the rows which have to be updated
  where: GrantAttachmentsBoolExp!
}

# aggregate variance on columns
type GrantAttachmentsVarianceFields {
  fileUploadId: Float
  grantId: Float
}

# order by variance() on columns of table "grant_attachments"
input GrantAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate varPop on columns
type GrantAttachmentsVarPopFields {
  fileUploadId: Float
  grantId: Float
}

# order by varPop() on columns of table "grant_attachments"
input GrantAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate varSamp on columns
type GrantAttachmentsVarSampFields {
  fileUploadId: Float
  grantId: Float
}

# order by varSamp() on columns of table "grant_attachments"
input GrantAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate avg on columns
type GrantAvgFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by avg() on columns of table "grant"
input GrantAvgOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# Boolean expression to filter rows from the table "grant". All fields are combined with a logical 'AND'.
input GrantBoolExp {
  _and: [GrantBoolExp!]
  _not: GrantBoolExp
  _or: [GrantBoolExp!]
  amountAsked: FloatComparisonExp
  amountGiven: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  generatedDocument: FileUploadBoolExp
  generatedDocumentId: BigintComparisonExp
  grantAttachments: GrantAttachmentsBoolExp
  grantAttachmentsAggregate: GrantAttachmentsAggregateBoolExp
  grantUnlocks: GrantUnlockBoolExp
  grantUnlocksAggregate: GrantUnlockAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  signature: FileUploadBoolExp
  signatureId: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  validatedAt: TimestamptzComparisonExp
  validatedBy: IndividualBoolExp
  validatedById: BigintComparisonExp
}

# unique or primary key constraints on table "grant"
enum GrantConstraint {
  # unique or primary key constraint on columns "id"
  grant_pkey
}

# input type for incrementing numeric columns in table "grant"
input GrantIncInput {
  amountAsked: Float
  amountGiven: Float
  createdById: bigint
  generatedDocumentId: bigint
  id: bigint
  signatureId: bigint
  teamId: bigint
  tenantId: bigint
  validatedById: bigint
}

# input type for inserting data into table "grant"
input GrantInsertInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  generatedDocument: FileUploadObjRelInsertInput
  generatedDocumentId: bigint
  grantAttachments: GrantAttachmentsArrRelInsertInput
  grantUnlocks: GrantUnlockArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  projects: ProjectArrRelInsertInput
  signature: FileUploadObjRelInsertInput
  signatureId: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  validatedAt: timestamptz
  validatedBy: IndividualObjRelInsertInput
  validatedById: bigint
}

# aggregate max on columns
type GrantMaxFields {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# order by max() on columns of table "grant"
input GrantMaxOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  signatureId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedById: OrderBy
}

# aggregate min on columns
type GrantMinFields {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# order by min() on columns of table "grant"
input GrantMinOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  signatureId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedById: OrderBy
}

# response of any mutation on the table "grant"
type GrantMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Grant!]!
}

# input type for inserting object relation for remote table "grant"
input GrantObjRelInsertInput {
  data: GrantInsertInput!

  # upsert condition
  onConflict: GrantOnConflict
}

# on_conflict condition type for table "grant"
input GrantOnConflict {
  constraint: GrantConstraint!
  updateColumns: [GrantUpdateColumn!]! = []
  where: GrantBoolExp
}

# Ordering options when selecting data from "grant".
input GrantOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocument: FileUploadOrderBy
  generatedDocumentId: OrderBy
  grantAttachmentsAggregate: GrantAttachmentsAggregateOrderBy
  grantUnlocksAggregate: GrantUnlockAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  projectsAggregate: ProjectAggregateOrderBy
  signature: FileUploadOrderBy
  signatureId: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedBy: IndividualOrderBy
  validatedById: OrderBy
}

# primary key columns input for table: grant
input GrantPkColumnsInput {
  id: bigint!
}

# select columns of table "grant"
enum GrantSelectColumn {
  # column name
  amountAsked

  # column name
  amountGiven

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  hiddenAt

  # column name
  id

  # column name
  signatureId

  # column name
  state

  # column name
  teamId

  # column name
  tenantId

  # column name
  validatedAt

  # column name
  validatedById
}

# input type for updating data in table "grant"
input GrantSetInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# aggregate stddev on columns
type GrantStddevFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddev() on columns of table "grant"
input GrantStddevOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate stddevPop on columns
type GrantStddevPopFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddevPop() on columns of table "grant"
input GrantStddevPopOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate stddevSamp on columns
type GrantStddevSampFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddevSamp() on columns of table "grant"
input GrantStddevSampOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# Streaming cursor of the table "grant"
input GrantStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantStreamCursorValueInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# aggregate sum on columns
type GrantSumFields {
  amountAsked: Float
  amountGiven: Float
  createdById: bigint
  generatedDocumentId: bigint
  id: bigint
  signatureId: bigint
  teamId: bigint
  tenantId: bigint
  validatedById: bigint
}

# order by sum() on columns of table "grant"
input GrantSumOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# columns and relationships of "grant_unlock"
type GrantUnlock {
  amountAsked: Float!
  amountGiven: Float!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  finance: Finance
  financeId: bigint

  # An object relationship
  generatedDocument: FileUpload
  generatedDocumentId: bigint

  # An object relationship
  grant: Grant!
  grantId: bigint!

  # An array relationship
  grantUnlockAttachments(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): [GrantUnlockAttachments!]!

  # An aggregate relationship
  grantUnlockAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): GrantUnlockAttachmentsAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  signature: FileUpload
  signatureId: bigint
  state: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  validatedAt: timestamptz

  # An object relationship
  validatedBy: Individual
  validatedById: bigint
}

# aggregated selection of "grant_unlock"
type GrantUnlockAggregate {
  aggregate: GrantUnlockAggregateFields
  nodes: [GrantUnlock!]!
}

input GrantUnlockAggregateBoolExp {
  count: grantUnlockAggregateBoolExpCount
}

input grantUnlockAggregateBoolExpCount {
  arguments: [GrantUnlockSelectColumn!]
  distinct: Boolean
  filter: GrantUnlockBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_unlock"
type GrantUnlockAggregateFields {
  avg: GrantUnlockAvgFields
  count(columns: [GrantUnlockSelectColumn!], distinct: Boolean): Int!
  max: GrantUnlockMaxFields
  min: GrantUnlockMinFields
  stddev: GrantUnlockStddevFields
  stddevPop: GrantUnlockStddevPopFields
  stddevSamp: GrantUnlockStddevSampFields
  sum: GrantUnlockSumFields
  varPop: GrantUnlockVarPopFields
  varSamp: GrantUnlockVarSampFields
  variance: GrantUnlockVarianceFields
}

# order by aggregate values of table "grant_unlock"
input GrantUnlockAggregateOrderBy {
  avg: GrantUnlockAvgOrderBy
  count: OrderBy
  max: GrantUnlockMaxOrderBy
  min: GrantUnlockMinOrderBy
  stddev: GrantUnlockStddevOrderBy
  stddevPop: GrantUnlockStddevPopOrderBy
  stddevSamp: GrantUnlockStddevSampOrderBy
  sum: GrantUnlockSumOrderBy
  varPop: GrantUnlockVarPopOrderBy
  varSamp: GrantUnlockVarSampOrderBy
  variance: GrantUnlockVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_unlock"
input GrantUnlockArrRelInsertInput {
  data: [GrantUnlockInsertInput!]!

  # upsert condition
  onConflict: GrantUnlockOnConflict
}

# columns and relationships of "grant_unlock_attachments"
type GrantUnlockAttachments {
  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  grantUnlock: GrantUnlock!
  grantUnlockId: bigint!
}

# aggregated selection of "grant_unlock_attachments"
type GrantUnlockAttachmentsAggregate {
  aggregate: GrantUnlockAttachmentsAggregateFields
  nodes: [GrantUnlockAttachments!]!
}

input GrantUnlockAttachmentsAggregateBoolExp {
  count: grantUnlockAttachmentsAggregateBoolExpCount
}

input grantUnlockAttachmentsAggregateBoolExpCount {
  arguments: [GrantUnlockAttachmentsSelectColumn!]
  distinct: Boolean
  filter: GrantUnlockAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_unlock_attachments"
type GrantUnlockAttachmentsAggregateFields {
  avg: GrantUnlockAttachmentsAvgFields
  count(columns: [GrantUnlockAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: GrantUnlockAttachmentsMaxFields
  min: GrantUnlockAttachmentsMinFields
  stddev: GrantUnlockAttachmentsStddevFields
  stddevPop: GrantUnlockAttachmentsStddevPopFields
  stddevSamp: GrantUnlockAttachmentsStddevSampFields
  sum: GrantUnlockAttachmentsSumFields
  varPop: GrantUnlockAttachmentsVarPopFields
  varSamp: GrantUnlockAttachmentsVarSampFields
  variance: GrantUnlockAttachmentsVarianceFields
}

# order by aggregate values of table "grant_unlock_attachments"
input GrantUnlockAttachmentsAggregateOrderBy {
  avg: GrantUnlockAttachmentsAvgOrderBy
  count: OrderBy
  max: GrantUnlockAttachmentsMaxOrderBy
  min: GrantUnlockAttachmentsMinOrderBy
  stddev: GrantUnlockAttachmentsStddevOrderBy
  stddevPop: GrantUnlockAttachmentsStddevPopOrderBy
  stddevSamp: GrantUnlockAttachmentsStddevSampOrderBy
  sum: GrantUnlockAttachmentsSumOrderBy
  varPop: GrantUnlockAttachmentsVarPopOrderBy
  varSamp: GrantUnlockAttachmentsVarSampOrderBy
  variance: GrantUnlockAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_unlock_attachments"
input GrantUnlockAttachmentsArrRelInsertInput {
  data: [GrantUnlockAttachmentsInsertInput!]!

  # upsert condition
  onConflict: GrantUnlockAttachmentsOnConflict
}

# aggregate avg on columns
type GrantUnlockAttachmentsAvgFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by avg() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# Boolean expression to filter rows from the table "grant_unlock_attachments". All fields are combined with a logical 'AND'.
input GrantUnlockAttachmentsBoolExp {
  _and: [GrantUnlockAttachmentsBoolExp!]
  _not: GrantUnlockAttachmentsBoolExp
  _or: [GrantUnlockAttachmentsBoolExp!]
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  grantUnlock: GrantUnlockBoolExp
  grantUnlockId: BigintComparisonExp
}

# unique or primary key constraints on table "grant_unlock_attachments"
enum GrantUnlockAttachmentsConstraint {
  # unique or primary key constraint on columns "file_upload_id", "grant_unlock_id"
  grant_unlock_attachments_pkey
}

# input type for incrementing numeric columns in table "grant_unlock_attachments"
input GrantUnlockAttachmentsIncInput {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# input type for inserting data into table "grant_unlock_attachments"
input GrantUnlockAttachmentsInsertInput {
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
  grantUnlock: GrantUnlockObjRelInsertInput
  grantUnlockId: bigint
}

# aggregate max on columns
type GrantUnlockAttachmentsMaxFields {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# order by max() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate min on columns
type GrantUnlockAttachmentsMinFields {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# order by min() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# response of any mutation on the table "grant_unlock_attachments"
type GrantUnlockAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantUnlockAttachments!]!
}

# on_conflict condition type for table "grant_unlock_attachments"
input GrantUnlockAttachmentsOnConflict {
  constraint: GrantUnlockAttachmentsConstraint!
  updateColumns: [GrantUnlockAttachmentsUpdateColumn!]! = []
  where: GrantUnlockAttachmentsBoolExp
}

# Ordering options when selecting data from "grant_unlock_attachments".
input GrantUnlockAttachmentsOrderBy {
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
  grantUnlock: GrantUnlockOrderBy
  grantUnlockId: OrderBy
}

# primary key columns input for table: grant_unlock_attachments
input GrantUnlockAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  grantUnlockId: bigint!
}

# select columns of table "grant_unlock_attachments"
enum GrantUnlockAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  grantUnlockId
}

# input type for updating data in table "grant_unlock_attachments"
input GrantUnlockAttachmentsSetInput {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# aggregate stddev on columns
type GrantUnlockAttachmentsStddevFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by stddev() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate stddevPop on columns
type GrantUnlockAttachmentsStddevPopFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by stddevPop() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate stddevSamp on columns
type GrantUnlockAttachmentsStddevSampFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by stddevSamp() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# Streaming cursor of the table "grant_unlock_attachments"
input GrantUnlockAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantUnlockAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantUnlockAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# aggregate sum on columns
type GrantUnlockAttachmentsSumFields {
  fileUploadId: bigint
  grantUnlockId: bigint
}

# order by sum() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# update columns of table "grant_unlock_attachments"
enum GrantUnlockAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  grantUnlockId
}

input GrantUnlockAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantUnlockAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantUnlockAttachmentsSetInput

  # filter the rows which have to be updated
  where: GrantUnlockAttachmentsBoolExp!
}

# aggregate variance on columns
type GrantUnlockAttachmentsVarianceFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by variance() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate varPop on columns
type GrantUnlockAttachmentsVarPopFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by varPop() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate varSamp on columns
type GrantUnlockAttachmentsVarSampFields {
  fileUploadId: Float
  grantUnlockId: Float
}

# order by varSamp() on columns of table "grant_unlock_attachments"
input GrantUnlockAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  grantUnlockId: OrderBy
}

# aggregate avg on columns
type GrantUnlockAvgFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by avg() on columns of table "grant_unlock"
input GrantUnlockAvgOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# Boolean expression to filter rows from the table "grant_unlock". All fields are combined with a logical 'AND'.
input GrantUnlockBoolExp {
  _and: [GrantUnlockBoolExp!]
  _not: GrantUnlockBoolExp
  _or: [GrantUnlockBoolExp!]
  amountAsked: FloatComparisonExp
  amountGiven: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  finance: FinanceBoolExp
  financeId: BigintComparisonExp
  generatedDocument: FileUploadBoolExp
  generatedDocumentId: BigintComparisonExp
  grant: GrantBoolExp
  grantId: BigintComparisonExp
  grantUnlockAttachments: GrantUnlockAttachmentsBoolExp
  grantUnlockAttachmentsAggregate: GrantUnlockAttachmentsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  signature: FileUploadBoolExp
  signatureId: BigintComparisonExp
  state: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  validatedAt: TimestamptzComparisonExp
  validatedBy: IndividualBoolExp
  validatedById: BigintComparisonExp
}

# unique or primary key constraints on table "grant_unlock"
enum GrantUnlockConstraint {
  # unique or primary key constraint on columns "id"
  grant_unlock_pkey
}

# input type for incrementing numeric columns in table "grant_unlock"
input GrantUnlockIncInput {
  amountAsked: Float
  amountGiven: Float
  createdById: bigint
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  id: bigint
  signatureId: bigint
  tenantId: bigint
  validatedById: bigint
}

# input type for inserting data into table "grant_unlock"
input GrantUnlockInsertInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  finance: FinanceObjRelInsertInput
  financeId: bigint
  generatedDocument: FileUploadObjRelInsertInput
  generatedDocumentId: bigint
  grant: GrantObjRelInsertInput
  grantId: bigint
  grantUnlockAttachments: GrantUnlockAttachmentsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  signature: FileUploadObjRelInsertInput
  signatureId: bigint
  state: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  validatedAt: timestamptz
  validatedBy: IndividualObjRelInsertInput
  validatedById: bigint
}

# aggregate max on columns
type GrantUnlockMaxFields {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# order by max() on columns of table "grant_unlock"
input GrantUnlockMaxOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  signatureId: OrderBy
  state: OrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedById: OrderBy
}

# aggregate min on columns
type GrantUnlockMinFields {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# order by min() on columns of table "grant_unlock"
input GrantUnlockMinOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  signatureId: OrderBy
  state: OrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedById: OrderBy
}

# response of any mutation on the table "grant_unlock"
type GrantUnlockMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantUnlock!]!
}

# input type for inserting object relation for remote table "grant_unlock"
input GrantUnlockObjRelInsertInput {
  data: GrantUnlockInsertInput!

  # upsert condition
  onConflict: GrantUnlockOnConflict
}

# on_conflict condition type for table "grant_unlock"
input GrantUnlockOnConflict {
  constraint: GrantUnlockConstraint!
  updateColumns: [GrantUnlockUpdateColumn!]! = []
  where: GrantUnlockBoolExp
}

# Ordering options when selecting data from "grant_unlock".
input GrantUnlockOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  finance: FinanceOrderBy
  financeId: OrderBy
  generatedDocument: FileUploadOrderBy
  generatedDocumentId: OrderBy
  grant: GrantOrderBy
  grantId: OrderBy
  grantUnlockAttachmentsAggregate: GrantUnlockAttachmentsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  signature: FileUploadOrderBy
  signatureId: OrderBy
  state: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  validatedAt: OrderBy
  validatedBy: IndividualOrderBy
  validatedById: OrderBy
}

# primary key columns input for table: grant_unlock
input GrantUnlockPkColumnsInput {
  id: bigint!
}

# select columns of table "grant_unlock"
enum GrantUnlockSelectColumn {
  # column name
  amountAsked

  # column name
  amountGiven

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  financeId

  # column name
  generatedDocumentId

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  signatureId

  # column name
  state

  # column name
  tenantId

  # column name
  validatedAt

  # column name
  validatedById
}

# input type for updating data in table "grant_unlock"
input GrantUnlockSetInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# aggregate stddev on columns
type GrantUnlockStddevFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddev() on columns of table "grant_unlock"
input GrantUnlockStddevOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate stddevPop on columns
type GrantUnlockStddevPopFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddevPop() on columns of table "grant_unlock"
input GrantUnlockStddevPopOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate stddevSamp on columns
type GrantUnlockStddevSampFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by stddevSamp() on columns of table "grant_unlock"
input GrantUnlockStddevSampOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# Streaming cursor of the table "grant_unlock"
input GrantUnlockStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantUnlockStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantUnlockStreamCursorValueInput {
  amountAsked: Float
  amountGiven: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  signatureId: bigint
  state: String
  tenantId: bigint
  validatedAt: timestamptz
  validatedById: bigint
}

# aggregate sum on columns
type GrantUnlockSumFields {
  amountAsked: Float
  amountGiven: Float
  createdById: bigint
  financeId: bigint
  generatedDocumentId: bigint
  grantId: bigint
  id: bigint
  signatureId: bigint
  tenantId: bigint
  validatedById: bigint
}

# order by sum() on columns of table "grant_unlock"
input GrantUnlockSumOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# update columns of table "grant_unlock"
enum GrantUnlockUpdateColumn {
  # column name
  amountAsked

  # column name
  amountGiven

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  financeId

  # column name
  generatedDocumentId

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  signatureId

  # column name
  state

  # column name
  tenantId

  # column name
  validatedAt

  # column name
  validatedById
}

input GrantUnlockUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantUnlockIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantUnlockSetInput

  # filter the rows which have to be updated
  where: GrantUnlockBoolExp!
}

# aggregate variance on columns
type GrantUnlockVarianceFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by variance() on columns of table "grant_unlock"
input GrantUnlockVarianceOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate varPop on columns
type GrantUnlockVarPopFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by varPop() on columns of table "grant_unlock"
input GrantUnlockVarPopOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate varSamp on columns
type GrantUnlockVarSampFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  financeId: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  signatureId: Float
  tenantId: Float
  validatedById: Float
}

# order by varSamp() on columns of table "grant_unlock"
input GrantUnlockVarSampOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  financeId: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# update columns of table "grant"
enum GrantUpdateColumn {
  # column name
  amountAsked

  # column name
  amountGiven

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  hiddenAt

  # column name
  id

  # column name
  signatureId

  # column name
  state

  # column name
  teamId

  # column name
  tenantId

  # column name
  validatedAt

  # column name
  validatedById
}

input GrantUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantSetInput

  # filter the rows which have to be updated
  where: GrantBoolExp!
}

# aggregate variance on columns
type GrantVarianceFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by variance() on columns of table "grant"
input GrantVarianceOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate varPop on columns
type GrantVarPopFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by varPop() on columns of table "grant"
input GrantVarPopOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# aggregate varSamp on columns
type GrantVarSampFields {
  amountAsked: Float
  amountGiven: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  signatureId: Float
  teamId: Float
  tenantId: Float
  validatedById: Float
}

# order by varSamp() on columns of table "grant"
input GrantVarSampOrderBy {
  amountAsked: OrderBy
  amountGiven: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  validatedById: OrderBy
}

# columns and relationships of "individual"
type Individual {
  # An object relationship
  actor: Actor

  # An object relationship
  bot: Bot
  botId: bigint
  contentSignature: String!

  # An array relationship
  contributorIssues(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): [IssueContributors!]!

  # An aggregate relationship
  contributorIssuesAggregate(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): IssueContributorsAggregate!

  # An array relationship
  createdAccountAllocates(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # An aggregate relationship
  createdAccountAllocatesAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!

  # An array relationship
  createdAccounts(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # An aggregate relationship
  createdAccountsAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # An array relationship
  createdActions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  createdActionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  createdActorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  createdActorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  createdActors(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # An aggregate relationship
  createdActorsAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # An array relationship
  createdAddresses(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # An aggregate relationship
  createdAddressesAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!
  createdAt: timestamptz!

  # An array relationship
  createdBankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  createdBankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # An array relationship
  createdBots(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # An aggregate relationship
  createdBotsAggregate(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): BotAggregate!

  # An object relationship
  createdBy: Individual
  createdById: bigint

  # An array relationship
  createdCampusClusters(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # An aggregate relationship
  createdCampusClustersAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # An array relationship
  createdCampuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  createdCampusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # An array relationship
  createdCanteenFoods(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # An aggregate relationship
  createdCanteenFoodsAggregate(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): CanteenFoodAggregate!

  # An array relationship
  createdCanteenMenus(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # An aggregate relationship
  createdCanteenMenusAggregate(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): CanteenMenuAggregate!

  # An array relationship
  createdCanteens(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): [Canteen!]!

  # An aggregate relationship
  createdCanteensAggregate(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): CanteenAggregate!

  # An array relationship
  createdClassGroupTeachers(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # An aggregate relationship
  createdClassGroupTeachersAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!

  # An array relationship
  createdClassGroups(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): [ClassGroup!]!

  # An aggregate relationship
  createdClassGroupsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): ClassGroupAggregate!

  # An array relationship
  createdCohorts(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): [Cohort!]!

  # An aggregate relationship
  createdCohortsAggregate(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): CohortAggregate!

  # An array relationship
  createdContents(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # An aggregate relationship
  createdContentsAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!

  # An array relationship
  createdDocuments(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # An aggregate relationship
  createdDocumentsAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!

  # An array relationship
  createdEventApprovalSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  createdEventApprovalStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # An array relationship
  createdEventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  createdEventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  createdEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  createdEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  createdEventManages(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # An aggregate relationship
  createdEventManagesAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # An array relationship
  createdEvents(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  createdEventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  createdExpenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  createdExpenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  createdExpenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  createdExpensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  createdFavorites(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # An aggregate relationship
  createdFavoritesAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!

  # An array relationship
  createdFileUploads(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # An aggregate relationship
  createdFileUploadsAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # An array relationship
  createdFinances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  createdFinancesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  createdFormSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  createdFormSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  createdForms(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # An aggregate relationship
  createdFormsAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # An array relationship
  createdGrantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  createdGrantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  createdGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  createdGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  createdIndividuals(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): [Individual!]!

  # An aggregate relationship
  createdIndividualsAggregate(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): IndividualAggregate!

  # An array relationship
  createdIssues(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): [Issue!]!

  # An aggregate relationship
  createdIssuesAggregate(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): IssueAggregate!

  # An array relationship
  createdLegalUnits(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # An aggregate relationship
  createdLegalUnitsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # An array relationship
  createdMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  createdMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  createdMissions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  createdMissionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # An array relationship
  createdPoles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  createdPolesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  createdProjects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  createdProjectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  createdReactions(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # An aggregate relationship
  createdReactionsAggregate(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): ReactionAggregate!

  # An array relationship
  createdReports(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # An aggregate relationship
  createdReportsAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # An array relationship
  createdRoles(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # An aggregate relationship
  createdRolesAggregate(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): RoleAggregate!

  # An array relationship
  createdSessions(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # An aggregate relationship
  createdSessionsAggregate(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): SessionAggregate!

  # An array relationship
  createdShortcuts(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # An aggregate relationship
  createdShortcutsAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!

  # An array relationship
  createdSocials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  createdSocialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # An array relationship
  createdSubjects(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): [Subject!]!

  # An aggregate relationship
  createdSubjectsAggregate(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): SubjectAggregate!

  # An array relationship
  createdTags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  createdTagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An array relationship
  createdTeamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  createdTeamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  createdTeamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  createdTeamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  createdTeamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  createdTeamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  createdTeamMetrics(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): [TeamMetric!]!

  # An aggregate relationship
  createdTeamMetricsAggregate(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): TeamMetricAggregate!

  # An array relationship
  createdTeams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  createdTeamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An array relationship
  createdTenantManages(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # An aggregate relationship
  createdTenantManagesAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!

  # An array relationship
  createdTenants(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # An aggregate relationship
  createdTenantsAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # An array relationship
  createdThreads(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): [Thread!]!

  # An aggregate relationship
  createdThreadsAggregate(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): ThreadAggregate!

  # An array relationship
  createdUsers(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # An aggregate relationship
  createdUsersAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # An array relationship
  createdValidations(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # An aggregate relationship
  createdValidationsAggregate(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): ValidationAggregate!

  # An array relationship
  createdVotes(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!

  # An aggregate relationship
  createdVotesAggregate(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): VoteAggregate!
  deletedAt: timestamptz

  # An array relationship
  following(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followingAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  notifieeEventApprovalSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  notifieeEventApprovalStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!
  passwordHash: String

  # An array relationship
  pointsSettledActions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  pointsSettledActionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  pointsSettledMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  pointsSettledMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  presenceSettledEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  presenceSettledEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!
  scopeRole: String!

  # An array relationship
  settledEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  settledEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  settledExpenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  settledExpensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  settledMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  settledMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  settledTeamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  settledTeamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An array relationship
  threadContributors(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): [ThreadContributors!]!

  # An aggregate relationship
  threadContributorsAggregate(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): ThreadContributorsAggregate!

  # An object relationship
  user: User
  userId: bigint

  # An array relationship
  validatedGrantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  validatedGrantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  validatedGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  validatedGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  validatorEventApprovalStep(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  validatorEventApprovalStepAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!
}

# aggregated selection of "individual"
type IndividualAggregate {
  aggregate: IndividualAggregateFields
  nodes: [Individual!]!
}

input IndividualAggregateBoolExp {
  count: individualAggregateBoolExpCount
}

input individualAggregateBoolExpCount {
  arguments: [IndividualSelectColumn!]
  distinct: Boolean
  filter: IndividualBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "individual"
type IndividualAggregateFields {
  avg: IndividualAvgFields
  count(columns: [IndividualSelectColumn!], distinct: Boolean): Int!
  max: IndividualMaxFields
  min: IndividualMinFields
  stddev: IndividualStddevFields
  stddevPop: IndividualStddevPopFields
  stddevSamp: IndividualStddevSampFields
  sum: IndividualSumFields
  varPop: IndividualVarPopFields
  varSamp: IndividualVarSampFields
  variance: IndividualVarianceFields
}

# order by aggregate values of table "individual"
input IndividualAggregateOrderBy {
  avg: IndividualAvgOrderBy
  count: OrderBy
  max: IndividualMaxOrderBy
  min: IndividualMinOrderBy
  stddev: IndividualStddevOrderBy
  stddevPop: IndividualStddevPopOrderBy
  stddevSamp: IndividualStddevSampOrderBy
  sum: IndividualSumOrderBy
  varPop: IndividualVarPopOrderBy
  varSamp: IndividualVarSampOrderBy
  variance: IndividualVarianceOrderBy
}

# input type for inserting array relation for remote table "individual"
input IndividualArrRelInsertInput {
  data: [IndividualInsertInput!]!

  # upsert condition
  onConflict: IndividualOnConflict
}

# aggregate avg on columns
type IndividualAvgFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "individual"
input IndividualAvgOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "individual". All fields are combined with a logical 'AND'.
input IndividualBoolExp {
  _and: [IndividualBoolExp!]
  _not: IndividualBoolExp
  _or: [IndividualBoolExp!]
  actor: ActorBoolExp
  bot: BotBoolExp
  botId: BigintComparisonExp
  contentSignature: StringComparisonExp
  contributorIssues: IssueContributorsBoolExp
  contributorIssuesAggregate: IssueContributorsAggregateBoolExp
  createdAccountAllocates: AccountAllocateBoolExp
  createdAccountAllocatesAggregate: AccountAllocateAggregateBoolExp
  createdAccounts: AccountBoolExp
  createdAccountsAggregate: AccountAggregateBoolExp
  createdActions: ActionBoolExp
  createdActionsAggregate: ActionAggregateBoolExp
  createdActorImages: ActorImageBoolExp
  createdActorImagesAggregate: ActorImageAggregateBoolExp
  createdActors: ActorBoolExp
  createdActorsAggregate: ActorAggregateBoolExp
  createdAddresses: AddressBoolExp
  createdAddressesAggregate: AddressAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBankInfos: BankInfoBoolExp
  createdBankInfosAggregate: BankInfoAggregateBoolExp
  createdBots: BotBoolExp
  createdBotsAggregate: BotAggregateBoolExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  createdCampusClusters: CampusClusterBoolExp
  createdCampusClustersAggregate: CampusClusterAggregateBoolExp
  createdCampuses: CampusBoolExp
  createdCampusesAggregate: CampusAggregateBoolExp
  createdCanteenFoods: CanteenFoodBoolExp
  createdCanteenFoodsAggregate: CanteenFoodAggregateBoolExp
  createdCanteenMenus: CanteenMenuBoolExp
  createdCanteenMenusAggregate: CanteenMenuAggregateBoolExp
  createdCanteens: CanteenBoolExp
  createdCanteensAggregate: CanteenAggregateBoolExp
  createdClassGroupTeachers: ClassGroupTeacherBoolExp
  createdClassGroupTeachersAggregate: ClassGroupTeacherAggregateBoolExp
  createdClassGroups: ClassGroupBoolExp
  createdClassGroupsAggregate: ClassGroupAggregateBoolExp
  createdCohorts: CohortBoolExp
  createdCohortsAggregate: CohortAggregateBoolExp
  createdContents: ContentBoolExp
  createdContentsAggregate: ContentAggregateBoolExp
  createdDocuments: DocumentBoolExp
  createdDocumentsAggregate: DocumentAggregateBoolExp
  createdEventApprovalSteps: EventApprovalStepBoolExp
  createdEventApprovalStepsAggregate: EventApprovalStepAggregateBoolExp
  createdEventApprovals: EventApprovalBoolExp
  createdEventApprovalsAggregate: EventApprovalAggregateBoolExp
  createdEventJoins: EventJoinBoolExp
  createdEventJoinsAggregate: EventJoinAggregateBoolExp
  createdEventManages: EventManageBoolExp
  createdEventManagesAggregate: EventManageAggregateBoolExp
  createdEvents: EventBoolExp
  createdEventsAggregate: EventAggregateBoolExp
  createdExpenseItems: ExpenseItemBoolExp
  createdExpenseItemsAggregate: ExpenseItemAggregateBoolExp
  createdExpenses: ExpenseBoolExp
  createdExpensesAggregate: ExpenseAggregateBoolExp
  createdFavorites: FavoriteBoolExp
  createdFavoritesAggregate: FavoriteAggregateBoolExp
  createdFileUploads: FileUploadBoolExp
  createdFileUploadsAggregate: FileUploadAggregateBoolExp
  createdFinances: FinanceBoolExp
  createdFinancesAggregate: FinanceAggregateBoolExp
  createdFormSubmissions: FormSubmissionBoolExp
  createdFormSubmissionsAggregate: FormSubmissionAggregateBoolExp
  createdForms: FormBoolExp
  createdFormsAggregate: FormAggregateBoolExp
  createdGrantUnlocks: GrantUnlockBoolExp
  createdGrantUnlocksAggregate: GrantUnlockAggregateBoolExp
  createdGrants: GrantBoolExp
  createdGrantsAggregate: GrantAggregateBoolExp
  createdIndividuals: IndividualBoolExp
  createdIndividualsAggregate: IndividualAggregateBoolExp
  createdIssues: IssueBoolExp
  createdIssuesAggregate: IssueAggregateBoolExp
  createdLegalUnits: LegalUnitBoolExp
  createdLegalUnitsAggregate: LegalUnitAggregateBoolExp
  createdMissionJoins: MissionJoinBoolExp
  createdMissionJoinsAggregate: MissionJoinAggregateBoolExp
  createdMissions: MissionBoolExp
  createdMissionsAggregate: MissionAggregateBoolExp
  createdPoles: PoleBoolExp
  createdPolesAggregate: PoleAggregateBoolExp
  createdProjects: ProjectBoolExp
  createdProjectsAggregate: ProjectAggregateBoolExp
  createdReactions: ReactionBoolExp
  createdReactionsAggregate: ReactionAggregateBoolExp
  createdReports: ReportBoolExp
  createdReportsAggregate: ReportAggregateBoolExp
  createdRoles: RoleBoolExp
  createdRolesAggregate: RoleAggregateBoolExp
  createdSessions: SessionBoolExp
  createdSessionsAggregate: SessionAggregateBoolExp
  createdShortcuts: ShortcutBoolExp
  createdShortcutsAggregate: ShortcutAggregateBoolExp
  createdSocials: SocialBoolExp
  createdSocialsAggregate: SocialAggregateBoolExp
  createdSubjects: SubjectBoolExp
  createdSubjectsAggregate: SubjectAggregateBoolExp
  createdTags: TagBoolExp
  createdTagsAggregate: TagAggregateBoolExp
  createdTeamHistories: TeamHistoryBoolExp
  createdTeamHistoriesAggregate: TeamHistoryAggregateBoolExp
  createdTeamJoins: TeamJoinBoolExp
  createdTeamJoinsAggregate: TeamJoinAggregateBoolExp
  createdTeamMembers: TeamMemberBoolExp
  createdTeamMembersAggregate: TeamMemberAggregateBoolExp
  createdTeamMetrics: TeamMetricBoolExp
  createdTeamMetricsAggregate: TeamMetricAggregateBoolExp
  createdTeams: TeamBoolExp
  createdTeamsAggregate: TeamAggregateBoolExp
  createdTenantManages: TenantManageBoolExp
  createdTenantManagesAggregate: TenantManageAggregateBoolExp
  createdTenants: TenantBoolExp
  createdTenantsAggregate: TenantAggregateBoolExp
  createdThreads: ThreadBoolExp
  createdThreadsAggregate: ThreadAggregateBoolExp
  createdUsers: UserBoolExp
  createdUsersAggregate: UserAggregateBoolExp
  createdValidations: ValidationBoolExp
  createdValidationsAggregate: ValidationAggregateBoolExp
  createdVotes: VoteBoolExp
  createdVotesAggregate: VoteAggregateBoolExp
  deletedAt: TimestamptzComparisonExp
  following: FollowBoolExp
  followingAggregate: FollowAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  notifieeEventApprovalSteps: EventApprovalStepNotifieesBoolExp
  notifieeEventApprovalStepsAggregate: EventApprovalStepNotifieesAggregateBoolExp
  passwordHash: StringComparisonExp
  pointsSettledActions: ActionBoolExp
  pointsSettledActionsAggregate: ActionAggregateBoolExp
  pointsSettledMissionJoins: MissionJoinBoolExp
  pointsSettledMissionJoinsAggregate: MissionJoinAggregateBoolExp
  presenceSettledEventJoins: EventJoinBoolExp
  presenceSettledEventJoinsAggregate: EventJoinAggregateBoolExp
  scopeRole: StringComparisonExp
  settledEventJoins: EventJoinBoolExp
  settledEventJoinsAggregate: EventJoinAggregateBoolExp
  settledExpenses: ExpenseBoolExp
  settledExpensesAggregate: ExpenseAggregateBoolExp
  settledMissionJoins: MissionJoinBoolExp
  settledMissionJoinsAggregate: MissionJoinAggregateBoolExp
  settledTeamJoins: TeamJoinBoolExp
  settledTeamJoinsAggregate: TeamJoinAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  threadContributors: ThreadContributorsBoolExp
  threadContributorsAggregate: ThreadContributorsAggregateBoolExp
  user: UserBoolExp
  userId: BigintComparisonExp
  validatedGrantUnlocks: GrantUnlockBoolExp
  validatedGrantUnlocksAggregate: GrantUnlockAggregateBoolExp
  validatedGrants: GrantBoolExp
  validatedGrantsAggregate: GrantAggregateBoolExp
  validatorEventApprovalStep: EventApprovalStepValidatorsBoolExp
  validatorEventApprovalStepAggregate: EventApprovalStepValidatorsAggregateBoolExp
}

# unique or primary key constraints on table "individual"
enum IndividualConstraint {
  # unique or primary key constraint on columns "bot_id"
  individual_bot_id_unique

  # unique or primary key constraint on columns "id"
  individual_pkey

  # unique or primary key constraint on columns "user_id"
  individual_user_id_unique
}

# input type for incrementing numeric columns in table "individual"
input IndividualIncInput {
  botId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "individual"
input IndividualInsertInput {
  actor: ActorObjRelInsertInput
  bot: BotObjRelInsertInput
  botId: bigint
  contentSignature: String
  contributorIssues: IssueContributorsArrRelInsertInput
  createdAccountAllocates: AccountAllocateArrRelInsertInput
  createdAccounts: AccountArrRelInsertInput
  createdActions: ActionArrRelInsertInput
  createdActorImages: ActorImageArrRelInsertInput
  createdActors: ActorArrRelInsertInput
  createdAddresses: AddressArrRelInsertInput
  createdAt: timestamptz
  createdBankInfos: BankInfoArrRelInsertInput
  createdBots: BotArrRelInsertInput
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  createdCampusClusters: CampusClusterArrRelInsertInput
  createdCampuses: CampusArrRelInsertInput
  createdCanteenFoods: CanteenFoodArrRelInsertInput
  createdCanteenMenus: CanteenMenuArrRelInsertInput
  createdCanteens: CanteenArrRelInsertInput
  createdClassGroupTeachers: ClassGroupTeacherArrRelInsertInput
  createdClassGroups: ClassGroupArrRelInsertInput
  createdCohorts: CohortArrRelInsertInput
  createdContents: ContentArrRelInsertInput
  createdDocuments: DocumentArrRelInsertInput
  createdEventApprovalSteps: EventApprovalStepArrRelInsertInput
  createdEventApprovals: EventApprovalArrRelInsertInput
  createdEventJoins: EventJoinArrRelInsertInput
  createdEventManages: EventManageArrRelInsertInput
  createdEvents: EventArrRelInsertInput
  createdExpenseItems: ExpenseItemArrRelInsertInput
  createdExpenses: ExpenseArrRelInsertInput
  createdFavorites: FavoriteArrRelInsertInput
  createdFileUploads: FileUploadArrRelInsertInput
  createdFinances: FinanceArrRelInsertInput
  createdFormSubmissions: FormSubmissionArrRelInsertInput
  createdForms: FormArrRelInsertInput
  createdGrantUnlocks: GrantUnlockArrRelInsertInput
  createdGrants: GrantArrRelInsertInput
  createdIndividuals: IndividualArrRelInsertInput
  createdIssues: IssueArrRelInsertInput
  createdLegalUnits: LegalUnitArrRelInsertInput
  createdMissionJoins: MissionJoinArrRelInsertInput
  createdMissions: MissionArrRelInsertInput
  createdPoles: PoleArrRelInsertInput
  createdProjects: ProjectArrRelInsertInput
  createdReactions: ReactionArrRelInsertInput
  createdReports: ReportArrRelInsertInput
  createdRoles: RoleArrRelInsertInput
  createdSessions: SessionArrRelInsertInput
  createdShortcuts: ShortcutArrRelInsertInput
  createdSocials: SocialArrRelInsertInput
  createdSubjects: SubjectArrRelInsertInput
  createdTags: TagArrRelInsertInput
  createdTeamHistories: TeamHistoryArrRelInsertInput
  createdTeamJoins: TeamJoinArrRelInsertInput
  createdTeamMembers: TeamMemberArrRelInsertInput
  createdTeamMetrics: TeamMetricArrRelInsertInput
  createdTeams: TeamArrRelInsertInput
  createdTenantManages: TenantManageArrRelInsertInput
  createdTenants: TenantArrRelInsertInput
  createdThreads: ThreadArrRelInsertInput
  createdUsers: UserArrRelInsertInput
  createdValidations: ValidationArrRelInsertInput
  createdVotes: VoteArrRelInsertInput
  deletedAt: timestamptz
  following: FollowArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  notifieeEventApprovalSteps: EventApprovalStepNotifieesArrRelInsertInput
  passwordHash: String
  pointsSettledActions: ActionArrRelInsertInput
  pointsSettledMissionJoins: MissionJoinArrRelInsertInput
  presenceSettledEventJoins: EventJoinArrRelInsertInput
  scopeRole: String
  settledEventJoins: EventJoinArrRelInsertInput
  settledExpenses: ExpenseArrRelInsertInput
  settledMissionJoins: MissionJoinArrRelInsertInput
  settledTeamJoins: TeamJoinArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  threadContributors: ThreadContributorsArrRelInsertInput
  user: UserObjRelInsertInput
  userId: bigint
  validatedGrantUnlocks: GrantUnlockArrRelInsertInput
  validatedGrants: GrantArrRelInsertInput
  validatorEventApprovalStep: EventApprovalStepValidatorsArrRelInsertInput
}

# aggregate max on columns
type IndividualMaxFields {
  botId: bigint
  contentSignature: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  passwordHash: String
  scopeRole: String
  tenantId: bigint
  userId: bigint
}

# order by max() on columns of table "individual"
input IndividualMaxOrderBy {
  botId: OrderBy
  contentSignature: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  passwordHash: OrderBy
  scopeRole: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type IndividualMinFields {
  botId: bigint
  contentSignature: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  passwordHash: String
  scopeRole: String
  tenantId: bigint
  userId: bigint
}

# order by min() on columns of table "individual"
input IndividualMinOrderBy {
  botId: OrderBy
  contentSignature: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  passwordHash: OrderBy
  scopeRole: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "individual"
type IndividualMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Individual!]!
}

# input type for inserting object relation for remote table "individual"
input IndividualObjRelInsertInput {
  data: IndividualInsertInput!

  # upsert condition
  onConflict: IndividualOnConflict
}

# on_conflict condition type for table "individual"
input IndividualOnConflict {
  constraint: IndividualConstraint!
  updateColumns: [IndividualUpdateColumn!]! = []
  where: IndividualBoolExp
}

# Ordering options when selecting data from "individual".
input IndividualOrderBy {
  actor: ActorOrderBy
  bot: BotOrderBy
  botId: OrderBy
  contentSignature: OrderBy
  contributorIssuesAggregate: IssueContributorsAggregateOrderBy
  createdAccountAllocatesAggregate: AccountAllocateAggregateOrderBy
  createdAccountsAggregate: AccountAggregateOrderBy
  createdActionsAggregate: ActionAggregateOrderBy
  createdActorImagesAggregate: ActorImageAggregateOrderBy
  createdActorsAggregate: ActorAggregateOrderBy
  createdAddressesAggregate: AddressAggregateOrderBy
  createdAt: OrderBy
  createdBankInfosAggregate: BankInfoAggregateOrderBy
  createdBotsAggregate: BotAggregateOrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  createdCampusClustersAggregate: CampusClusterAggregateOrderBy
  createdCampusesAggregate: CampusAggregateOrderBy
  createdCanteenFoodsAggregate: CanteenFoodAggregateOrderBy
  createdCanteenMenusAggregate: CanteenMenuAggregateOrderBy
  createdCanteensAggregate: CanteenAggregateOrderBy
  createdClassGroupTeachersAggregate: ClassGroupTeacherAggregateOrderBy
  createdClassGroupsAggregate: ClassGroupAggregateOrderBy
  createdCohortsAggregate: CohortAggregateOrderBy
  createdContentsAggregate: ContentAggregateOrderBy
  createdDocumentsAggregate: DocumentAggregateOrderBy
  createdEventApprovalStepsAggregate: EventApprovalStepAggregateOrderBy
  createdEventApprovalsAggregate: EventApprovalAggregateOrderBy
  createdEventJoinsAggregate: EventJoinAggregateOrderBy
  createdEventManagesAggregate: EventManageAggregateOrderBy
  createdEventsAggregate: EventAggregateOrderBy
  createdExpenseItemsAggregate: ExpenseItemAggregateOrderBy
  createdExpensesAggregate: ExpenseAggregateOrderBy
  createdFavoritesAggregate: FavoriteAggregateOrderBy
  createdFileUploadsAggregate: FileUploadAggregateOrderBy
  createdFinancesAggregate: FinanceAggregateOrderBy
  createdFormSubmissionsAggregate: FormSubmissionAggregateOrderBy
  createdFormsAggregate: FormAggregateOrderBy
  createdGrantUnlocksAggregate: GrantUnlockAggregateOrderBy
  createdGrantsAggregate: GrantAggregateOrderBy
  createdIndividualsAggregate: IndividualAggregateOrderBy
  createdIssuesAggregate: IssueAggregateOrderBy
  createdLegalUnitsAggregate: LegalUnitAggregateOrderBy
  createdMissionJoinsAggregate: MissionJoinAggregateOrderBy
  createdMissionsAggregate: MissionAggregateOrderBy
  createdPolesAggregate: PoleAggregateOrderBy
  createdProjectsAggregate: ProjectAggregateOrderBy
  createdReactionsAggregate: ReactionAggregateOrderBy
  createdReportsAggregate: ReportAggregateOrderBy
  createdRolesAggregate: RoleAggregateOrderBy
  createdSessionsAggregate: SessionAggregateOrderBy
  createdShortcutsAggregate: ShortcutAggregateOrderBy
  createdSocialsAggregate: SocialAggregateOrderBy
  createdSubjectsAggregate: SubjectAggregateOrderBy
  createdTagsAggregate: TagAggregateOrderBy
  createdTeamHistoriesAggregate: TeamHistoryAggregateOrderBy
  createdTeamJoinsAggregate: TeamJoinAggregateOrderBy
  createdTeamMembersAggregate: TeamMemberAggregateOrderBy
  createdTeamMetricsAggregate: TeamMetricAggregateOrderBy
  createdTeamsAggregate: TeamAggregateOrderBy
  createdTenantManagesAggregate: TenantManageAggregateOrderBy
  createdTenantsAggregate: TenantAggregateOrderBy
  createdThreadsAggregate: ThreadAggregateOrderBy
  createdUsersAggregate: UserAggregateOrderBy
  createdValidationsAggregate: ValidationAggregateOrderBy
  createdVotesAggregate: VoteAggregateOrderBy
  deletedAt: OrderBy
  followingAggregate: FollowAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  notifieeEventApprovalStepsAggregate: EventApprovalStepNotifieesAggregateOrderBy
  passwordHash: OrderBy
  pointsSettledActionsAggregate: ActionAggregateOrderBy
  pointsSettledMissionJoinsAggregate: MissionJoinAggregateOrderBy
  presenceSettledEventJoinsAggregate: EventJoinAggregateOrderBy
  scopeRole: OrderBy
  settledEventJoinsAggregate: EventJoinAggregateOrderBy
  settledExpensesAggregate: ExpenseAggregateOrderBy
  settledMissionJoinsAggregate: MissionJoinAggregateOrderBy
  settledTeamJoinsAggregate: TeamJoinAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  threadContributorsAggregate: ThreadContributorsAggregateOrderBy
  user: UserOrderBy
  userId: OrderBy
  validatedGrantUnlocksAggregate: GrantUnlockAggregateOrderBy
  validatedGrantsAggregate: GrantAggregateOrderBy
  validatorEventApprovalStepAggregate: EventApprovalStepValidatorsAggregateOrderBy
}

# primary key columns input for table: individual
input IndividualPkColumnsInput {
  id: bigint!
}

# select columns of table "individual"
enum IndividualSelectColumn {
  # column name
  botId

  # column name
  contentSignature

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  passwordHash

  # column name
  scopeRole

  # column name
  tenantId

  # column name
  userId
}

# input type for updating data in table "individual"
input IndividualSetInput {
  botId: bigint
  contentSignature: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  passwordHash: String
  scopeRole: String
  tenantId: bigint
  userId: bigint
}

# aggregate stddev on columns
type IndividualStddevFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "individual"
input IndividualStddevOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type IndividualStddevPopFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "individual"
input IndividualStddevPopOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type IndividualStddevSampFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "individual"
input IndividualStddevSampOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "individual"
input IndividualStreamCursorInput {
  # Stream column input with initial value
  initialValue: IndividualStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input IndividualStreamCursorValueInput {
  botId: bigint
  contentSignature: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  passwordHash: String
  scopeRole: String
  tenantId: bigint
  userId: bigint
}

# aggregate sum on columns
type IndividualSumFields {
  botId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "individual"
input IndividualSumOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "individual"
enum IndividualUpdateColumn {
  # column name
  botId

  # column name
  contentSignature

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  passwordHash

  # column name
  scopeRole

  # column name
  tenantId

  # column name
  userId
}

input IndividualUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: IndividualIncInput

  # sets the columns of the filtered rows to the given values
  _set: IndividualSetInput

  # filter the rows which have to be updated
  where: IndividualBoolExp!
}

# aggregate variance on columns
type IndividualVarianceFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "individual"
input IndividualVarianceOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type IndividualVarPopFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "individual"
input IndividualVarPopOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type IndividualVarSampFields {
  botId: Float
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "individual"
input IndividualVarSampOrderBy {
  botId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "issue"
type Issue {
  # An object relationship
  content: Content!
  contentId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  issueContributors(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): [IssueContributors!]!

  # An aggregate relationship
  issueContributorsAggregate(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): IssueContributorsAggregate!

  # An array relationship
  issueTags(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): [IssueTags!]!

  # An aggregate relationship
  issueTagsAggregate(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): IssueTagsAggregate!
  name: String!
  slug: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "issue"
type IssueAggregate {
  aggregate: IssueAggregateFields
  nodes: [Issue!]!
}

input IssueAggregateBoolExp {
  count: issueAggregateBoolExpCount
}

input issueAggregateBoolExpCount {
  arguments: [IssueSelectColumn!]
  distinct: Boolean
  filter: IssueBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "issue"
type IssueAggregateFields {
  avg: IssueAvgFields
  count(columns: [IssueSelectColumn!], distinct: Boolean): Int!
  max: IssueMaxFields
  min: IssueMinFields
  stddev: IssueStddevFields
  stddevPop: IssueStddevPopFields
  stddevSamp: IssueStddevSampFields
  sum: IssueSumFields
  varPop: IssueVarPopFields
  varSamp: IssueVarSampFields
  variance: IssueVarianceFields
}

# order by aggregate values of table "issue"
input IssueAggregateOrderBy {
  avg: IssueAvgOrderBy
  count: OrderBy
  max: IssueMaxOrderBy
  min: IssueMinOrderBy
  stddev: IssueStddevOrderBy
  stddevPop: IssueStddevPopOrderBy
  stddevSamp: IssueStddevSampOrderBy
  sum: IssueSumOrderBy
  varPop: IssueVarPopOrderBy
  varSamp: IssueVarSampOrderBy
  variance: IssueVarianceOrderBy
}

# input type for inserting array relation for remote table "issue"
input IssueArrRelInsertInput {
  data: [IssueInsertInput!]!

  # upsert condition
  onConflict: IssueOnConflict
}

# aggregate avg on columns
type IssueAvgFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "issue"
input IssueAvgOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "issue". All fields are combined with a logical 'AND'.
input IssueBoolExp {
  _and: [IssueBoolExp!]
  _not: IssueBoolExp
  _or: [IssueBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  issueContributors: IssueContributorsBoolExp
  issueContributorsAggregate: IssueContributorsAggregateBoolExp
  issueTags: IssueTagsBoolExp
  issueTagsAggregate: IssueTagsAggregateBoolExp
  name: StringComparisonExp
  slug: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "issue"
enum IssueConstraint {
  # unique or primary key constraint on columns "content_id"
  issue_content_id_unique

  # unique or primary key constraint on columns "id"
  issue_pkey
}

# columns and relationships of "issue_contributors"
type IssueContributors {
  # An object relationship
  individual: Individual!
  individualId: bigint!

  # An object relationship
  issue: Issue!
  issueId: bigint!
}

# aggregated selection of "issue_contributors"
type IssueContributorsAggregate {
  aggregate: IssueContributorsAggregateFields
  nodes: [IssueContributors!]!
}

input IssueContributorsAggregateBoolExp {
  count: issueContributorsAggregateBoolExpCount
}

input issueContributorsAggregateBoolExpCount {
  arguments: [IssueContributorsSelectColumn!]
  distinct: Boolean
  filter: IssueContributorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "issue_contributors"
type IssueContributorsAggregateFields {
  avg: IssueContributorsAvgFields
  count(columns: [IssueContributorsSelectColumn!], distinct: Boolean): Int!
  max: IssueContributorsMaxFields
  min: IssueContributorsMinFields
  stddev: IssueContributorsStddevFields
  stddevPop: IssueContributorsStddevPopFields
  stddevSamp: IssueContributorsStddevSampFields
  sum: IssueContributorsSumFields
  varPop: IssueContributorsVarPopFields
  varSamp: IssueContributorsVarSampFields
  variance: IssueContributorsVarianceFields
}

# order by aggregate values of table "issue_contributors"
input IssueContributorsAggregateOrderBy {
  avg: IssueContributorsAvgOrderBy
  count: OrderBy
  max: IssueContributorsMaxOrderBy
  min: IssueContributorsMinOrderBy
  stddev: IssueContributorsStddevOrderBy
  stddevPop: IssueContributorsStddevPopOrderBy
  stddevSamp: IssueContributorsStddevSampOrderBy
  sum: IssueContributorsSumOrderBy
  varPop: IssueContributorsVarPopOrderBy
  varSamp: IssueContributorsVarSampOrderBy
  variance: IssueContributorsVarianceOrderBy
}

# input type for inserting array relation for remote table "issue_contributors"
input IssueContributorsArrRelInsertInput {
  data: [IssueContributorsInsertInput!]!

  # upsert condition
  onConflict: IssueContributorsOnConflict
}

# aggregate avg on columns
type IssueContributorsAvgFields {
  individualId: Float
  issueId: Float
}

# order by avg() on columns of table "issue_contributors"
input IssueContributorsAvgOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# Boolean expression to filter rows from the table "issue_contributors". All fields are combined with a logical 'AND'.
input IssueContributorsBoolExp {
  _and: [IssueContributorsBoolExp!]
  _not: IssueContributorsBoolExp
  _or: [IssueContributorsBoolExp!]
  individual: IndividualBoolExp
  individualId: BigintComparisonExp
  issue: IssueBoolExp
  issueId: BigintComparisonExp
}

# unique or primary key constraints on table "issue_contributors"
enum IssueContributorsConstraint {
  # unique or primary key constraint on columns "issue_id", "individual_id"
  issue_contributors_pkey
}

# input type for incrementing numeric columns in table "issue_contributors"
input IssueContributorsIncInput {
  individualId: bigint
  issueId: bigint
}

# input type for inserting data into table "issue_contributors"
input IssueContributorsInsertInput {
  individual: IndividualObjRelInsertInput
  individualId: bigint
  issue: IssueObjRelInsertInput
  issueId: bigint
}

# aggregate max on columns
type IssueContributorsMaxFields {
  individualId: bigint
  issueId: bigint
}

# order by max() on columns of table "issue_contributors"
input IssueContributorsMaxOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# aggregate min on columns
type IssueContributorsMinFields {
  individualId: bigint
  issueId: bigint
}

# order by min() on columns of table "issue_contributors"
input IssueContributorsMinOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# response of any mutation on the table "issue_contributors"
type IssueContributorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [IssueContributors!]!
}

# on_conflict condition type for table "issue_contributors"
input IssueContributorsOnConflict {
  constraint: IssueContributorsConstraint!
  updateColumns: [IssueContributorsUpdateColumn!]! = []
  where: IssueContributorsBoolExp
}

# Ordering options when selecting data from "issue_contributors".
input IssueContributorsOrderBy {
  individual: IndividualOrderBy
  individualId: OrderBy
  issue: IssueOrderBy
  issueId: OrderBy
}

# primary key columns input for table: issue_contributors
input IssueContributorsPkColumnsInput {
  individualId: bigint!
  issueId: bigint!
}

# select columns of table "issue_contributors"
enum IssueContributorsSelectColumn {
  # column name
  individualId

  # column name
  issueId
}

# input type for updating data in table "issue_contributors"
input IssueContributorsSetInput {
  individualId: bigint
  issueId: bigint
}

# aggregate stddev on columns
type IssueContributorsStddevFields {
  individualId: Float
  issueId: Float
}

# order by stddev() on columns of table "issue_contributors"
input IssueContributorsStddevOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# aggregate stddevPop on columns
type IssueContributorsStddevPopFields {
  individualId: Float
  issueId: Float
}

# order by stddevPop() on columns of table "issue_contributors"
input IssueContributorsStddevPopOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# aggregate stddevSamp on columns
type IssueContributorsStddevSampFields {
  individualId: Float
  issueId: Float
}

# order by stddevSamp() on columns of table "issue_contributors"
input IssueContributorsStddevSampOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# Streaming cursor of the table "issue_contributors"
input IssueContributorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: IssueContributorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input IssueContributorsStreamCursorValueInput {
  individualId: bigint
  issueId: bigint
}

# aggregate sum on columns
type IssueContributorsSumFields {
  individualId: bigint
  issueId: bigint
}

# order by sum() on columns of table "issue_contributors"
input IssueContributorsSumOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# update columns of table "issue_contributors"
enum IssueContributorsUpdateColumn {
  # column name
  individualId

  # column name
  issueId
}

input IssueContributorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: IssueContributorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: IssueContributorsSetInput

  # filter the rows which have to be updated
  where: IssueContributorsBoolExp!
}

# aggregate variance on columns
type IssueContributorsVarianceFields {
  individualId: Float
  issueId: Float
}

# order by variance() on columns of table "issue_contributors"
input IssueContributorsVarianceOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# aggregate varPop on columns
type IssueContributorsVarPopFields {
  individualId: Float
  issueId: Float
}

# order by varPop() on columns of table "issue_contributors"
input IssueContributorsVarPopOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# aggregate varSamp on columns
type IssueContributorsVarSampFields {
  individualId: Float
  issueId: Float
}

# order by varSamp() on columns of table "issue_contributors"
input IssueContributorsVarSampOrderBy {
  individualId: OrderBy
  issueId: OrderBy
}

# input type for incrementing numeric columns in table "issue"
input IssueIncInput {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "issue"
input IssueInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  issueContributors: IssueContributorsArrRelInsertInput
  issueTags: IssueTagsArrRelInsertInput
  name: String
  slug: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type IssueMaxFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# order by max() on columns of table "issue"
input IssueMaxOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type IssueMinFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# order by min() on columns of table "issue"
input IssueMinOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "issue"
type IssueMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Issue!]!
}

# input type for inserting object relation for remote table "issue"
input IssueObjRelInsertInput {
  data: IssueInsertInput!

  # upsert condition
  onConflict: IssueOnConflict
}

# on_conflict condition type for table "issue"
input IssueOnConflict {
  constraint: IssueConstraint!
  updateColumns: [IssueUpdateColumn!]! = []
  where: IssueBoolExp
}

# Ordering options when selecting data from "issue".
input IssueOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  issueContributorsAggregate: IssueContributorsAggregateOrderBy
  issueTagsAggregate: IssueTagsAggregateOrderBy
  name: OrderBy
  slug: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: issue
input IssuePkColumnsInput {
  id: bigint!
}

# select columns of table "issue"
enum IssueSelectColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  slug

  # column name
  tenantId
}

# input type for updating data in table "issue"
input IssueSetInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# aggregate stddev on columns
type IssueStddevFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "issue"
input IssueStddevOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type IssueStddevPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "issue"
input IssueStddevPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type IssueStddevSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "issue"
input IssueStddevSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "issue"
input IssueStreamCursorInput {
  # Stream column input with initial value
  initialValue: IssueStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input IssueStreamCursorValueInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# aggregate sum on columns
type IssueSumFields {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "issue"
input IssueSumOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "issue_tags"
type IssueTags {
  # An object relationship
  issue: Issue!
  issueId: bigint!

  # An object relationship
  tag: Tag!
  tagId: bigint!
}

# aggregated selection of "issue_tags"
type IssueTagsAggregate {
  aggregate: IssueTagsAggregateFields
  nodes: [IssueTags!]!
}

input IssueTagsAggregateBoolExp {
  count: issueTagsAggregateBoolExpCount
}

input issueTagsAggregateBoolExpCount {
  arguments: [IssueTagsSelectColumn!]
  distinct: Boolean
  filter: IssueTagsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "issue_tags"
type IssueTagsAggregateFields {
  avg: IssueTagsAvgFields
  count(columns: [IssueTagsSelectColumn!], distinct: Boolean): Int!
  max: IssueTagsMaxFields
  min: IssueTagsMinFields
  stddev: IssueTagsStddevFields
  stddevPop: IssueTagsStddevPopFields
  stddevSamp: IssueTagsStddevSampFields
  sum: IssueTagsSumFields
  varPop: IssueTagsVarPopFields
  varSamp: IssueTagsVarSampFields
  variance: IssueTagsVarianceFields
}

# order by aggregate values of table "issue_tags"
input IssueTagsAggregateOrderBy {
  avg: IssueTagsAvgOrderBy
  count: OrderBy
  max: IssueTagsMaxOrderBy
  min: IssueTagsMinOrderBy
  stddev: IssueTagsStddevOrderBy
  stddevPop: IssueTagsStddevPopOrderBy
  stddevSamp: IssueTagsStddevSampOrderBy
  sum: IssueTagsSumOrderBy
  varPop: IssueTagsVarPopOrderBy
  varSamp: IssueTagsVarSampOrderBy
  variance: IssueTagsVarianceOrderBy
}

# input type for inserting array relation for remote table "issue_tags"
input IssueTagsArrRelInsertInput {
  data: [IssueTagsInsertInput!]!

  # upsert condition
  onConflict: IssueTagsOnConflict
}

# aggregate avg on columns
type IssueTagsAvgFields {
  issueId: Float
  tagId: Float
}

# order by avg() on columns of table "issue_tags"
input IssueTagsAvgOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# Boolean expression to filter rows from the table "issue_tags". All fields are combined with a logical 'AND'.
input IssueTagsBoolExp {
  _and: [IssueTagsBoolExp!]
  _not: IssueTagsBoolExp
  _or: [IssueTagsBoolExp!]
  issue: IssueBoolExp
  issueId: BigintComparisonExp
  tag: TagBoolExp
  tagId: BigintComparisonExp
}

# unique or primary key constraints on table "issue_tags"
enum IssueTagsConstraint {
  # unique or primary key constraint on columns "issue_id", "tag_id"
  issue_tags_pkey
}

# input type for incrementing numeric columns in table "issue_tags"
input IssueTagsIncInput {
  issueId: bigint
  tagId: bigint
}

# input type for inserting data into table "issue_tags"
input IssueTagsInsertInput {
  issue: IssueObjRelInsertInput
  issueId: bigint
  tag: TagObjRelInsertInput
  tagId: bigint
}

# aggregate max on columns
type IssueTagsMaxFields {
  issueId: bigint
  tagId: bigint
}

# order by max() on columns of table "issue_tags"
input IssueTagsMaxOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# aggregate min on columns
type IssueTagsMinFields {
  issueId: bigint
  tagId: bigint
}

# order by min() on columns of table "issue_tags"
input IssueTagsMinOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# response of any mutation on the table "issue_tags"
type IssueTagsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [IssueTags!]!
}

# on_conflict condition type for table "issue_tags"
input IssueTagsOnConflict {
  constraint: IssueTagsConstraint!
  updateColumns: [IssueTagsUpdateColumn!]! = []
  where: IssueTagsBoolExp
}

# Ordering options when selecting data from "issue_tags".
input IssueTagsOrderBy {
  issue: IssueOrderBy
  issueId: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
}

# primary key columns input for table: issue_tags
input IssueTagsPkColumnsInput {
  issueId: bigint!
  tagId: bigint!
}

# select columns of table "issue_tags"
enum IssueTagsSelectColumn {
  # column name
  issueId

  # column name
  tagId
}

# input type for updating data in table "issue_tags"
input IssueTagsSetInput {
  issueId: bigint
  tagId: bigint
}

# aggregate stddev on columns
type IssueTagsStddevFields {
  issueId: Float
  tagId: Float
}

# order by stddev() on columns of table "issue_tags"
input IssueTagsStddevOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# aggregate stddevPop on columns
type IssueTagsStddevPopFields {
  issueId: Float
  tagId: Float
}

# order by stddevPop() on columns of table "issue_tags"
input IssueTagsStddevPopOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# aggregate stddevSamp on columns
type IssueTagsStddevSampFields {
  issueId: Float
  tagId: Float
}

# order by stddevSamp() on columns of table "issue_tags"
input IssueTagsStddevSampOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# Streaming cursor of the table "issue_tags"
input IssueTagsStreamCursorInput {
  # Stream column input with initial value
  initialValue: IssueTagsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input IssueTagsStreamCursorValueInput {
  issueId: bigint
  tagId: bigint
}

# aggregate sum on columns
type IssueTagsSumFields {
  issueId: bigint
  tagId: bigint
}

# order by sum() on columns of table "issue_tags"
input IssueTagsSumOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# update columns of table "issue_tags"
enum IssueTagsUpdateColumn {
  # column name
  issueId

  # column name
  tagId
}

input IssueTagsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: IssueTagsIncInput

  # sets the columns of the filtered rows to the given values
  _set: IssueTagsSetInput

  # filter the rows which have to be updated
  where: IssueTagsBoolExp!
}

# aggregate variance on columns
type IssueTagsVarianceFields {
  issueId: Float
  tagId: Float
}

# order by variance() on columns of table "issue_tags"
input IssueTagsVarianceOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# aggregate varPop on columns
type IssueTagsVarPopFields {
  issueId: Float
  tagId: Float
}

# order by varPop() on columns of table "issue_tags"
input IssueTagsVarPopOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# aggregate varSamp on columns
type IssueTagsVarSampFields {
  issueId: Float
  tagId: Float
}

# order by varSamp() on columns of table "issue_tags"
input IssueTagsVarSampOrderBy {
  issueId: OrderBy
  tagId: OrderBy
}

# update columns of table "issue"
enum IssueUpdateColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  slug

  # column name
  tenantId
}

input IssueUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: IssueIncInput

  # sets the columns of the filtered rows to the given values
  _set: IssueSetInput

  # filter the rows which have to be updated
  where: IssueBoolExp!
}

# aggregate variance on columns
type IssueVarianceFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "issue"
input IssueVarianceOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type IssueVarPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "issue"
input IssueVarPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type IssueVarSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "issue"
input IssueVarSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

scalar jsonb

input JsonbCastExp {
  String: StringComparisonExp
}

# Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
input JsonbComparisonExp {
  _cast: JsonbCastExp

  # is the column contained in the given json value
  _containedIn: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _hasKey: String

  # do all of these strings exist as top-level keys in the column
  _hasKeysAll: [String!]

  # do any of these strings exist as top-level keys in the column
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# columns and relationships of "legal_unit"
type LegalUnit {
  # An object relationship
  actor: Actor

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  grandFundTeams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  grandFundTeamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "legal_unit"
type LegalUnitAggregate {
  aggregate: LegalUnitAggregateFields
  nodes: [LegalUnit!]!
}

input LegalUnitAggregateBoolExp {
  count: legalUnitAggregateBoolExpCount
}

input legalUnitAggregateBoolExpCount {
  arguments: [LegalUnitSelectColumn!]
  distinct: Boolean
  filter: LegalUnitBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "legal_unit"
type LegalUnitAggregateFields {
  avg: LegalUnitAvgFields
  count(columns: [LegalUnitSelectColumn!], distinct: Boolean): Int!
  max: LegalUnitMaxFields
  min: LegalUnitMinFields
  stddev: LegalUnitStddevFields
  stddevPop: LegalUnitStddevPopFields
  stddevSamp: LegalUnitStddevSampFields
  sum: LegalUnitSumFields
  varPop: LegalUnitVarPopFields
  varSamp: LegalUnitVarSampFields
  variance: LegalUnitVarianceFields
}

# order by aggregate values of table "legal_unit"
input LegalUnitAggregateOrderBy {
  avg: LegalUnitAvgOrderBy
  count: OrderBy
  max: LegalUnitMaxOrderBy
  min: LegalUnitMinOrderBy
  stddev: LegalUnitStddevOrderBy
  stddevPop: LegalUnitStddevPopOrderBy
  stddevSamp: LegalUnitStddevSampOrderBy
  sum: LegalUnitSumOrderBy
  varPop: LegalUnitVarPopOrderBy
  varSamp: LegalUnitVarSampOrderBy
  variance: LegalUnitVarianceOrderBy
}

# input type for inserting array relation for remote table "legal_unit"
input LegalUnitArrRelInsertInput {
  data: [LegalUnitInsertInput!]!

  # upsert condition
  onConflict: LegalUnitOnConflict
}

# aggregate avg on columns
type LegalUnitAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "legal_unit"
input LegalUnitAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "legal_unit". All fields are combined with a logical 'AND'.
input LegalUnitBoolExp {
  _and: [LegalUnitBoolExp!]
  _not: LegalUnitBoolExp
  _or: [LegalUnitBoolExp!]
  actor: ActorBoolExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  grandFundTeams: TeamBoolExp
  grandFundTeamsAggregate: TeamAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "legal_unit"
enum LegalUnitConstraint {
  # unique or primary key constraint on columns "id"
  legal_unit_pkey
}

# input type for incrementing numeric columns in table "legal_unit"
input LegalUnitIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "legal_unit"
input LegalUnitInsertInput {
  actor: ActorObjRelInsertInput
  bankInfos: BankInfoArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  grandFundTeams: TeamArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type LegalUnitMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# order by max() on columns of table "legal_unit"
input LegalUnitMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type LegalUnitMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# order by min() on columns of table "legal_unit"
input LegalUnitMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "legal_unit"
type LegalUnitMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [LegalUnit!]!
}

# input type for inserting object relation for remote table "legal_unit"
input LegalUnitObjRelInsertInput {
  data: LegalUnitInsertInput!

  # upsert condition
  onConflict: LegalUnitOnConflict
}

# on_conflict condition type for table "legal_unit"
input LegalUnitOnConflict {
  constraint: LegalUnitConstraint!
  updateColumns: [LegalUnitUpdateColumn!]! = []
  where: LegalUnitBoolExp
}

# Ordering options when selecting data from "legal_unit".
input LegalUnitOrderBy {
  actor: ActorOrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  grandFundTeamsAggregate: TeamAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: legal_unit
input LegalUnitPkColumnsInput {
  id: bigint!
}

# select columns of table "legal_unit"
enum LegalUnitSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "legal_unit"
input LegalUnitSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type LegalUnitStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "legal_unit"
input LegalUnitStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type LegalUnitStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "legal_unit"
input LegalUnitStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type LegalUnitStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "legal_unit"
input LegalUnitStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "legal_unit"
input LegalUnitStreamCursorInput {
  # Stream column input with initial value
  initialValue: LegalUnitStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input LegalUnitStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type LegalUnitSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "legal_unit"
input LegalUnitSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "legal_unit"
enum LegalUnitUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type
}

input LegalUnitUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: LegalUnitIncInput

  # sets the columns of the filtered rows to the given values
  _set: LegalUnitSetInput

  # filter the rows which have to be updated
  where: LegalUnitBoolExp!
}

# aggregate variance on columns
type LegalUnitVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "legal_unit"
input LegalUnitVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type LegalUnitVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "legal_unit"
input LegalUnitVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type LegalUnitVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "legal_unit"
input LegalUnitVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "mission"
type Mission {
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  eventManage: EventManage
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isAutoAcceptingMembers: Boolean!
  isTemplate: Boolean!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!
  name: String!
  pointsMaximum: smallint!
  pointsMinimum: smallint!

  # An object relationship
  project: Project
  projectId: bigint
  quantity: smallint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "mission"
type MissionAggregate {
  aggregate: MissionAggregateFields
  nodes: [Mission!]!
}

input MissionAggregateBoolExp {
  bool_and: missionAggregateBoolExpBool_and
  bool_or: missionAggregateBoolExpBool_or
  count: missionAggregateBoolExpCount
}

input missionAggregateBoolExpBool_and {
  arguments: MissionSelectColumnMissionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: MissionBoolExp
  predicate: BooleanComparisonExp!
}

input missionAggregateBoolExpBool_or {
  arguments: MissionSelectColumnMissionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: MissionBoolExp
  predicate: BooleanComparisonExp!
}

input missionAggregateBoolExpCount {
  arguments: [MissionSelectColumn!]
  distinct: Boolean
  filter: MissionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "mission"
type MissionAggregateFields {
  avg: MissionAvgFields
  count(columns: [MissionSelectColumn!], distinct: Boolean): Int!
  max: MissionMaxFields
  min: MissionMinFields
  stddev: MissionStddevFields
  stddevPop: MissionStddevPopFields
  stddevSamp: MissionStddevSampFields
  sum: MissionSumFields
  varPop: MissionVarPopFields
  varSamp: MissionVarSampFields
  variance: MissionVarianceFields
}

# order by aggregate values of table "mission"
input MissionAggregateOrderBy {
  avg: MissionAvgOrderBy
  count: OrderBy
  max: MissionMaxOrderBy
  min: MissionMinOrderBy
  stddev: MissionStddevOrderBy
  stddevPop: MissionStddevPopOrderBy
  stddevSamp: MissionStddevSampOrderBy
  sum: MissionSumOrderBy
  varPop: MissionVarPopOrderBy
  varSamp: MissionVarSampOrderBy
  variance: MissionVarianceOrderBy
}

# input type for inserting array relation for remote table "mission"
input MissionArrRelInsertInput {
  data: [MissionInsertInput!]!

  # upsert condition
  onConflict: MissionOnConflict
}

# aggregate avg on columns
type MissionAvgFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "mission"
input MissionAvgOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "mission". All fields are combined with a logical 'AND'.
input MissionBoolExp {
  _and: [MissionBoolExp!]
  _not: MissionBoolExp
  _or: [MissionBoolExp!]
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventManage: EventManageBoolExp
  eventManageId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAutoAcceptingMembers: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  name: StringComparisonExp
  pointsMaximum: SmallintComparisonExp
  pointsMinimum: SmallintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  quantity: SmallintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "mission"
enum MissionConstraint {
  # unique or primary key constraint on columns "id"
  mission_pkey
}

# input type for incrementing numeric columns in table "mission"
input MissionIncInput {
  createdById: bigint
  eventManageId: bigint
  id: bigint
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "mission"
input MissionInsertInput {
  color: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManage: EventManageObjRelInsertInput
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  missionJoins: MissionJoinArrRelInsertInput
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  project: ProjectObjRelInsertInput
  projectId: bigint
  quantity: smallint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# columns and relationships of "mission_join"
type MissionJoin {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  eventJoin: EventJoin
  eventJoinId: bigint

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  joiner: User!
  joinerId: bigint!

  # An object relationship
  mission: Mission!
  missionId: bigint!
  points: smallint
  pointsSettledAt: timestamptz

  # An object relationship
  pointsSettledBy: Individual
  pointsSettledById: bigint

  # An object relationship
  project: Project
  projectId: bigint
  settledAt: timestamptz

  # An object relationship
  settledBy: Individual
  settledById: bigint
  state: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "mission_join"
type MissionJoinAggregate {
  aggregate: MissionJoinAggregateFields
  nodes: [MissionJoin!]!
}

input MissionJoinAggregateBoolExp {
  count: missionJoinAggregateBoolExpCount
}

input missionJoinAggregateBoolExpCount {
  arguments: [MissionJoinSelectColumn!]
  distinct: Boolean
  filter: MissionJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "mission_join"
type MissionJoinAggregateFields {
  avg: MissionJoinAvgFields
  count(columns: [MissionJoinSelectColumn!], distinct: Boolean): Int!
  max: MissionJoinMaxFields
  min: MissionJoinMinFields
  stddev: MissionJoinStddevFields
  stddevPop: MissionJoinStddevPopFields
  stddevSamp: MissionJoinStddevSampFields
  sum: MissionJoinSumFields
  varPop: MissionJoinVarPopFields
  varSamp: MissionJoinVarSampFields
  variance: MissionJoinVarianceFields
}

# order by aggregate values of table "mission_join"
input MissionJoinAggregateOrderBy {
  avg: MissionJoinAvgOrderBy
  count: OrderBy
  max: MissionJoinMaxOrderBy
  min: MissionJoinMinOrderBy
  stddev: MissionJoinStddevOrderBy
  stddevPop: MissionJoinStddevPopOrderBy
  stddevSamp: MissionJoinStddevSampOrderBy
  sum: MissionJoinSumOrderBy
  varPop: MissionJoinVarPopOrderBy
  varSamp: MissionJoinVarSampOrderBy
  variance: MissionJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "mission_join"
input MissionJoinArrRelInsertInput {
  data: [MissionJoinInsertInput!]!

  # upsert condition
  onConflict: MissionJoinOnConflict
}

# aggregate avg on columns
type MissionJoinAvgFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by avg() on columns of table "mission_join"
input MissionJoinAvgOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "mission_join". All fields are combined with a logical 'AND'.
input MissionJoinBoolExp {
  _and: [MissionJoinBoolExp!]
  _not: MissionJoinBoolExp
  _or: [MissionJoinBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventJoin: EventJoinBoolExp
  eventJoinId: BigintComparisonExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  joiner: UserBoolExp
  joinerId: BigintComparisonExp
  mission: MissionBoolExp
  missionId: BigintComparisonExp
  points: SmallintComparisonExp
  pointsSettledAt: TimestamptzComparisonExp
  pointsSettledBy: IndividualBoolExp
  pointsSettledById: BigintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  settledAt: TimestamptzComparisonExp
  settledBy: IndividualBoolExp
  settledById: BigintComparisonExp
  state: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "mission_join"
enum MissionJoinConstraint {
  # unique or primary key constraint on columns "event_join_id"
  mission_join_event_join_id_unique

  # unique or primary key constraint on columns "id"
  mission_join_pkey
}

# input type for incrementing numeric columns in table "mission_join"
input MissionJoinIncInput {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledById: bigint
  projectId: bigint
  settledById: bigint
  tenantId: bigint
}

# input type for inserting data into table "mission_join"
input MissionJoinInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventJoin: EventJoinObjRelInsertInput
  eventJoinId: bigint
  eventJoins: EventJoinArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  joiner: UserObjRelInsertInput
  joinerId: bigint
  mission: MissionObjRelInsertInput
  missionId: bigint
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledBy: IndividualObjRelInsertInput
  pointsSettledById: bigint
  project: ProjectObjRelInsertInput
  projectId: bigint
  settledAt: timestamptz
  settledBy: IndividualObjRelInsertInput
  settledById: bigint
  state: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type MissionJoinMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by max() on columns of table "mission_join"
input MissionJoinMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type MissionJoinMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# order by min() on columns of table "mission_join"
input MissionJoinMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "mission_join"
type MissionJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [MissionJoin!]!
}

# input type for inserting object relation for remote table "mission_join"
input MissionJoinObjRelInsertInput {
  data: MissionJoinInsertInput!

  # upsert condition
  onConflict: MissionJoinOnConflict
}

# on_conflict condition type for table "mission_join"
input MissionJoinOnConflict {
  constraint: MissionJoinConstraint!
  updateColumns: [MissionJoinUpdateColumn!]! = []
  where: MissionJoinBoolExp
}

# Ordering options when selecting data from "mission_join".
input MissionJoinOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoin: EventJoinOrderBy
  eventJoinId: OrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joiner: UserOrderBy
  joinerId: OrderBy
  mission: MissionOrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledAt: OrderBy
  pointsSettledBy: IndividualOrderBy
  pointsSettledById: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  settledAt: OrderBy
  settledBy: IndividualOrderBy
  settledById: OrderBy
  state: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: mission_join
input MissionJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "mission_join"
enum MissionJoinSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinerId

  # column name
  missionId

  # column name
  points

  # column name
  pointsSettledAt

  # column name
  pointsSettledById

  # column name
  projectId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

# input type for updating data in table "mission_join"
input MissionJoinSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate stddev on columns
type MissionJoinStddevFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by stddev() on columns of table "mission_join"
input MissionJoinStddevOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type MissionJoinStddevPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "mission_join"
input MissionJoinStddevPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type MissionJoinStddevSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "mission_join"
input MissionJoinStddevSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "mission_join"
input MissionJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: MissionJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input MissionJoinStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledAt: timestamptz
  pointsSettledById: bigint
  projectId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  tenantId: bigint
}

# aggregate sum on columns
type MissionJoinSumFields {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  joinerId: bigint
  missionId: bigint
  points: smallint
  pointsSettledById: bigint
  projectId: bigint
  settledById: bigint
  tenantId: bigint
}

# order by sum() on columns of table "mission_join"
input MissionJoinSumOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# update columns of table "mission_join"
enum MissionJoinUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinerId

  # column name
  missionId

  # column name
  points

  # column name
  pointsSettledAt

  # column name
  pointsSettledById

  # column name
  projectId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  tenantId
}

input MissionJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: MissionJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: MissionJoinSetInput

  # filter the rows which have to be updated
  where: MissionJoinBoolExp!
}

# aggregate variance on columns
type MissionJoinVarianceFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by variance() on columns of table "mission_join"
input MissionJoinVarianceOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type MissionJoinVarPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by varPop() on columns of table "mission_join"
input MissionJoinVarPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type MissionJoinVarSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinerId: Float
  missionId: Float
  points: Float
  pointsSettledById: Float
  projectId: Float
  settledById: Float
  tenantId: Float
}

# order by varSamp() on columns of table "mission_join"
input MissionJoinVarSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsSettledById: OrderBy
  projectId: OrderBy
  settledById: OrderBy
  tenantId: OrderBy
}

# aggregate max on columns
type MissionMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "mission"
input MissionMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManageId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type MissionMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "mission"
input MissionMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManageId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "mission"
type MissionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Mission!]!
}

# input type for inserting object relation for remote table "mission"
input MissionObjRelInsertInput {
  data: MissionInsertInput!

  # upsert condition
  onConflict: MissionOnConflict
}

# on_conflict condition type for table "mission"
input MissionOnConflict {
  constraint: MissionConstraint!
  updateColumns: [MissionUpdateColumn!]! = []
  where: MissionBoolExp
}

# Ordering options when selecting data from "mission".
input MissionOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManage: EventManageOrderBy
  eventManageId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAutoAcceptingMembers: OrderBy
  isTemplate: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  quantity: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: mission
input MissionPkColumnsInput {
  id: bigint!
}

# select columns of table "mission"
enum MissionSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventManageId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate

  # column name
  name

  # column name
  pointsMaximum

  # column name
  pointsMinimum

  # column name
  projectId

  # column name
  quantity

  # column name
  teamId

  # column name
  tenantId
}

# select "missionAggregateBoolExpBool_andArgumentsColumns" columns of table "mission"
enum MissionSelectColumnMissionAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate
}

# select "missionAggregateBoolExpBool_orArgumentsColumns" columns of table "mission"
enum MissionSelectColumnMissionAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate
}

# input type for updating data in table "mission"
input MissionSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type MissionStddevFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "mission"
input MissionStddevOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type MissionStddevPopFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "mission"
input MissionStddevPopOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type MissionStddevSampFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "mission"
input MissionStddevSampOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "mission"
input MissionStreamCursorInput {
  # Stream column input with initial value
  initialValue: MissionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input MissionStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type MissionSumFields {
  createdById: bigint
  eventManageId: bigint
  id: bigint
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "mission"
input MissionSumOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "mission"
enum MissionUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventManageId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate

  # column name
  name

  # column name
  pointsMaximum

  # column name
  pointsMinimum

  # column name
  projectId

  # column name
  quantity

  # column name
  teamId

  # column name
  tenantId
}

input MissionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: MissionIncInput

  # sets the columns of the filtered rows to the given values
  _set: MissionSetInput

  # filter the rows which have to be updated
  where: MissionBoolExp!
}

# aggregate variance on columns
type MissionVarianceFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "mission"
input MissionVarianceOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type MissionVarPopFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "mission"
input MissionVarPopOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type MissionVarSampFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "mission"
input MissionVarSampOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# mutation root
type Mutation {
  # delete data from the table: "account"
  deleteAccount(
    # filter the rows which have to be deleted
    where: AccountBoolExp!
  ): AccountMutationResponse

  # delete data from the table: "account_allocate"
  deleteAccountAllocate(
    # filter the rows which have to be deleted
    where: AccountAllocateBoolExp!
  ): AccountAllocateMutationResponse

  # delete single row from the table: "account_allocate"
  deleteAccountAllocateByPk(id: bigint!): AccountAllocate

  # delete single row from the table: "account"
  deleteAccountByPk(id: bigint!): Account

  # delete data from the table: "action"
  deleteAction(
    # filter the rows which have to be deleted
    where: ActionBoolExp!
  ): ActionMutationResponse

  # delete single row from the table: "action"
  deleteActionByPk(id: bigint!): Action

  # delete data from the table: "actor"
  deleteActor(
    # filter the rows which have to be deleted
    where: ActorBoolExp!
  ): ActorMutationResponse

  # delete single row from the table: "actor"
  deleteActorByPk(id: bigint!): Actor

  # delete data from the table: "actor_image"
  deleteActorImage(
    # filter the rows which have to be deleted
    where: ActorImageBoolExp!
  ): ActorImageMutationResponse

  # delete single row from the table: "actor_image"
  deleteActorImageByPk(id: bigint!): ActorImage

  # delete data from the table: "actor_tags"
  deleteActorTags(
    # filter the rows which have to be deleted
    where: ActorTagsBoolExp!
  ): ActorTagsMutationResponse

  # delete single row from the table: "actor_tags"
  deleteActorTagsByPk(actorId: bigint!, tagId: bigint!): ActorTags

  # delete data from the table: "address"
  deleteAddress(
    # filter the rows which have to be deleted
    where: AddressBoolExp!
  ): AddressMutationResponse

  # delete single row from the table: "address"
  deleteAddressByPk(id: bigint!): Address

  # delete data from the table: "bank_info"
  deleteBankInfo(
    # filter the rows which have to be deleted
    where: BankInfoBoolExp!
  ): BankInfoMutationResponse

  # delete single row from the table: "bank_info"
  deleteBankInfoByPk(id: bigint!): BankInfo

  # delete data from the table: "bot"
  deleteBot(
    # filter the rows which have to be deleted
    where: BotBoolExp!
  ): BotMutationResponse

  # delete single row from the table: "bot"
  deleteBotByPk(id: bigint!): Bot

  # delete data from the table: "campus"
  deleteCampus(
    # filter the rows which have to be deleted
    where: CampusBoolExp!
  ): CampusMutationResponse

  # delete single row from the table: "campus"
  deleteCampusByPk(id: bigint!): Campus

  # delete data from the table: "campus_cluster"
  deleteCampusCluster(
    # filter the rows which have to be deleted
    where: CampusClusterBoolExp!
  ): CampusClusterMutationResponse

  # delete single row from the table: "campus_cluster"
  deleteCampusClusterByPk(id: bigint!): CampusCluster

  # delete data from the table: "canteen"
  deleteCanteen(
    # filter the rows which have to be deleted
    where: CanteenBoolExp!
  ): CanteenMutationResponse

  # delete single row from the table: "canteen"
  deleteCanteenByPk(id: bigint!): Canteen

  # delete data from the table: "canteen_food"
  deleteCanteenFood(
    # filter the rows which have to be deleted
    where: CanteenFoodBoolExp!
  ): CanteenFoodMutationResponse

  # delete single row from the table: "canteen_food"
  deleteCanteenFoodByPk(id: bigint!): CanteenFood

  # delete data from the table: "canteen_menu"
  deleteCanteenMenu(
    # filter the rows which have to be deleted
    where: CanteenMenuBoolExp!
  ): CanteenMenuMutationResponse

  # delete single row from the table: "canteen_menu"
  deleteCanteenMenuByPk(id: bigint!): CanteenMenu

  # delete data from the table: "class_group"
  deleteClassGroup(
    # filter the rows which have to be deleted
    where: ClassGroupBoolExp!
  ): ClassGroupMutationResponse

  # delete single row from the table: "class_group"
  deleteClassGroupByPk(id: bigint!): ClassGroup

  # delete data from the table: "class_group_teacher"
  deleteClassGroupTeacher(
    # filter the rows which have to be deleted
    where: ClassGroupTeacherBoolExp!
  ): ClassGroupTeacherMutationResponse

  # delete single row from the table: "class_group_teacher"
  deleteClassGroupTeacherByPk(id: bigint!): ClassGroupTeacher

  # delete data from the table: "class_group_teacher_subjects"
  deleteClassGroupTeacherSubjects(
    # filter the rows which have to be deleted
    where: ClassGroupTeacherSubjectsBoolExp!
  ): ClassGroupTeacherSubjectsMutationResponse

  # delete single row from the table: "class_group_teacher_subjects"
  deleteClassGroupTeacherSubjectsByPk(classGroupTeacherId: bigint!, subjectId: bigint!): ClassGroupTeacherSubjects

  # delete data from the table: "cohort"
  deleteCohort(
    # filter the rows which have to be deleted
    where: CohortBoolExp!
  ): CohortMutationResponse

  # delete single row from the table: "cohort"
  deleteCohortByPk(id: bigint!): Cohort

  # delete data from the table: "content"
  deleteContent(
    # filter the rows which have to be deleted
    where: ContentBoolExp!
  ): ContentMutationResponse

  # delete data from the table: "content_attachments"
  deleteContentAttachments(
    # filter the rows which have to be deleted
    where: ContentAttachmentsBoolExp!
  ): ContentAttachmentsMutationResponse

  # delete single row from the table: "content_attachments"
  deleteContentAttachmentsByPk(contentId: bigint!, fileUploadId: bigint!): ContentAttachments

  # delete single row from the table: "content"
  deleteContentByPk(id: bigint!): Content

  # delete data from the table: "document"
  deleteDocument(
    # filter the rows which have to be deleted
    where: DocumentBoolExp!
  ): DocumentMutationResponse

  # delete single row from the table: "document"
  deleteDocumentByPk(id: bigint!): Document

  # delete data from the table: "event"
  deleteEvent(
    # filter the rows which have to be deleted
    where: EventBoolExp!
  ): EventMutationResponse

  # delete data from the table: "event_approval"
  deleteEventApproval(
    # filter the rows which have to be deleted
    where: EventApprovalBoolExp!
  ): EventApprovalMutationResponse

  # delete single row from the table: "event_approval"
  deleteEventApprovalByPk(id: bigint!): EventApproval

  # delete data from the table: "event_approval_step"
  deleteEventApprovalStep(
    # filter the rows which have to be deleted
    where: EventApprovalStepBoolExp!
  ): EventApprovalStepMutationResponse

  # delete single row from the table: "event_approval_step"
  deleteEventApprovalStepByPk(id: bigint!): EventApprovalStep

  # delete data from the table: "event_approval_step_notifiees"
  deleteEventApprovalStepNotifiees(
    # filter the rows which have to be deleted
    where: EventApprovalStepNotifieesBoolExp!
  ): EventApprovalStepNotifieesMutationResponse

  # delete single row from the table: "event_approval_step_notifiees"
  deleteEventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepNotifiees

  # delete data from the table: "event_approval_step_validators"
  deleteEventApprovalStepValidators(
    # filter the rows which have to be deleted
    where: EventApprovalStepValidatorsBoolExp!
  ): EventApprovalStepValidatorsMutationResponse

  # delete single row from the table: "event_approval_step_validators"
  deleteEventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepValidators

  # delete single row from the table: "event"
  deleteEventByPk(id: bigint!): Event

  # delete data from the table: "event_join"
  deleteEventJoin(
    # filter the rows which have to be deleted
    where: EventJoinBoolExp!
  ): EventJoinMutationResponse

  # delete single row from the table: "event_join"
  deleteEventJoinByPk(id: bigint!): EventJoin

  # delete data from the table: "event_manage"
  deleteEventManage(
    # filter the rows which have to be deleted
    where: EventManageBoolExp!
  ): EventManageMutationResponse

  # delete single row from the table: "event_manage"
  deleteEventManageByPk(id: bigint!): EventManage

  # delete data from the table: "event_supervisors"
  deleteEventSupervisors(
    # filter the rows which have to be deleted
    where: EventSupervisorsBoolExp!
  ): EventSupervisorsMutationResponse

  # delete single row from the table: "event_supervisors"
  deleteEventSupervisorsByPk(eventId: bigint!, userId: bigint!): EventSupervisors

  # delete data from the table: "event_tags"
  deleteEventTags(
    # filter the rows which have to be deleted
    where: EventTagsBoolExp!
  ): EventTagsMutationResponse

  # delete single row from the table: "event_tags"
  deleteEventTagsByPk(eventId: bigint!, tagId: bigint!): EventTags

  # delete data from the table: "expense"
  deleteExpense(
    # filter the rows which have to be deleted
    where: ExpenseBoolExp!
  ): ExpenseMutationResponse

  # delete single row from the table: "expense"
  deleteExpenseByPk(id: bigint!): Expense

  # delete data from the table: "expense_item"
  deleteExpenseItem(
    # filter the rows which have to be deleted
    where: ExpenseItemBoolExp!
  ): ExpenseItemMutationResponse

  # delete data from the table: "expense_item_attachments"
  deleteExpenseItemAttachments(
    # filter the rows which have to be deleted
    where: ExpenseItemAttachmentsBoolExp!
  ): ExpenseItemAttachmentsMutationResponse

  # delete single row from the table: "expense_item_attachments"
  deleteExpenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # delete single row from the table: "expense_item"
  deleteExpenseItemByPk(id: bigint!): ExpenseItem

  # delete data from the table: "favorite"
  deleteFavorite(
    # filter the rows which have to be deleted
    where: FavoriteBoolExp!
  ): FavoriteMutationResponse

  # delete single row from the table: "favorite"
  deleteFavoriteByPk(id: bigint!): Favorite

  # delete data from the table: "file_upload"
  deleteFileUpload(
    # filter the rows which have to be deleted
    where: FileUploadBoolExp!
  ): FileUploadMutationResponse

  # delete single row from the table: "file_upload"
  deleteFileUploadByPk(id: bigint!): FileUpload

  # delete data from the table: "finance"
  deleteFinance(
    # filter the rows which have to be deleted
    where: FinanceBoolExp!
  ): FinanceMutationResponse

  # delete data from the table: "finance_attachments"
  deleteFinanceAttachments(
    # filter the rows which have to be deleted
    where: FinanceAttachmentsBoolExp!
  ): FinanceAttachmentsMutationResponse

  # delete single row from the table: "finance_attachments"
  deleteFinanceAttachmentsByPk(fileUploadId: bigint!, financeId: bigint!): FinanceAttachments

  # delete single row from the table: "finance"
  deleteFinanceByPk(id: bigint!): Finance

  # delete data from the table: "follow"
  deleteFollow(
    # filter the rows which have to be deleted
    where: FollowBoolExp!
  ): FollowMutationResponse

  # delete single row from the table: "follow"
  deleteFollowByPk(id: bigint!): Follow

  # delete data from the table: "form"
  deleteForm(
    # filter the rows which have to be deleted
    where: FormBoolExp!
  ): FormMutationResponse

  # delete single row from the table: "form"
  deleteFormByPk(id: bigint!): Form

  # delete data from the table: "form_submission"
  deleteFormSubmission(
    # filter the rows which have to be deleted
    where: FormSubmissionBoolExp!
  ): FormSubmissionMutationResponse

  # delete single row from the table: "form_submission"
  deleteFormSubmissionByPk(id: bigint!): FormSubmission

  # delete data from the table: "grant"
  deleteGrant(
    # filter the rows which have to be deleted
    where: GrantBoolExp!
  ): GrantMutationResponse

  # delete data from the table: "grant_attachments"
  deleteGrantAttachments(
    # filter the rows which have to be deleted
    where: GrantAttachmentsBoolExp!
  ): GrantAttachmentsMutationResponse

  # delete single row from the table: "grant_attachments"
  deleteGrantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # delete single row from the table: "grant"
  deleteGrantByPk(id: bigint!): Grant

  # delete data from the table: "grant_unlock"
  deleteGrantUnlock(
    # filter the rows which have to be deleted
    where: GrantUnlockBoolExp!
  ): GrantUnlockMutationResponse

  # delete data from the table: "grant_unlock_attachments"
  deleteGrantUnlockAttachments(
    # filter the rows which have to be deleted
    where: GrantUnlockAttachmentsBoolExp!
  ): GrantUnlockAttachmentsMutationResponse

  # delete single row from the table: "grant_unlock_attachments"
  deleteGrantUnlockAttachmentsByPk(fileUploadId: bigint!, grantUnlockId: bigint!): GrantUnlockAttachments

  # delete single row from the table: "grant_unlock"
  deleteGrantUnlockByPk(id: bigint!): GrantUnlock

  # delete data from the table: "individual"
  deleteIndividual(
    # filter the rows which have to be deleted
    where: IndividualBoolExp!
  ): IndividualMutationResponse

  # delete single row from the table: "individual"
  deleteIndividualByPk(id: bigint!): Individual

  # delete data from the table: "issue"
  deleteIssue(
    # filter the rows which have to be deleted
    where: IssueBoolExp!
  ): IssueMutationResponse

  # delete single row from the table: "issue"
  deleteIssueByPk(id: bigint!): Issue

  # delete data from the table: "issue_contributors"
  deleteIssueContributors(
    # filter the rows which have to be deleted
    where: IssueContributorsBoolExp!
  ): IssueContributorsMutationResponse

  # delete single row from the table: "issue_contributors"
  deleteIssueContributorsByPk(individualId: bigint!, issueId: bigint!): IssueContributors

  # delete data from the table: "issue_tags"
  deleteIssueTags(
    # filter the rows which have to be deleted
    where: IssueTagsBoolExp!
  ): IssueTagsMutationResponse

  # delete single row from the table: "issue_tags"
  deleteIssueTagsByPk(issueId: bigint!, tagId: bigint!): IssueTags

  # delete data from the table: "legal_unit"
  deleteLegalUnit(
    # filter the rows which have to be deleted
    where: LegalUnitBoolExp!
  ): LegalUnitMutationResponse

  # delete single row from the table: "legal_unit"
  deleteLegalUnitByPk(id: bigint!): LegalUnit

  # delete data from the table: "mission"
  deleteMission(
    # filter the rows which have to be deleted
    where: MissionBoolExp!
  ): MissionMutationResponse

  # delete single row from the table: "mission"
  deleteMissionByPk(id: bigint!): Mission

  # delete data from the table: "mission_join"
  deleteMissionJoin(
    # filter the rows which have to be deleted
    where: MissionJoinBoolExp!
  ): MissionJoinMutationResponse

  # delete single row from the table: "mission_join"
  deleteMissionJoinByPk(id: bigint!): MissionJoin

  # delete data from the table: "pole"
  deletePole(
    # filter the rows which have to be deleted
    where: PoleBoolExp!
  ): PoleMutationResponse

  # delete single row from the table: "pole"
  deletePoleByPk(id: bigint!): Pole

  # delete data from the table: "project"
  deleteProject(
    # filter the rows which have to be deleted
    where: ProjectBoolExp!
  ): ProjectMutationResponse

  # delete single row from the table: "project"
  deleteProjectByPk(id: bigint!): Project

  # delete data from the table: "project_supervisors"
  deleteProjectSupervisors(
    # filter the rows which have to be deleted
    where: ProjectSupervisorsBoolExp!
  ): ProjectSupervisorsMutationResponse

  # delete single row from the table: "project_supervisors"
  deleteProjectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # delete data from the table: "project_tags"
  deleteProjectTags(
    # filter the rows which have to be deleted
    where: ProjectTagsBoolExp!
  ): ProjectTagsMutationResponse

  # delete single row from the table: "project_tags"
  deleteProjectTagsByPk(projectId: bigint!, tagId: bigint!): ProjectTags

  # delete data from the table: "reaction"
  deleteReaction(
    # filter the rows which have to be deleted
    where: ReactionBoolExp!
  ): ReactionMutationResponse

  # delete single row from the table: "reaction"
  deleteReactionByPk(id: bigint!): Reaction

  # delete data from the table: "report"
  deleteReport(
    # filter the rows which have to be deleted
    where: ReportBoolExp!
  ): ReportMutationResponse

  # delete single row from the table: "report"
  deleteReportByPk(id: bigint!): Report

  # delete data from the table: "role"
  deleteRole(
    # filter the rows which have to be deleted
    where: RoleBoolExp!
  ): RoleMutationResponse

  # delete single row from the table: "role"
  deleteRoleByPk(id: bigint!): Role

  # delete data from the table: "session"
  deleteSession(
    # filter the rows which have to be deleted
    where: SessionBoolExp!
  ): SessionMutationResponse

  # delete single row from the table: "session"
  deleteSessionByPk(id: bigint!): Session

  # delete data from the table: "shortcut"
  deleteShortcut(
    # filter the rows which have to be deleted
    where: ShortcutBoolExp!
  ): ShortcutMutationResponse

  # delete single row from the table: "shortcut"
  deleteShortcutByPk(id: bigint!): Shortcut

  # delete data from the table: "social"
  deleteSocial(
    # filter the rows which have to be deleted
    where: SocialBoolExp!
  ): SocialMutationResponse

  # delete single row from the table: "social"
  deleteSocialByPk(id: bigint!): Social

  # delete data from the table: "subject"
  deleteSubject(
    # filter the rows which have to be deleted
    where: SubjectBoolExp!
  ): SubjectMutationResponse

  # delete single row from the table: "subject"
  deleteSubjectByPk(id: bigint!): Subject

  # delete data from the table: "subject_class_groups"
  deleteSubjectClassGroups(
    # filter the rows which have to be deleted
    where: SubjectClassGroupsBoolExp!
  ): SubjectClassGroupsMutationResponse

  # delete single row from the table: "subject_class_groups"
  deleteSubjectClassGroupsByPk(classGroupId: bigint!, subjectId: bigint!): SubjectClassGroups

  # delete data from the table: "tag"
  deleteTag(
    # filter the rows which have to be deleted
    where: TagBoolExp!
  ): TagMutationResponse

  # delete single row from the table: "tag"
  deleteTagByPk(id: bigint!): Tag

  # delete data from the table: "team"
  deleteTeam(
    # filter the rows which have to be deleted
    where: TeamBoolExp!
  ): TeamMutationResponse

  # delete single row from the table: "team"
  deleteTeamByPk(id: bigint!): Team

  # delete data from the table: "team_history"
  deleteTeamHistory(
    # filter the rows which have to be deleted
    where: TeamHistoryBoolExp!
  ): TeamHistoryMutationResponse

  # delete single row from the table: "team_history"
  deleteTeamHistoryByPk(id: bigint!): TeamHistory

  # delete data from the table: "team_join"
  deleteTeamJoin(
    # filter the rows which have to be deleted
    where: TeamJoinBoolExp!
  ): TeamJoinMutationResponse

  # delete single row from the table: "team_join"
  deleteTeamJoinByPk(id: bigint!): TeamJoin

  # delete data from the table: "team_member"
  deleteTeamMember(
    # filter the rows which have to be deleted
    where: TeamMemberBoolExp!
  ): TeamMemberMutationResponse

  # delete single row from the table: "team_member"
  deleteTeamMemberByPk(id: bigint!): TeamMember

  # delete data from the table: "team_member_roles"
  deleteTeamMemberRoles(
    # filter the rows which have to be deleted
    where: TeamMemberRolesBoolExp!
  ): TeamMemberRolesMutationResponse

  # delete single row from the table: "team_member_roles"
  deleteTeamMemberRolesByPk(roleId: bigint!, teamMemberId: bigint!): TeamMemberRoles

  # delete data from the table: "team_metric"
  deleteTeamMetric(
    # filter the rows which have to be deleted
    where: TeamMetricBoolExp!
  ): TeamMetricMutationResponse

  # delete single row from the table: "team_metric"
  deleteTeamMetricByPk(id: bigint!): TeamMetric

  # delete data from the table: "tenant"
  deleteTenant(
    # filter the rows which have to be deleted
    where: TenantBoolExp!
  ): TenantMutationResponse

  # delete single row from the table: "tenant"
  deleteTenantByPk(id: bigint!): Tenant

  # delete data from the table: "tenant_manage"
  deleteTenantManage(
    # filter the rows which have to be deleted
    where: TenantManageBoolExp!
  ): TenantManageMutationResponse

  # delete single row from the table: "tenant_manage"
  deleteTenantManageByPk(id: bigint!): TenantManage

  # delete data from the table: "thread"
  deleteThread(
    # filter the rows which have to be deleted
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  # delete single row from the table: "thread"
  deleteThreadByPk(id: bigint!): Thread

  # delete data from the table: "thread_contributors"
  deleteThreadContributors(
    # filter the rows which have to be deleted
    where: ThreadContributorsBoolExp!
  ): ThreadContributorsMutationResponse

  # delete single row from the table: "thread_contributors"
  deleteThreadContributorsByPk(individualId: bigint!, threadId: bigint!): ThreadContributors

  # delete data from the table: "thread_tags"
  deleteThreadTags(
    # filter the rows which have to be deleted
    where: ThreadTagsBoolExp!
  ): ThreadTagsMutationResponse

  # delete single row from the table: "thread_tags"
  deleteThreadTagsByPk(tagId: bigint!, threadId: bigint!): ThreadTags

  # delete data from the table: "user"
  deleteUser(
    # filter the rows which have to be deleted
    where: UserBoolExp!
  ): UserMutationResponse

  # delete single row from the table: "user"
  deleteUserByPk(id: bigint!): User

  # delete data from the table: "validation"
  deleteValidation(
    # filter the rows which have to be deleted
    where: ValidationBoolExp!
  ): ValidationMutationResponse

  # delete single row from the table: "validation"
  deleteValidationByPk(id: bigint!): Validation

  # delete data from the table: "vote"
  deleteVote(
    # filter the rows which have to be deleted
    where: VoteBoolExp!
  ): VoteMutationResponse

  # delete single row from the table: "vote"
  deleteVoteByPk(id: bigint!): Vote

  # insert data into the table: "account"
  insertAccount(
    # the rows to be inserted
    objects: [AccountInsertInput!]!

    # upsert condition
    onConflict: AccountOnConflict
  ): AccountMutationResponse

  # insert data into the table: "account_allocate"
  insertAccountAllocate(
    # the rows to be inserted
    objects: [AccountAllocateInsertInput!]!

    # upsert condition
    onConflict: AccountAllocateOnConflict
  ): AccountAllocateMutationResponse

  # insert a single row into the table: "account_allocate"
  insertAccountAllocateOne(
    # the row to be inserted
    object: AccountAllocateInsertInput!

    # upsert condition
    onConflict: AccountAllocateOnConflict
  ): AccountAllocate

  # insert a single row into the table: "account"
  insertAccountOne(
    # the row to be inserted
    object: AccountInsertInput!

    # upsert condition
    onConflict: AccountOnConflict
  ): Account

  # insert data into the table: "action"
  insertAction(
    # the rows to be inserted
    objects: [ActionInsertInput!]!

    # upsert condition
    onConflict: ActionOnConflict
  ): ActionMutationResponse

  # insert a single row into the table: "action"
  insertActionOne(
    # the row to be inserted
    object: ActionInsertInput!

    # upsert condition
    onConflict: ActionOnConflict
  ): Action

  # insert data into the table: "actor"
  insertActor(
    # the rows to be inserted
    objects: [ActorInsertInput!]!

    # upsert condition
    onConflict: ActorOnConflict
  ): ActorMutationResponse

  # insert data into the table: "actor_image"
  insertActorImage(
    # the rows to be inserted
    objects: [ActorImageInsertInput!]!

    # upsert condition
    onConflict: ActorImageOnConflict
  ): ActorImageMutationResponse

  # insert a single row into the table: "actor_image"
  insertActorImageOne(
    # the row to be inserted
    object: ActorImageInsertInput!

    # upsert condition
    onConflict: ActorImageOnConflict
  ): ActorImage

  # insert a single row into the table: "actor"
  insertActorOne(
    # the row to be inserted
    object: ActorInsertInput!

    # upsert condition
    onConflict: ActorOnConflict
  ): Actor

  # insert data into the table: "actor_tags"
  insertActorTags(
    # the rows to be inserted
    objects: [ActorTagsInsertInput!]!

    # upsert condition
    onConflict: ActorTagsOnConflict
  ): ActorTagsMutationResponse

  # insert a single row into the table: "actor_tags"
  insertActorTagsOne(
    # the row to be inserted
    object: ActorTagsInsertInput!

    # upsert condition
    onConflict: ActorTagsOnConflict
  ): ActorTags

  # insert data into the table: "address"
  insertAddress(
    # the rows to be inserted
    objects: [AddressInsertInput!]!

    # upsert condition
    onConflict: AddressOnConflict
  ): AddressMutationResponse

  # insert a single row into the table: "address"
  insertAddressOne(
    # the row to be inserted
    object: AddressInsertInput!

    # upsert condition
    onConflict: AddressOnConflict
  ): Address

  # insert data into the table: "bank_info"
  insertBankInfo(
    # the rows to be inserted
    objects: [BankInfoInsertInput!]!

    # upsert condition
    onConflict: BankInfoOnConflict
  ): BankInfoMutationResponse

  # insert a single row into the table: "bank_info"
  insertBankInfoOne(
    # the row to be inserted
    object: BankInfoInsertInput!

    # upsert condition
    onConflict: BankInfoOnConflict
  ): BankInfo

  # insert data into the table: "bot"
  insertBot(
    # the rows to be inserted
    objects: [BotInsertInput!]!

    # upsert condition
    onConflict: BotOnConflict
  ): BotMutationResponse

  # insert a single row into the table: "bot"
  insertBotOne(
    # the row to be inserted
    object: BotInsertInput!

    # upsert condition
    onConflict: BotOnConflict
  ): Bot

  # insert data into the table: "campus"
  insertCampus(
    # the rows to be inserted
    objects: [CampusInsertInput!]!

    # upsert condition
    onConflict: CampusOnConflict
  ): CampusMutationResponse

  # insert data into the table: "campus_cluster"
  insertCampusCluster(
    # the rows to be inserted
    objects: [CampusClusterInsertInput!]!

    # upsert condition
    onConflict: CampusClusterOnConflict
  ): CampusClusterMutationResponse

  # insert a single row into the table: "campus_cluster"
  insertCampusClusterOne(
    # the row to be inserted
    object: CampusClusterInsertInput!

    # upsert condition
    onConflict: CampusClusterOnConflict
  ): CampusCluster

  # insert a single row into the table: "campus"
  insertCampusOne(
    # the row to be inserted
    object: CampusInsertInput!

    # upsert condition
    onConflict: CampusOnConflict
  ): Campus

  # insert data into the table: "canteen"
  insertCanteen(
    # the rows to be inserted
    objects: [CanteenInsertInput!]!

    # upsert condition
    onConflict: CanteenOnConflict
  ): CanteenMutationResponse

  # insert data into the table: "canteen_food"
  insertCanteenFood(
    # the rows to be inserted
    objects: [CanteenFoodInsertInput!]!

    # upsert condition
    onConflict: CanteenFoodOnConflict
  ): CanteenFoodMutationResponse

  # insert a single row into the table: "canteen_food"
  insertCanteenFoodOne(
    # the row to be inserted
    object: CanteenFoodInsertInput!

    # upsert condition
    onConflict: CanteenFoodOnConflict
  ): CanteenFood

  # insert data into the table: "canteen_menu"
  insertCanteenMenu(
    # the rows to be inserted
    objects: [CanteenMenuInsertInput!]!

    # upsert condition
    onConflict: CanteenMenuOnConflict
  ): CanteenMenuMutationResponse

  # insert a single row into the table: "canteen_menu"
  insertCanteenMenuOne(
    # the row to be inserted
    object: CanteenMenuInsertInput!

    # upsert condition
    onConflict: CanteenMenuOnConflict
  ): CanteenMenu

  # insert a single row into the table: "canteen"
  insertCanteenOne(
    # the row to be inserted
    object: CanteenInsertInput!

    # upsert condition
    onConflict: CanteenOnConflict
  ): Canteen

  # insert data into the table: "class_group"
  insertClassGroup(
    # the rows to be inserted
    objects: [ClassGroupInsertInput!]!

    # upsert condition
    onConflict: ClassGroupOnConflict
  ): ClassGroupMutationResponse

  # insert a single row into the table: "class_group"
  insertClassGroupOne(
    # the row to be inserted
    object: ClassGroupInsertInput!

    # upsert condition
    onConflict: ClassGroupOnConflict
  ): ClassGroup

  # insert data into the table: "class_group_teacher"
  insertClassGroupTeacher(
    # the rows to be inserted
    objects: [ClassGroupTeacherInsertInput!]!

    # upsert condition
    onConflict: ClassGroupTeacherOnConflict
  ): ClassGroupTeacherMutationResponse

  # insert a single row into the table: "class_group_teacher"
  insertClassGroupTeacherOne(
    # the row to be inserted
    object: ClassGroupTeacherInsertInput!

    # upsert condition
    onConflict: ClassGroupTeacherOnConflict
  ): ClassGroupTeacher

  # insert data into the table: "class_group_teacher_subjects"
  insertClassGroupTeacherSubjects(
    # the rows to be inserted
    objects: [ClassGroupTeacherSubjectsInsertInput!]!

    # upsert condition
    onConflict: ClassGroupTeacherSubjectsOnConflict
  ): ClassGroupTeacherSubjectsMutationResponse

  # insert a single row into the table: "class_group_teacher_subjects"
  insertClassGroupTeacherSubjectsOne(
    # the row to be inserted
    object: ClassGroupTeacherSubjectsInsertInput!

    # upsert condition
    onConflict: ClassGroupTeacherSubjectsOnConflict
  ): ClassGroupTeacherSubjects

  # insert data into the table: "cohort"
  insertCohort(
    # the rows to be inserted
    objects: [CohortInsertInput!]!

    # upsert condition
    onConflict: CohortOnConflict
  ): CohortMutationResponse

  # insert a single row into the table: "cohort"
  insertCohortOne(
    # the row to be inserted
    object: CohortInsertInput!

    # upsert condition
    onConflict: CohortOnConflict
  ): Cohort

  # insert data into the table: "content"
  insertContent(
    # the rows to be inserted
    objects: [ContentInsertInput!]!

    # upsert condition
    onConflict: ContentOnConflict
  ): ContentMutationResponse

  # insert data into the table: "content_attachments"
  insertContentAttachments(
    # the rows to be inserted
    objects: [ContentAttachmentsInsertInput!]!

    # upsert condition
    onConflict: ContentAttachmentsOnConflict
  ): ContentAttachmentsMutationResponse

  # insert a single row into the table: "content_attachments"
  insertContentAttachmentsOne(
    # the row to be inserted
    object: ContentAttachmentsInsertInput!

    # upsert condition
    onConflict: ContentAttachmentsOnConflict
  ): ContentAttachments

  # insert a single row into the table: "content"
  insertContentOne(
    # the row to be inserted
    object: ContentInsertInput!

    # upsert condition
    onConflict: ContentOnConflict
  ): Content

  # insert data into the table: "document"
  insertDocument(
    # the rows to be inserted
    objects: [DocumentInsertInput!]!

    # upsert condition
    onConflict: DocumentOnConflict
  ): DocumentMutationResponse

  # insert a single row into the table: "document"
  insertDocumentOne(
    # the row to be inserted
    object: DocumentInsertInput!

    # upsert condition
    onConflict: DocumentOnConflict
  ): Document

  # insert data into the table: "event"
  insertEvent(
    # the rows to be inserted
    objects: [EventInsertInput!]!

    # upsert condition
    onConflict: EventOnConflict
  ): EventMutationResponse

  # insert data into the table: "event_approval"
  insertEventApproval(
    # the rows to be inserted
    objects: [EventApprovalInsertInput!]!

    # upsert condition
    onConflict: EventApprovalOnConflict
  ): EventApprovalMutationResponse

  # insert a single row into the table: "event_approval"
  insertEventApprovalOne(
    # the row to be inserted
    object: EventApprovalInsertInput!

    # upsert condition
    onConflict: EventApprovalOnConflict
  ): EventApproval

  # insert data into the table: "event_approval_step"
  insertEventApprovalStep(
    # the rows to be inserted
    objects: [EventApprovalStepInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepOnConflict
  ): EventApprovalStepMutationResponse

  # insert data into the table: "event_approval_step_notifiees"
  insertEventApprovalStepNotifiees(
    # the rows to be inserted
    objects: [EventApprovalStepNotifieesInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepNotifieesOnConflict
  ): EventApprovalStepNotifieesMutationResponse

  # insert a single row into the table: "event_approval_step_notifiees"
  insertEventApprovalStepNotifieesOne(
    # the row to be inserted
    object: EventApprovalStepNotifieesInsertInput!

    # upsert condition
    onConflict: EventApprovalStepNotifieesOnConflict
  ): EventApprovalStepNotifiees

  # insert a single row into the table: "event_approval_step"
  insertEventApprovalStepOne(
    # the row to be inserted
    object: EventApprovalStepInsertInput!

    # upsert condition
    onConflict: EventApprovalStepOnConflict
  ): EventApprovalStep

  # insert data into the table: "event_approval_step_validators"
  insertEventApprovalStepValidators(
    # the rows to be inserted
    objects: [EventApprovalStepValidatorsInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepValidatorsOnConflict
  ): EventApprovalStepValidatorsMutationResponse

  # insert a single row into the table: "event_approval_step_validators"
  insertEventApprovalStepValidatorsOne(
    # the row to be inserted
    object: EventApprovalStepValidatorsInsertInput!

    # upsert condition
    onConflict: EventApprovalStepValidatorsOnConflict
  ): EventApprovalStepValidators

  # insert data into the table: "event_join"
  insertEventJoin(
    # the rows to be inserted
    objects: [EventJoinInsertInput!]!

    # upsert condition
    onConflict: EventJoinOnConflict
  ): EventJoinMutationResponse

  # insert a single row into the table: "event_join"
  insertEventJoinOne(
    # the row to be inserted
    object: EventJoinInsertInput!

    # upsert condition
    onConflict: EventJoinOnConflict
  ): EventJoin

  # insert data into the table: "event_manage"
  insertEventManage(
    # the rows to be inserted
    objects: [EventManageInsertInput!]!

    # upsert condition
    onConflict: EventManageOnConflict
  ): EventManageMutationResponse

  # insert a single row into the table: "event_manage"
  insertEventManageOne(
    # the row to be inserted
    object: EventManageInsertInput!

    # upsert condition
    onConflict: EventManageOnConflict
  ): EventManage

  # insert a single row into the table: "event"
  insertEventOne(
    # the row to be inserted
    object: EventInsertInput!

    # upsert condition
    onConflict: EventOnConflict
  ): Event

  # insert data into the table: "event_supervisors"
  insertEventSupervisors(
    # the rows to be inserted
    objects: [EventSupervisorsInsertInput!]!

    # upsert condition
    onConflict: EventSupervisorsOnConflict
  ): EventSupervisorsMutationResponse

  # insert a single row into the table: "event_supervisors"
  insertEventSupervisorsOne(
    # the row to be inserted
    object: EventSupervisorsInsertInput!

    # upsert condition
    onConflict: EventSupervisorsOnConflict
  ): EventSupervisors

  # insert data into the table: "event_tags"
  insertEventTags(
    # the rows to be inserted
    objects: [EventTagsInsertInput!]!

    # upsert condition
    onConflict: EventTagsOnConflict
  ): EventTagsMutationResponse

  # insert a single row into the table: "event_tags"
  insertEventTagsOne(
    # the row to be inserted
    object: EventTagsInsertInput!

    # upsert condition
    onConflict: EventTagsOnConflict
  ): EventTags

  # insert data into the table: "expense"
  insertExpense(
    # the rows to be inserted
    objects: [ExpenseInsertInput!]!

    # upsert condition
    onConflict: ExpenseOnConflict
  ): ExpenseMutationResponse

  # insert data into the table: "expense_item"
  insertExpenseItem(
    # the rows to be inserted
    objects: [ExpenseItemInsertInput!]!

    # upsert condition
    onConflict: ExpenseItemOnConflict
  ): ExpenseItemMutationResponse

  # insert data into the table: "expense_item_attachments"
  insertExpenseItemAttachments(
    # the rows to be inserted
    objects: [ExpenseItemAttachmentsInsertInput!]!

    # upsert condition
    onConflict: ExpenseItemAttachmentsOnConflict
  ): ExpenseItemAttachmentsMutationResponse

  # insert a single row into the table: "expense_item_attachments"
  insertExpenseItemAttachmentsOne(
    # the row to be inserted
    object: ExpenseItemAttachmentsInsertInput!

    # upsert condition
    onConflict: ExpenseItemAttachmentsOnConflict
  ): ExpenseItemAttachments

  # insert a single row into the table: "expense_item"
  insertExpenseItemOne(
    # the row to be inserted
    object: ExpenseItemInsertInput!

    # upsert condition
    onConflict: ExpenseItemOnConflict
  ): ExpenseItem

  # insert a single row into the table: "expense"
  insertExpenseOne(
    # the row to be inserted
    object: ExpenseInsertInput!

    # upsert condition
    onConflict: ExpenseOnConflict
  ): Expense

  # insert data into the table: "favorite"
  insertFavorite(
    # the rows to be inserted
    objects: [FavoriteInsertInput!]!

    # upsert condition
    onConflict: FavoriteOnConflict
  ): FavoriteMutationResponse

  # insert a single row into the table: "favorite"
  insertFavoriteOne(
    # the row to be inserted
    object: FavoriteInsertInput!

    # upsert condition
    onConflict: FavoriteOnConflict
  ): Favorite

  # insert data into the table: "file_upload"
  insertFileUpload(
    # the rows to be inserted
    objects: [FileUploadInsertInput!]!

    # upsert condition
    onConflict: FileUploadOnConflict
  ): FileUploadMutationResponse

  # insert a single row into the table: "file_upload"
  insertFileUploadOne(
    # the row to be inserted
    object: FileUploadInsertInput!

    # upsert condition
    onConflict: FileUploadOnConflict
  ): FileUpload

  # insert data into the table: "finance"
  insertFinance(
    # the rows to be inserted
    objects: [FinanceInsertInput!]!

    # upsert condition
    onConflict: FinanceOnConflict
  ): FinanceMutationResponse

  # insert data into the table: "finance_attachments"
  insertFinanceAttachments(
    # the rows to be inserted
    objects: [FinanceAttachmentsInsertInput!]!

    # upsert condition
    onConflict: FinanceAttachmentsOnConflict
  ): FinanceAttachmentsMutationResponse

  # insert a single row into the table: "finance_attachments"
  insertFinanceAttachmentsOne(
    # the row to be inserted
    object: FinanceAttachmentsInsertInput!

    # upsert condition
    onConflict: FinanceAttachmentsOnConflict
  ): FinanceAttachments

  # insert a single row into the table: "finance"
  insertFinanceOne(
    # the row to be inserted
    object: FinanceInsertInput!

    # upsert condition
    onConflict: FinanceOnConflict
  ): Finance

  # insert data into the table: "follow"
  insertFollow(
    # the rows to be inserted
    objects: [FollowInsertInput!]!

    # upsert condition
    onConflict: FollowOnConflict
  ): FollowMutationResponse

  # insert a single row into the table: "follow"
  insertFollowOne(
    # the row to be inserted
    object: FollowInsertInput!

    # upsert condition
    onConflict: FollowOnConflict
  ): Follow

  # insert data into the table: "form"
  insertForm(
    # the rows to be inserted
    objects: [FormInsertInput!]!

    # upsert condition
    onConflict: FormOnConflict
  ): FormMutationResponse

  # insert a single row into the table: "form"
  insertFormOne(
    # the row to be inserted
    object: FormInsertInput!

    # upsert condition
    onConflict: FormOnConflict
  ): Form

  # insert data into the table: "form_submission"
  insertFormSubmission(
    # the rows to be inserted
    objects: [FormSubmissionInsertInput!]!

    # upsert condition
    onConflict: FormSubmissionOnConflict
  ): FormSubmissionMutationResponse

  # insert a single row into the table: "form_submission"
  insertFormSubmissionOne(
    # the row to be inserted
    object: FormSubmissionInsertInput!

    # upsert condition
    onConflict: FormSubmissionOnConflict
  ): FormSubmission

  # insert data into the table: "grant"
  insertGrant(
    # the rows to be inserted
    objects: [GrantInsertInput!]!

    # upsert condition
    onConflict: GrantOnConflict
  ): GrantMutationResponse

  # insert data into the table: "grant_attachments"
  insertGrantAttachments(
    # the rows to be inserted
    objects: [GrantAttachmentsInsertInput!]!

    # upsert condition
    onConflict: GrantAttachmentsOnConflict
  ): GrantAttachmentsMutationResponse

  # insert a single row into the table: "grant_attachments"
  insertGrantAttachmentsOne(
    # the row to be inserted
    object: GrantAttachmentsInsertInput!

    # upsert condition
    onConflict: GrantAttachmentsOnConflict
  ): GrantAttachments

  # insert a single row into the table: "grant"
  insertGrantOne(
    # the row to be inserted
    object: GrantInsertInput!

    # upsert condition
    onConflict: GrantOnConflict
  ): Grant

  # insert data into the table: "grant_unlock"
  insertGrantUnlock(
    # the rows to be inserted
    objects: [GrantUnlockInsertInput!]!

    # upsert condition
    onConflict: GrantUnlockOnConflict
  ): GrantUnlockMutationResponse

  # insert data into the table: "grant_unlock_attachments"
  insertGrantUnlockAttachments(
    # the rows to be inserted
    objects: [GrantUnlockAttachmentsInsertInput!]!

    # upsert condition
    onConflict: GrantUnlockAttachmentsOnConflict
  ): GrantUnlockAttachmentsMutationResponse

  # insert a single row into the table: "grant_unlock_attachments"
  insertGrantUnlockAttachmentsOne(
    # the row to be inserted
    object: GrantUnlockAttachmentsInsertInput!

    # upsert condition
    onConflict: GrantUnlockAttachmentsOnConflict
  ): GrantUnlockAttachments

  # insert a single row into the table: "grant_unlock"
  insertGrantUnlockOne(
    # the row to be inserted
    object: GrantUnlockInsertInput!

    # upsert condition
    onConflict: GrantUnlockOnConflict
  ): GrantUnlock

  # insert data into the table: "individual"
  insertIndividual(
    # the rows to be inserted
    objects: [IndividualInsertInput!]!

    # upsert condition
    onConflict: IndividualOnConflict
  ): IndividualMutationResponse

  # insert a single row into the table: "individual"
  insertIndividualOne(
    # the row to be inserted
    object: IndividualInsertInput!

    # upsert condition
    onConflict: IndividualOnConflict
  ): Individual

  # insert data into the table: "issue"
  insertIssue(
    # the rows to be inserted
    objects: [IssueInsertInput!]!

    # upsert condition
    onConflict: IssueOnConflict
  ): IssueMutationResponse

  # insert data into the table: "issue_contributors"
  insertIssueContributors(
    # the rows to be inserted
    objects: [IssueContributorsInsertInput!]!

    # upsert condition
    onConflict: IssueContributorsOnConflict
  ): IssueContributorsMutationResponse

  # insert a single row into the table: "issue_contributors"
  insertIssueContributorsOne(
    # the row to be inserted
    object: IssueContributorsInsertInput!

    # upsert condition
    onConflict: IssueContributorsOnConflict
  ): IssueContributors

  # insert a single row into the table: "issue"
  insertIssueOne(
    # the row to be inserted
    object: IssueInsertInput!

    # upsert condition
    onConflict: IssueOnConflict
  ): Issue

  # insert data into the table: "issue_tags"
  insertIssueTags(
    # the rows to be inserted
    objects: [IssueTagsInsertInput!]!

    # upsert condition
    onConflict: IssueTagsOnConflict
  ): IssueTagsMutationResponse

  # insert a single row into the table: "issue_tags"
  insertIssueTagsOne(
    # the row to be inserted
    object: IssueTagsInsertInput!

    # upsert condition
    onConflict: IssueTagsOnConflict
  ): IssueTags

  # insert data into the table: "legal_unit"
  insertLegalUnit(
    # the rows to be inserted
    objects: [LegalUnitInsertInput!]!

    # upsert condition
    onConflict: LegalUnitOnConflict
  ): LegalUnitMutationResponse

  # insert a single row into the table: "legal_unit"
  insertLegalUnitOne(
    # the row to be inserted
    object: LegalUnitInsertInput!

    # upsert condition
    onConflict: LegalUnitOnConflict
  ): LegalUnit

  # insert data into the table: "mission"
  insertMission(
    # the rows to be inserted
    objects: [MissionInsertInput!]!

    # upsert condition
    onConflict: MissionOnConflict
  ): MissionMutationResponse

  # insert data into the table: "mission_join"
  insertMissionJoin(
    # the rows to be inserted
    objects: [MissionJoinInsertInput!]!

    # upsert condition
    onConflict: MissionJoinOnConflict
  ): MissionJoinMutationResponse

  # insert a single row into the table: "mission_join"
  insertMissionJoinOne(
    # the row to be inserted
    object: MissionJoinInsertInput!

    # upsert condition
    onConflict: MissionJoinOnConflict
  ): MissionJoin

  # insert a single row into the table: "mission"
  insertMissionOne(
    # the row to be inserted
    object: MissionInsertInput!

    # upsert condition
    onConflict: MissionOnConflict
  ): Mission

  # insert data into the table: "pole"
  insertPole(
    # the rows to be inserted
    objects: [PoleInsertInput!]!

    # upsert condition
    onConflict: PoleOnConflict
  ): PoleMutationResponse

  # insert a single row into the table: "pole"
  insertPoleOne(
    # the row to be inserted
    object: PoleInsertInput!

    # upsert condition
    onConflict: PoleOnConflict
  ): Pole

  # insert data into the table: "project"
  insertProject(
    # the rows to be inserted
    objects: [ProjectInsertInput!]!

    # upsert condition
    onConflict: ProjectOnConflict
  ): ProjectMutationResponse

  # insert a single row into the table: "project"
  insertProjectOne(
    # the row to be inserted
    object: ProjectInsertInput!

    # upsert condition
    onConflict: ProjectOnConflict
  ): Project

  # insert data into the table: "project_supervisors"
  insertProjectSupervisors(
    # the rows to be inserted
    objects: [ProjectSupervisorsInsertInput!]!

    # upsert condition
    onConflict: ProjectSupervisorsOnConflict
  ): ProjectSupervisorsMutationResponse

  # insert a single row into the table: "project_supervisors"
  insertProjectSupervisorsOne(
    # the row to be inserted
    object: ProjectSupervisorsInsertInput!

    # upsert condition
    onConflict: ProjectSupervisorsOnConflict
  ): ProjectSupervisors

  # insert data into the table: "project_tags"
  insertProjectTags(
    # the rows to be inserted
    objects: [ProjectTagsInsertInput!]!

    # upsert condition
    onConflict: ProjectTagsOnConflict
  ): ProjectTagsMutationResponse

  # insert a single row into the table: "project_tags"
  insertProjectTagsOne(
    # the row to be inserted
    object: ProjectTagsInsertInput!

    # upsert condition
    onConflict: ProjectTagsOnConflict
  ): ProjectTags

  # insert data into the table: "reaction"
  insertReaction(
    # the rows to be inserted
    objects: [ReactionInsertInput!]!

    # upsert condition
    onConflict: ReactionOnConflict
  ): ReactionMutationResponse

  # insert a single row into the table: "reaction"
  insertReactionOne(
    # the row to be inserted
    object: ReactionInsertInput!

    # upsert condition
    onConflict: ReactionOnConflict
  ): Reaction

  # insert data into the table: "report"
  insertReport(
    # the rows to be inserted
    objects: [ReportInsertInput!]!

    # upsert condition
    onConflict: ReportOnConflict
  ): ReportMutationResponse

  # insert a single row into the table: "report"
  insertReportOne(
    # the row to be inserted
    object: ReportInsertInput!

    # upsert condition
    onConflict: ReportOnConflict
  ): Report

  # insert data into the table: "role"
  insertRole(
    # the rows to be inserted
    objects: [RoleInsertInput!]!

    # upsert condition
    onConflict: RoleOnConflict
  ): RoleMutationResponse

  # insert a single row into the table: "role"
  insertRoleOne(
    # the row to be inserted
    object: RoleInsertInput!

    # upsert condition
    onConflict: RoleOnConflict
  ): Role

  # insert data into the table: "session"
  insertSession(
    # the rows to be inserted
    objects: [SessionInsertInput!]!

    # upsert condition
    onConflict: SessionOnConflict
  ): SessionMutationResponse

  # insert a single row into the table: "session"
  insertSessionOne(
    # the row to be inserted
    object: SessionInsertInput!

    # upsert condition
    onConflict: SessionOnConflict
  ): Session

  # insert data into the table: "shortcut"
  insertShortcut(
    # the rows to be inserted
    objects: [ShortcutInsertInput!]!

    # upsert condition
    onConflict: ShortcutOnConflict
  ): ShortcutMutationResponse

  # insert a single row into the table: "shortcut"
  insertShortcutOne(
    # the row to be inserted
    object: ShortcutInsertInput!

    # upsert condition
    onConflict: ShortcutOnConflict
  ): Shortcut

  # insert data into the table: "social"
  insertSocial(
    # the rows to be inserted
    objects: [SocialInsertInput!]!

    # upsert condition
    onConflict: SocialOnConflict
  ): SocialMutationResponse

  # insert a single row into the table: "social"
  insertSocialOne(
    # the row to be inserted
    object: SocialInsertInput!

    # upsert condition
    onConflict: SocialOnConflict
  ): Social

  # insert data into the table: "subject"
  insertSubject(
    # the rows to be inserted
    objects: [SubjectInsertInput!]!

    # upsert condition
    onConflict: SubjectOnConflict
  ): SubjectMutationResponse

  # insert data into the table: "subject_class_groups"
  insertSubjectClassGroups(
    # the rows to be inserted
    objects: [SubjectClassGroupsInsertInput!]!

    # upsert condition
    onConflict: SubjectClassGroupsOnConflict
  ): SubjectClassGroupsMutationResponse

  # insert a single row into the table: "subject_class_groups"
  insertSubjectClassGroupsOne(
    # the row to be inserted
    object: SubjectClassGroupsInsertInput!

    # upsert condition
    onConflict: SubjectClassGroupsOnConflict
  ): SubjectClassGroups

  # insert a single row into the table: "subject"
  insertSubjectOne(
    # the row to be inserted
    object: SubjectInsertInput!

    # upsert condition
    onConflict: SubjectOnConflict
  ): Subject

  # insert data into the table: "tag"
  insertTag(
    # the rows to be inserted
    objects: [TagInsertInput!]!

    # upsert condition
    onConflict: TagOnConflict
  ): TagMutationResponse

  # insert a single row into the table: "tag"
  insertTagOne(
    # the row to be inserted
    object: TagInsertInput!

    # upsert condition
    onConflict: TagOnConflict
  ): Tag

  # insert data into the table: "team"
  insertTeam(
    # the rows to be inserted
    objects: [TeamInsertInput!]!

    # upsert condition
    onConflict: TeamOnConflict
  ): TeamMutationResponse

  # insert data into the table: "team_history"
  insertTeamHistory(
    # the rows to be inserted
    objects: [TeamHistoryInsertInput!]!

    # upsert condition
    onConflict: TeamHistoryOnConflict
  ): TeamHistoryMutationResponse

  # insert a single row into the table: "team_history"
  insertTeamHistoryOne(
    # the row to be inserted
    object: TeamHistoryInsertInput!

    # upsert condition
    onConflict: TeamHistoryOnConflict
  ): TeamHistory

  # insert data into the table: "team_join"
  insertTeamJoin(
    # the rows to be inserted
    objects: [TeamJoinInsertInput!]!

    # upsert condition
    onConflict: TeamJoinOnConflict
  ): TeamJoinMutationResponse

  # insert a single row into the table: "team_join"
  insertTeamJoinOne(
    # the row to be inserted
    object: TeamJoinInsertInput!

    # upsert condition
    onConflict: TeamJoinOnConflict
  ): TeamJoin

  # insert data into the table: "team_member"
  insertTeamMember(
    # the rows to be inserted
    objects: [TeamMemberInsertInput!]!

    # upsert condition
    onConflict: TeamMemberOnConflict
  ): TeamMemberMutationResponse

  # insert a single row into the table: "team_member"
  insertTeamMemberOne(
    # the row to be inserted
    object: TeamMemberInsertInput!

    # upsert condition
    onConflict: TeamMemberOnConflict
  ): TeamMember

  # insert data into the table: "team_member_roles"
  insertTeamMemberRoles(
    # the rows to be inserted
    objects: [TeamMemberRolesInsertInput!]!

    # upsert condition
    onConflict: TeamMemberRolesOnConflict
  ): TeamMemberRolesMutationResponse

  # insert a single row into the table: "team_member_roles"
  insertTeamMemberRolesOne(
    # the row to be inserted
    object: TeamMemberRolesInsertInput!

    # upsert condition
    onConflict: TeamMemberRolesOnConflict
  ): TeamMemberRoles

  # insert data into the table: "team_metric"
  insertTeamMetric(
    # the rows to be inserted
    objects: [TeamMetricInsertInput!]!

    # upsert condition
    onConflict: TeamMetricOnConflict
  ): TeamMetricMutationResponse

  # insert a single row into the table: "team_metric"
  insertTeamMetricOne(
    # the row to be inserted
    object: TeamMetricInsertInput!

    # upsert condition
    onConflict: TeamMetricOnConflict
  ): TeamMetric

  # insert a single row into the table: "team"
  insertTeamOne(
    # the row to be inserted
    object: TeamInsertInput!

    # upsert condition
    onConflict: TeamOnConflict
  ): Team

  # insert data into the table: "tenant"
  insertTenant(
    # the rows to be inserted
    objects: [TenantInsertInput!]!

    # upsert condition
    onConflict: TenantOnConflict
  ): TenantMutationResponse

  # insert data into the table: "tenant_manage"
  insertTenantManage(
    # the rows to be inserted
    objects: [TenantManageInsertInput!]!

    # upsert condition
    onConflict: TenantManageOnConflict
  ): TenantManageMutationResponse

  # insert a single row into the table: "tenant_manage"
  insertTenantManageOne(
    # the row to be inserted
    object: TenantManageInsertInput!

    # upsert condition
    onConflict: TenantManageOnConflict
  ): TenantManage

  # insert a single row into the table: "tenant"
  insertTenantOne(
    # the row to be inserted
    object: TenantInsertInput!

    # upsert condition
    onConflict: TenantOnConflict
  ): Tenant

  # insert data into the table: "thread"
  insertThread(
    # the rows to be inserted
    objects: [ThreadInsertInput!]!

    # upsert condition
    onConflict: ThreadOnConflict
  ): ThreadMutationResponse

  # insert data into the table: "thread_contributors"
  insertThreadContributors(
    # the rows to be inserted
    objects: [ThreadContributorsInsertInput!]!

    # upsert condition
    onConflict: ThreadContributorsOnConflict
  ): ThreadContributorsMutationResponse

  # insert a single row into the table: "thread_contributors"
  insertThreadContributorsOne(
    # the row to be inserted
    object: ThreadContributorsInsertInput!

    # upsert condition
    onConflict: ThreadContributorsOnConflict
  ): ThreadContributors

  # insert a single row into the table: "thread"
  insertThreadOne(
    # the row to be inserted
    object: ThreadInsertInput!

    # upsert condition
    onConflict: ThreadOnConflict
  ): Thread

  # insert data into the table: "thread_tags"
  insertThreadTags(
    # the rows to be inserted
    objects: [ThreadTagsInsertInput!]!

    # upsert condition
    onConflict: ThreadTagsOnConflict
  ): ThreadTagsMutationResponse

  # insert a single row into the table: "thread_tags"
  insertThreadTagsOne(
    # the row to be inserted
    object: ThreadTagsInsertInput!

    # upsert condition
    onConflict: ThreadTagsOnConflict
  ): ThreadTags

  # insert data into the table: "user"
  insertUser(
    # the rows to be inserted
    objects: [UserInsertInput!]!

    # upsert condition
    onConflict: UserOnConflict
  ): UserMutationResponse

  # insert a single row into the table: "user"
  insertUserOne(
    # the row to be inserted
    object: UserInsertInput!

    # upsert condition
    onConflict: UserOnConflict
  ): User

  # insert data into the table: "validation"
  insertValidation(
    # the rows to be inserted
    objects: [ValidationInsertInput!]!

    # upsert condition
    onConflict: ValidationOnConflict
  ): ValidationMutationResponse

  # insert a single row into the table: "validation"
  insertValidationOne(
    # the row to be inserted
    object: ValidationInsertInput!

    # upsert condition
    onConflict: ValidationOnConflict
  ): Validation

  # insert data into the table: "vote"
  insertVote(
    # the rows to be inserted
    objects: [VoteInsertInput!]!

    # upsert condition
    onConflict: VoteOnConflict
  ): VoteMutationResponse

  # insert a single row into the table: "vote"
  insertVoteOne(
    # the row to be inserted
    object: VoteInsertInput!

    # upsert condition
    onConflict: VoteOnConflict
  ): Vote

  # update data of the table: "account"
  updateAccount(
    # increments the numeric columns with given value of the filtered values
    _inc: AccountIncInput

    # sets the columns of the filtered rows to the given values
    _set: AccountSetInput

    # filter the rows which have to be updated
    where: AccountBoolExp!
  ): AccountMutationResponse

  # update data of the table: "account_allocate"
  updateAccountAllocate(
    # increments the numeric columns with given value of the filtered values
    _inc: AccountAllocateIncInput

    # sets the columns of the filtered rows to the given values
    _set: AccountAllocateSetInput

    # filter the rows which have to be updated
    where: AccountAllocateBoolExp!
  ): AccountAllocateMutationResponse

  # update single row of the table: "account_allocate"
  updateAccountAllocateByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: AccountAllocateIncInput

    # sets the columns of the filtered rows to the given values
    _set: AccountAllocateSetInput
    pkColumns: AccountAllocatePkColumnsInput!
  ): AccountAllocate

  # update multiples rows of table: "account_allocate"
  updateAccountAllocateMany(
    # updates to execute, in order
    updates: [AccountAllocateUpdates!]!
  ): [AccountAllocateMutationResponse]

  # update single row of the table: "account"
  updateAccountByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: AccountIncInput

    # sets the columns of the filtered rows to the given values
    _set: AccountSetInput
    pkColumns: AccountPkColumnsInput!
  ): Account

  # update multiples rows of table: "account"
  updateAccountMany(
    # updates to execute, in order
    updates: [AccountUpdates!]!
  ): [AccountMutationResponse]

  # update data of the table: "action"
  updateAction(
    # increments the numeric columns with given value of the filtered values
    _inc: ActionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActionSetInput

    # filter the rows which have to be updated
    where: ActionBoolExp!
  ): ActionMutationResponse

  # update single row of the table: "action"
  updateActionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActionSetInput
    pkColumns: ActionPkColumnsInput!
  ): Action

  # update multiples rows of table: "action"
  updateActionMany(
    # updates to execute, in order
    updates: [ActionUpdates!]!
  ): [ActionMutationResponse]

  # update data of the table: "actor"
  updateActor(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorSetInput

    # filter the rows which have to be updated
    where: ActorBoolExp!
  ): ActorMutationResponse

  # update single row of the table: "actor"
  updateActorByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorSetInput
    pkColumns: ActorPkColumnsInput!
  ): Actor

  # update data of the table: "actor_image"
  updateActorImage(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorImageIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorImageSetInput

    # filter the rows which have to be updated
    where: ActorImageBoolExp!
  ): ActorImageMutationResponse

  # update single row of the table: "actor_image"
  updateActorImageByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorImageIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorImageSetInput
    pkColumns: ActorImagePkColumnsInput!
  ): ActorImage

  # update multiples rows of table: "actor_image"
  updateActorImageMany(
    # updates to execute, in order
    updates: [ActorImageUpdates!]!
  ): [ActorImageMutationResponse]

  # update multiples rows of table: "actor"
  updateActorMany(
    # updates to execute, in order
    updates: [ActorUpdates!]!
  ): [ActorMutationResponse]

  # update data of the table: "actor_tags"
  updateActorTags(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorTagsSetInput

    # filter the rows which have to be updated
    where: ActorTagsBoolExp!
  ): ActorTagsMutationResponse

  # update single row of the table: "actor_tags"
  updateActorTagsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorTagsSetInput
    pkColumns: ActorTagsPkColumnsInput!
  ): ActorTags

  # update multiples rows of table: "actor_tags"
  updateActorTagsMany(
    # updates to execute, in order
    updates: [ActorTagsUpdates!]!
  ): [ActorTagsMutationResponse]

  # update data of the table: "address"
  updateAddress(
    # increments the numeric columns with given value of the filtered values
    _inc: AddressIncInput

    # sets the columns of the filtered rows to the given values
    _set: AddressSetInput

    # filter the rows which have to be updated
    where: AddressBoolExp!
  ): AddressMutationResponse

  # update single row of the table: "address"
  updateAddressByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: AddressIncInput

    # sets the columns of the filtered rows to the given values
    _set: AddressSetInput
    pkColumns: AddressPkColumnsInput!
  ): Address

  # update multiples rows of table: "address"
  updateAddressMany(
    # updates to execute, in order
    updates: [AddressUpdates!]!
  ): [AddressMutationResponse]

  # update data of the table: "bank_info"
  updateBankInfo(
    # increments the numeric columns with given value of the filtered values
    _inc: BankInfoIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankInfoSetInput

    # filter the rows which have to be updated
    where: BankInfoBoolExp!
  ): BankInfoMutationResponse

  # update single row of the table: "bank_info"
  updateBankInfoByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: BankInfoIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankInfoSetInput
    pkColumns: BankInfoPkColumnsInput!
  ): BankInfo

  # update multiples rows of table: "bank_info"
  updateBankInfoMany(
    # updates to execute, in order
    updates: [BankInfoUpdates!]!
  ): [BankInfoMutationResponse]

  # update data of the table: "bot"
  updateBot(
    # increments the numeric columns with given value of the filtered values
    _inc: BotIncInput

    # sets the columns of the filtered rows to the given values
    _set: BotSetInput

    # filter the rows which have to be updated
    where: BotBoolExp!
  ): BotMutationResponse

  # update single row of the table: "bot"
  updateBotByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: BotIncInput

    # sets the columns of the filtered rows to the given values
    _set: BotSetInput
    pkColumns: BotPkColumnsInput!
  ): Bot

  # update multiples rows of table: "bot"
  updateBotMany(
    # updates to execute, in order
    updates: [BotUpdates!]!
  ): [BotMutationResponse]

  # update data of the table: "campus"
  updateCampus(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusSetInput

    # filter the rows which have to be updated
    where: CampusBoolExp!
  ): CampusMutationResponse

  # update single row of the table: "campus"
  updateCampusByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusSetInput
    pkColumns: CampusPkColumnsInput!
  ): Campus

  # update data of the table: "campus_cluster"
  updateCampusCluster(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusClusterIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusClusterSetInput

    # filter the rows which have to be updated
    where: CampusClusterBoolExp!
  ): CampusClusterMutationResponse

  # update single row of the table: "campus_cluster"
  updateCampusClusterByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusClusterIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusClusterSetInput
    pkColumns: CampusClusterPkColumnsInput!
  ): CampusCluster

  # update multiples rows of table: "campus_cluster"
  updateCampusClusterMany(
    # updates to execute, in order
    updates: [CampusClusterUpdates!]!
  ): [CampusClusterMutationResponse]

  # update multiples rows of table: "campus"
  updateCampusMany(
    # updates to execute, in order
    updates: [CampusUpdates!]!
  ): [CampusMutationResponse]

  # update data of the table: "canteen"
  updateCanteen(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenSetInput

    # filter the rows which have to be updated
    where: CanteenBoolExp!
  ): CanteenMutationResponse

  # update single row of the table: "canteen"
  updateCanteenByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenSetInput
    pkColumns: CanteenPkColumnsInput!
  ): Canteen

  # update data of the table: "canteen_food"
  updateCanteenFood(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenFoodIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenFoodSetInput

    # filter the rows which have to be updated
    where: CanteenFoodBoolExp!
  ): CanteenFoodMutationResponse

  # update single row of the table: "canteen_food"
  updateCanteenFoodByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenFoodIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenFoodSetInput
    pkColumns: CanteenFoodPkColumnsInput!
  ): CanteenFood

  # update multiples rows of table: "canteen_food"
  updateCanteenFoodMany(
    # updates to execute, in order
    updates: [CanteenFoodUpdates!]!
  ): [CanteenFoodMutationResponse]

  # update multiples rows of table: "canteen"
  updateCanteenMany(
    # updates to execute, in order
    updates: [CanteenUpdates!]!
  ): [CanteenMutationResponse]

  # update data of the table: "canteen_menu"
  updateCanteenMenu(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenMenuIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenMenuSetInput

    # filter the rows which have to be updated
    where: CanteenMenuBoolExp!
  ): CanteenMenuMutationResponse

  # update single row of the table: "canteen_menu"
  updateCanteenMenuByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CanteenMenuIncInput

    # sets the columns of the filtered rows to the given values
    _set: CanteenMenuSetInput
    pkColumns: CanteenMenuPkColumnsInput!
  ): CanteenMenu

  # update multiples rows of table: "canteen_menu"
  updateCanteenMenuMany(
    # updates to execute, in order
    updates: [CanteenMenuUpdates!]!
  ): [CanteenMenuMutationResponse]

  # update data of the table: "class_group"
  updateClassGroup(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupSetInput

    # filter the rows which have to be updated
    where: ClassGroupBoolExp!
  ): ClassGroupMutationResponse

  # update single row of the table: "class_group"
  updateClassGroupByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupSetInput
    pkColumns: ClassGroupPkColumnsInput!
  ): ClassGroup

  # update multiples rows of table: "class_group"
  updateClassGroupMany(
    # updates to execute, in order
    updates: [ClassGroupUpdates!]!
  ): [ClassGroupMutationResponse]

  # update data of the table: "class_group_teacher"
  updateClassGroupTeacher(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupTeacherIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupTeacherSetInput

    # filter the rows which have to be updated
    where: ClassGroupTeacherBoolExp!
  ): ClassGroupTeacherMutationResponse

  # update single row of the table: "class_group_teacher"
  updateClassGroupTeacherByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupTeacherIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupTeacherSetInput
    pkColumns: ClassGroupTeacherPkColumnsInput!
  ): ClassGroupTeacher

  # update multiples rows of table: "class_group_teacher"
  updateClassGroupTeacherMany(
    # updates to execute, in order
    updates: [ClassGroupTeacherUpdates!]!
  ): [ClassGroupTeacherMutationResponse]

  # update data of the table: "class_group_teacher_subjects"
  updateClassGroupTeacherSubjects(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupTeacherSubjectsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupTeacherSubjectsSetInput

    # filter the rows which have to be updated
    where: ClassGroupTeacherSubjectsBoolExp!
  ): ClassGroupTeacherSubjectsMutationResponse

  # update single row of the table: "class_group_teacher_subjects"
  updateClassGroupTeacherSubjectsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ClassGroupTeacherSubjectsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ClassGroupTeacherSubjectsSetInput
    pkColumns: ClassGroupTeacherSubjectsPkColumnsInput!
  ): ClassGroupTeacherSubjects

  # update multiples rows of table: "class_group_teacher_subjects"
  updateClassGroupTeacherSubjectsMany(
    # updates to execute, in order
    updates: [ClassGroupTeacherSubjectsUpdates!]!
  ): [ClassGroupTeacherSubjectsMutationResponse]

  # update data of the table: "cohort"
  updateCohort(
    # increments the numeric columns with given value of the filtered values
    _inc: CohortIncInput

    # sets the columns of the filtered rows to the given values
    _set: CohortSetInput

    # filter the rows which have to be updated
    where: CohortBoolExp!
  ): CohortMutationResponse

  # update single row of the table: "cohort"
  updateCohortByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CohortIncInput

    # sets the columns of the filtered rows to the given values
    _set: CohortSetInput
    pkColumns: CohortPkColumnsInput!
  ): Cohort

  # update multiples rows of table: "cohort"
  updateCohortMany(
    # updates to execute, in order
    updates: [CohortUpdates!]!
  ): [CohortMutationResponse]

  # update data of the table: "content"
  updateContent(
    # increments the numeric columns with given value of the filtered values
    _inc: ContentIncInput

    # sets the columns of the filtered rows to the given values
    _set: ContentSetInput

    # filter the rows which have to be updated
    where: ContentBoolExp!
  ): ContentMutationResponse

  # update data of the table: "content_attachments"
  updateContentAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: ContentAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ContentAttachmentsSetInput

    # filter the rows which have to be updated
    where: ContentAttachmentsBoolExp!
  ): ContentAttachmentsMutationResponse

  # update single row of the table: "content_attachments"
  updateContentAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ContentAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ContentAttachmentsSetInput
    pkColumns: ContentAttachmentsPkColumnsInput!
  ): ContentAttachments

  # update multiples rows of table: "content_attachments"
  updateContentAttachmentsMany(
    # updates to execute, in order
    updates: [ContentAttachmentsUpdates!]!
  ): [ContentAttachmentsMutationResponse]

  # update single row of the table: "content"
  updateContentByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ContentIncInput

    # sets the columns of the filtered rows to the given values
    _set: ContentSetInput
    pkColumns: ContentPkColumnsInput!
  ): Content

  # update multiples rows of table: "content"
  updateContentMany(
    # updates to execute, in order
    updates: [ContentUpdates!]!
  ): [ContentMutationResponse]

  # update data of the table: "document"
  updateDocument(
    # increments the numeric columns with given value of the filtered values
    _inc: DocumentIncInput

    # sets the columns of the filtered rows to the given values
    _set: DocumentSetInput

    # filter the rows which have to be updated
    where: DocumentBoolExp!
  ): DocumentMutationResponse

  # update single row of the table: "document"
  updateDocumentByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: DocumentIncInput

    # sets the columns of the filtered rows to the given values
    _set: DocumentSetInput
    pkColumns: DocumentPkColumnsInput!
  ): Document

  # update multiples rows of table: "document"
  updateDocumentMany(
    # updates to execute, in order
    updates: [DocumentUpdates!]!
  ): [DocumentMutationResponse]

  # update data of the table: "event"
  updateEvent(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: EventAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: EventDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: EventDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: EventDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: EventIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: EventPrependInput

    # sets the columns of the filtered rows to the given values
    _set: EventSetInput

    # filter the rows which have to be updated
    where: EventBoolExp!
  ): EventMutationResponse

  # update data of the table: "event_approval"
  updateEventApproval(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalSetInput

    # filter the rows which have to be updated
    where: EventApprovalBoolExp!
  ): EventApprovalMutationResponse

  # update single row of the table: "event_approval"
  updateEventApprovalByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalSetInput
    pkColumns: EventApprovalPkColumnsInput!
  ): EventApproval

  # update multiples rows of table: "event_approval"
  updateEventApprovalMany(
    # updates to execute, in order
    updates: [EventApprovalUpdates!]!
  ): [EventApprovalMutationResponse]

  # update data of the table: "event_approval_step"
  updateEventApprovalStep(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepBoolExp!
  ): EventApprovalStepMutationResponse

  # update single row of the table: "event_approval_step"
  updateEventApprovalStepByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepSetInput
    pkColumns: EventApprovalStepPkColumnsInput!
  ): EventApprovalStep

  # update multiples rows of table: "event_approval_step"
  updateEventApprovalStepMany(
    # updates to execute, in order
    updates: [EventApprovalStepUpdates!]!
  ): [EventApprovalStepMutationResponse]

  # update data of the table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifiees(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepNotifieesIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepNotifieesSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepNotifieesBoolExp!
  ): EventApprovalStepNotifieesMutationResponse

  # update single row of the table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifieesByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepNotifieesIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepNotifieesSetInput
    pkColumns: EventApprovalStepNotifieesPkColumnsInput!
  ): EventApprovalStepNotifiees

  # update multiples rows of table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifieesMany(
    # updates to execute, in order
    updates: [EventApprovalStepNotifieesUpdates!]!
  ): [EventApprovalStepNotifieesMutationResponse]

  # update data of the table: "event_approval_step_validators"
  updateEventApprovalStepValidators(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepValidatorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepValidatorsSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepValidatorsBoolExp!
  ): EventApprovalStepValidatorsMutationResponse

  # update single row of the table: "event_approval_step_validators"
  updateEventApprovalStepValidatorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepValidatorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepValidatorsSetInput
    pkColumns: EventApprovalStepValidatorsPkColumnsInput!
  ): EventApprovalStepValidators

  # update multiples rows of table: "event_approval_step_validators"
  updateEventApprovalStepValidatorsMany(
    # updates to execute, in order
    updates: [EventApprovalStepValidatorsUpdates!]!
  ): [EventApprovalStepValidatorsMutationResponse]

  # update single row of the table: "event"
  updateEventByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: EventAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: EventDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: EventDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: EventDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: EventIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: EventPrependInput

    # sets the columns of the filtered rows to the given values
    _set: EventSetInput
    pkColumns: EventPkColumnsInput!
  ): Event

  # update data of the table: "event_join"
  updateEventJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: EventJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventJoinSetInput

    # filter the rows which have to be updated
    where: EventJoinBoolExp!
  ): EventJoinMutationResponse

  # update single row of the table: "event_join"
  updateEventJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventJoinSetInput
    pkColumns: EventJoinPkColumnsInput!
  ): EventJoin

  # update multiples rows of table: "event_join"
  updateEventJoinMany(
    # updates to execute, in order
    updates: [EventJoinUpdates!]!
  ): [EventJoinMutationResponse]

  # update data of the table: "event_manage"
  updateEventManage(
    # increments the numeric columns with given value of the filtered values
    _inc: EventManageIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventManageSetInput

    # filter the rows which have to be updated
    where: EventManageBoolExp!
  ): EventManageMutationResponse

  # update single row of the table: "event_manage"
  updateEventManageByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventManageIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventManageSetInput
    pkColumns: EventManagePkColumnsInput!
  ): EventManage

  # update multiples rows of table: "event_manage"
  updateEventManageMany(
    # updates to execute, in order
    updates: [EventManageUpdates!]!
  ): [EventManageMutationResponse]

  # update multiples rows of table: "event"
  updateEventMany(
    # updates to execute, in order
    updates: [EventUpdates!]!
  ): [EventMutationResponse]

  # update data of the table: "event_supervisors"
  updateEventSupervisors(
    # increments the numeric columns with given value of the filtered values
    _inc: EventSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventSupervisorsSetInput

    # filter the rows which have to be updated
    where: EventSupervisorsBoolExp!
  ): EventSupervisorsMutationResponse

  # update single row of the table: "event_supervisors"
  updateEventSupervisorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventSupervisorsSetInput
    pkColumns: EventSupervisorsPkColumnsInput!
  ): EventSupervisors

  # update multiples rows of table: "event_supervisors"
  updateEventSupervisorsMany(
    # updates to execute, in order
    updates: [EventSupervisorsUpdates!]!
  ): [EventSupervisorsMutationResponse]

  # update data of the table: "event_tags"
  updateEventTags(
    # increments the numeric columns with given value of the filtered values
    _inc: EventTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventTagsSetInput

    # filter the rows which have to be updated
    where: EventTagsBoolExp!
  ): EventTagsMutationResponse

  # update single row of the table: "event_tags"
  updateEventTagsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventTagsSetInput
    pkColumns: EventTagsPkColumnsInput!
  ): EventTags

  # update multiples rows of table: "event_tags"
  updateEventTagsMany(
    # updates to execute, in order
    updates: [EventTagsUpdates!]!
  ): [EventTagsMutationResponse]

  # update data of the table: "expense"
  updateExpense(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseSetInput

    # filter the rows which have to be updated
    where: ExpenseBoolExp!
  ): ExpenseMutationResponse

  # update single row of the table: "expense"
  updateExpenseByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseSetInput
    pkColumns: ExpensePkColumnsInput!
  ): Expense

  # update data of the table: "expense_item"
  updateExpenseItem(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemSetInput

    # filter the rows which have to be updated
    where: ExpenseItemBoolExp!
  ): ExpenseItemMutationResponse

  # update data of the table: "expense_item_attachments"
  updateExpenseItemAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemAttachmentsSetInput

    # filter the rows which have to be updated
    where: ExpenseItemAttachmentsBoolExp!
  ): ExpenseItemAttachmentsMutationResponse

  # update single row of the table: "expense_item_attachments"
  updateExpenseItemAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemAttachmentsSetInput
    pkColumns: ExpenseItemAttachmentsPkColumnsInput!
  ): ExpenseItemAttachments

  # update multiples rows of table: "expense_item_attachments"
  updateExpenseItemAttachmentsMany(
    # updates to execute, in order
    updates: [ExpenseItemAttachmentsUpdates!]!
  ): [ExpenseItemAttachmentsMutationResponse]

  # update single row of the table: "expense_item"
  updateExpenseItemByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemSetInput
    pkColumns: ExpenseItemPkColumnsInput!
  ): ExpenseItem

  # update multiples rows of table: "expense_item"
  updateExpenseItemMany(
    # updates to execute, in order
    updates: [ExpenseItemUpdates!]!
  ): [ExpenseItemMutationResponse]

  # update multiples rows of table: "expense"
  updateExpenseMany(
    # updates to execute, in order
    updates: [ExpenseUpdates!]!
  ): [ExpenseMutationResponse]

  # update data of the table: "favorite"
  updateFavorite(
    # increments the numeric columns with given value of the filtered values
    _inc: FavoriteIncInput

    # sets the columns of the filtered rows to the given values
    _set: FavoriteSetInput

    # filter the rows which have to be updated
    where: FavoriteBoolExp!
  ): FavoriteMutationResponse

  # update single row of the table: "favorite"
  updateFavoriteByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FavoriteIncInput

    # sets the columns of the filtered rows to the given values
    _set: FavoriteSetInput
    pkColumns: FavoritePkColumnsInput!
  ): Favorite

  # update multiples rows of table: "favorite"
  updateFavoriteMany(
    # updates to execute, in order
    updates: [FavoriteUpdates!]!
  ): [FavoriteMutationResponse]

  # update data of the table: "file_upload"
  updateFileUpload(
    # increments the numeric columns with given value of the filtered values
    _inc: FileUploadIncInput

    # sets the columns of the filtered rows to the given values
    _set: FileUploadSetInput

    # filter the rows which have to be updated
    where: FileUploadBoolExp!
  ): FileUploadMutationResponse

  # update single row of the table: "file_upload"
  updateFileUploadByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FileUploadIncInput

    # sets the columns of the filtered rows to the given values
    _set: FileUploadSetInput
    pkColumns: FileUploadPkColumnsInput!
  ): FileUpload

  # update multiples rows of table: "file_upload"
  updateFileUploadMany(
    # updates to execute, in order
    updates: [FileUploadUpdates!]!
  ): [FileUploadMutationResponse]

  # update data of the table: "finance"
  updateFinance(
    # increments the numeric columns with given value of the filtered values
    _inc: FinanceIncInput

    # sets the columns of the filtered rows to the given values
    _set: FinanceSetInput

    # filter the rows which have to be updated
    where: FinanceBoolExp!
  ): FinanceMutationResponse

  # update data of the table: "finance_attachments"
  updateFinanceAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: FinanceAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: FinanceAttachmentsSetInput

    # filter the rows which have to be updated
    where: FinanceAttachmentsBoolExp!
  ): FinanceAttachmentsMutationResponse

  # update single row of the table: "finance_attachments"
  updateFinanceAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FinanceAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: FinanceAttachmentsSetInput
    pkColumns: FinanceAttachmentsPkColumnsInput!
  ): FinanceAttachments

  # update multiples rows of table: "finance_attachments"
  updateFinanceAttachmentsMany(
    # updates to execute, in order
    updates: [FinanceAttachmentsUpdates!]!
  ): [FinanceAttachmentsMutationResponse]

  # update single row of the table: "finance"
  updateFinanceByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FinanceIncInput

    # sets the columns of the filtered rows to the given values
    _set: FinanceSetInput
    pkColumns: FinancePkColumnsInput!
  ): Finance

  # update multiples rows of table: "finance"
  updateFinanceMany(
    # updates to execute, in order
    updates: [FinanceUpdates!]!
  ): [FinanceMutationResponse]

  # update data of the table: "follow"
  updateFollow(
    # increments the numeric columns with given value of the filtered values
    _inc: FollowIncInput

    # sets the columns of the filtered rows to the given values
    _set: FollowSetInput

    # filter the rows which have to be updated
    where: FollowBoolExp!
  ): FollowMutationResponse

  # update single row of the table: "follow"
  updateFollowByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FollowIncInput

    # sets the columns of the filtered rows to the given values
    _set: FollowSetInput
    pkColumns: FollowPkColumnsInput!
  ): Follow

  # update multiples rows of table: "follow"
  updateFollowMany(
    # updates to execute, in order
    updates: [FollowUpdates!]!
  ): [FollowMutationResponse]

  # update data of the table: "form"
  updateForm(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSetInput

    # filter the rows which have to be updated
    where: FormBoolExp!
  ): FormMutationResponse

  # update single row of the table: "form"
  updateFormByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSetInput
    pkColumns: FormPkColumnsInput!
  ): Form

  # update multiples rows of table: "form"
  updateFormMany(
    # updates to execute, in order
    updates: [FormUpdates!]!
  ): [FormMutationResponse]

  # update data of the table: "form_submission"
  updateFormSubmission(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormSubmissionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormSubmissionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormSubmissionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormSubmissionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormSubmissionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionSetInput

    # filter the rows which have to be updated
    where: FormSubmissionBoolExp!
  ): FormSubmissionMutationResponse

  # update single row of the table: "form_submission"
  updateFormSubmissionByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormSubmissionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormSubmissionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormSubmissionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormSubmissionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormSubmissionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionSetInput
    pkColumns: FormSubmissionPkColumnsInput!
  ): FormSubmission

  # update multiples rows of table: "form_submission"
  updateFormSubmissionMany(
    # updates to execute, in order
    updates: [FormSubmissionUpdates!]!
  ): [FormSubmissionMutationResponse]

  # update data of the table: "grant"
  updateGrant(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantSetInput

    # filter the rows which have to be updated
    where: GrantBoolExp!
  ): GrantMutationResponse

  # update data of the table: "grant_attachments"
  updateGrantAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAttachmentsSetInput

    # filter the rows which have to be updated
    where: GrantAttachmentsBoolExp!
  ): GrantAttachmentsMutationResponse

  # update single row of the table: "grant_attachments"
  updateGrantAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAttachmentsSetInput
    pkColumns: GrantAttachmentsPkColumnsInput!
  ): GrantAttachments

  # update multiples rows of table: "grant_attachments"
  updateGrantAttachmentsMany(
    # updates to execute, in order
    updates: [GrantAttachmentsUpdates!]!
  ): [GrantAttachmentsMutationResponse]

  # update single row of the table: "grant"
  updateGrantByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantSetInput
    pkColumns: GrantPkColumnsInput!
  ): Grant

  # update multiples rows of table: "grant"
  updateGrantMany(
    # updates to execute, in order
    updates: [GrantUpdates!]!
  ): [GrantMutationResponse]

  # update data of the table: "grant_unlock"
  updateGrantUnlock(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantUnlockIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantUnlockSetInput

    # filter the rows which have to be updated
    where: GrantUnlockBoolExp!
  ): GrantUnlockMutationResponse

  # update data of the table: "grant_unlock_attachments"
  updateGrantUnlockAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantUnlockAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantUnlockAttachmentsSetInput

    # filter the rows which have to be updated
    where: GrantUnlockAttachmentsBoolExp!
  ): GrantUnlockAttachmentsMutationResponse

  # update single row of the table: "grant_unlock_attachments"
  updateGrantUnlockAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantUnlockAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantUnlockAttachmentsSetInput
    pkColumns: GrantUnlockAttachmentsPkColumnsInput!
  ): GrantUnlockAttachments

  # update multiples rows of table: "grant_unlock_attachments"
  updateGrantUnlockAttachmentsMany(
    # updates to execute, in order
    updates: [GrantUnlockAttachmentsUpdates!]!
  ): [GrantUnlockAttachmentsMutationResponse]

  # update single row of the table: "grant_unlock"
  updateGrantUnlockByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantUnlockIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantUnlockSetInput
    pkColumns: GrantUnlockPkColumnsInput!
  ): GrantUnlock

  # update multiples rows of table: "grant_unlock"
  updateGrantUnlockMany(
    # updates to execute, in order
    updates: [GrantUnlockUpdates!]!
  ): [GrantUnlockMutationResponse]

  # update data of the table: "individual"
  updateIndividual(
    # increments the numeric columns with given value of the filtered values
    _inc: IndividualIncInput

    # sets the columns of the filtered rows to the given values
    _set: IndividualSetInput

    # filter the rows which have to be updated
    where: IndividualBoolExp!
  ): IndividualMutationResponse

  # update single row of the table: "individual"
  updateIndividualByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: IndividualIncInput

    # sets the columns of the filtered rows to the given values
    _set: IndividualSetInput
    pkColumns: IndividualPkColumnsInput!
  ): Individual

  # update multiples rows of table: "individual"
  updateIndividualMany(
    # updates to execute, in order
    updates: [IndividualUpdates!]!
  ): [IndividualMutationResponse]

  # update data of the table: "issue"
  updateIssue(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueSetInput

    # filter the rows which have to be updated
    where: IssueBoolExp!
  ): IssueMutationResponse

  # update single row of the table: "issue"
  updateIssueByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueSetInput
    pkColumns: IssuePkColumnsInput!
  ): Issue

  # update data of the table: "issue_contributors"
  updateIssueContributors(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueContributorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueContributorsSetInput

    # filter the rows which have to be updated
    where: IssueContributorsBoolExp!
  ): IssueContributorsMutationResponse

  # update single row of the table: "issue_contributors"
  updateIssueContributorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueContributorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueContributorsSetInput
    pkColumns: IssueContributorsPkColumnsInput!
  ): IssueContributors

  # update multiples rows of table: "issue_contributors"
  updateIssueContributorsMany(
    # updates to execute, in order
    updates: [IssueContributorsUpdates!]!
  ): [IssueContributorsMutationResponse]

  # update multiples rows of table: "issue"
  updateIssueMany(
    # updates to execute, in order
    updates: [IssueUpdates!]!
  ): [IssueMutationResponse]

  # update data of the table: "issue_tags"
  updateIssueTags(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueTagsSetInput

    # filter the rows which have to be updated
    where: IssueTagsBoolExp!
  ): IssueTagsMutationResponse

  # update single row of the table: "issue_tags"
  updateIssueTagsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: IssueTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: IssueTagsSetInput
    pkColumns: IssueTagsPkColumnsInput!
  ): IssueTags

  # update multiples rows of table: "issue_tags"
  updateIssueTagsMany(
    # updates to execute, in order
    updates: [IssueTagsUpdates!]!
  ): [IssueTagsMutationResponse]

  # update data of the table: "legal_unit"
  updateLegalUnit(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitSetInput

    # filter the rows which have to be updated
    where: LegalUnitBoolExp!
  ): LegalUnitMutationResponse

  # update single row of the table: "legal_unit"
  updateLegalUnitByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitSetInput
    pkColumns: LegalUnitPkColumnsInput!
  ): LegalUnit

  # update multiples rows of table: "legal_unit"
  updateLegalUnitMany(
    # updates to execute, in order
    updates: [LegalUnitUpdates!]!
  ): [LegalUnitMutationResponse]

  # update data of the table: "mission"
  updateMission(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionSetInput

    # filter the rows which have to be updated
    where: MissionBoolExp!
  ): MissionMutationResponse

  # update single row of the table: "mission"
  updateMissionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionSetInput
    pkColumns: MissionPkColumnsInput!
  ): Mission

  # update data of the table: "mission_join"
  updateMissionJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionJoinSetInput

    # filter the rows which have to be updated
    where: MissionJoinBoolExp!
  ): MissionJoinMutationResponse

  # update single row of the table: "mission_join"
  updateMissionJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionJoinSetInput
    pkColumns: MissionJoinPkColumnsInput!
  ): MissionJoin

  # update multiples rows of table: "mission_join"
  updateMissionJoinMany(
    # updates to execute, in order
    updates: [MissionJoinUpdates!]!
  ): [MissionJoinMutationResponse]

  # update multiples rows of table: "mission"
  updateMissionMany(
    # updates to execute, in order
    updates: [MissionUpdates!]!
  ): [MissionMutationResponse]

  # update data of the table: "pole"
  updatePole(
    # increments the numeric columns with given value of the filtered values
    _inc: PoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: PoleSetInput

    # filter the rows which have to be updated
    where: PoleBoolExp!
  ): PoleMutationResponse

  # update single row of the table: "pole"
  updatePoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: PoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: PoleSetInput
    pkColumns: PolePkColumnsInput!
  ): Pole

  # update multiples rows of table: "pole"
  updatePoleMany(
    # updates to execute, in order
    updates: [PoleUpdates!]!
  ): [PoleMutationResponse]

  # update data of the table: "project"
  updateProject(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSetInput

    # filter the rows which have to be updated
    where: ProjectBoolExp!
  ): ProjectMutationResponse

  # update single row of the table: "project"
  updateProjectByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSetInput
    pkColumns: ProjectPkColumnsInput!
  ): Project

  # update multiples rows of table: "project"
  updateProjectMany(
    # updates to execute, in order
    updates: [ProjectUpdates!]!
  ): [ProjectMutationResponse]

  # update data of the table: "project_supervisors"
  updateProjectSupervisors(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSupervisorsSetInput

    # filter the rows which have to be updated
    where: ProjectSupervisorsBoolExp!
  ): ProjectSupervisorsMutationResponse

  # update single row of the table: "project_supervisors"
  updateProjectSupervisorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSupervisorsSetInput
    pkColumns: ProjectSupervisorsPkColumnsInput!
  ): ProjectSupervisors

  # update multiples rows of table: "project_supervisors"
  updateProjectSupervisorsMany(
    # updates to execute, in order
    updates: [ProjectSupervisorsUpdates!]!
  ): [ProjectSupervisorsMutationResponse]

  # update data of the table: "project_tags"
  updateProjectTags(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectTagsSetInput

    # filter the rows which have to be updated
    where: ProjectTagsBoolExp!
  ): ProjectTagsMutationResponse

  # update single row of the table: "project_tags"
  updateProjectTagsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectTagsSetInput
    pkColumns: ProjectTagsPkColumnsInput!
  ): ProjectTags

  # update multiples rows of table: "project_tags"
  updateProjectTagsMany(
    # updates to execute, in order
    updates: [ProjectTagsUpdates!]!
  ): [ProjectTagsMutationResponse]

  # update data of the table: "reaction"
  updateReaction(
    # increments the numeric columns with given value of the filtered values
    _inc: ReactionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ReactionSetInput

    # filter the rows which have to be updated
    where: ReactionBoolExp!
  ): ReactionMutationResponse

  # update single row of the table: "reaction"
  updateReactionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ReactionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ReactionSetInput
    pkColumns: ReactionPkColumnsInput!
  ): Reaction

  # update multiples rows of table: "reaction"
  updateReactionMany(
    # updates to execute, in order
    updates: [ReactionUpdates!]!
  ): [ReactionMutationResponse]

  # update data of the table: "report"
  updateReport(
    # increments the numeric columns with given value of the filtered values
    _inc: ReportIncInput

    # sets the columns of the filtered rows to the given values
    _set: ReportSetInput

    # filter the rows which have to be updated
    where: ReportBoolExp!
  ): ReportMutationResponse

  # update single row of the table: "report"
  updateReportByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ReportIncInput

    # sets the columns of the filtered rows to the given values
    _set: ReportSetInput
    pkColumns: ReportPkColumnsInput!
  ): Report

  # update multiples rows of table: "report"
  updateReportMany(
    # updates to execute, in order
    updates: [ReportUpdates!]!
  ): [ReportMutationResponse]

  # update data of the table: "role"
  updateRole(
    # increments the numeric columns with given value of the filtered values
    _inc: RoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: RoleSetInput

    # filter the rows which have to be updated
    where: RoleBoolExp!
  ): RoleMutationResponse

  # update single row of the table: "role"
  updateRoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: RoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: RoleSetInput
    pkColumns: RolePkColumnsInput!
  ): Role

  # update multiples rows of table: "role"
  updateRoleMany(
    # updates to execute, in order
    updates: [RoleUpdates!]!
  ): [RoleMutationResponse]

  # update data of the table: "session"
  updateSession(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: SessionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: SessionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: SessionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: SessionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: SessionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: SessionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: SessionSetInput

    # filter the rows which have to be updated
    where: SessionBoolExp!
  ): SessionMutationResponse

  # update single row of the table: "session"
  updateSessionByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: SessionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: SessionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: SessionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: SessionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: SessionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: SessionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: SessionSetInput
    pkColumns: SessionPkColumnsInput!
  ): Session

  # update multiples rows of table: "session"
  updateSessionMany(
    # updates to execute, in order
    updates: [SessionUpdates!]!
  ): [SessionMutationResponse]

  # update data of the table: "shortcut"
  updateShortcut(
    # increments the numeric columns with given value of the filtered values
    _inc: ShortcutIncInput

    # sets the columns of the filtered rows to the given values
    _set: ShortcutSetInput

    # filter the rows which have to be updated
    where: ShortcutBoolExp!
  ): ShortcutMutationResponse

  # update single row of the table: "shortcut"
  updateShortcutByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ShortcutIncInput

    # sets the columns of the filtered rows to the given values
    _set: ShortcutSetInput
    pkColumns: ShortcutPkColumnsInput!
  ): Shortcut

  # update multiples rows of table: "shortcut"
  updateShortcutMany(
    # updates to execute, in order
    updates: [ShortcutUpdates!]!
  ): [ShortcutMutationResponse]

  # update data of the table: "social"
  updateSocial(
    # increments the numeric columns with given value of the filtered values
    _inc: SocialIncInput

    # sets the columns of the filtered rows to the given values
    _set: SocialSetInput

    # filter the rows which have to be updated
    where: SocialBoolExp!
  ): SocialMutationResponse

  # update single row of the table: "social"
  updateSocialByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: SocialIncInput

    # sets the columns of the filtered rows to the given values
    _set: SocialSetInput
    pkColumns: SocialPkColumnsInput!
  ): Social

  # update multiples rows of table: "social"
  updateSocialMany(
    # updates to execute, in order
    updates: [SocialUpdates!]!
  ): [SocialMutationResponse]

  # update data of the table: "subject"
  updateSubject(
    # increments the numeric columns with given value of the filtered values
    _inc: SubjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: SubjectSetInput

    # filter the rows which have to be updated
    where: SubjectBoolExp!
  ): SubjectMutationResponse

  # update single row of the table: "subject"
  updateSubjectByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: SubjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: SubjectSetInput
    pkColumns: SubjectPkColumnsInput!
  ): Subject

  # update data of the table: "subject_class_groups"
  updateSubjectClassGroups(
    # increments the numeric columns with given value of the filtered values
    _inc: SubjectClassGroupsIncInput

    # sets the columns of the filtered rows to the given values
    _set: SubjectClassGroupsSetInput

    # filter the rows which have to be updated
    where: SubjectClassGroupsBoolExp!
  ): SubjectClassGroupsMutationResponse

  # update single row of the table: "subject_class_groups"
  updateSubjectClassGroupsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: SubjectClassGroupsIncInput

    # sets the columns of the filtered rows to the given values
    _set: SubjectClassGroupsSetInput
    pkColumns: SubjectClassGroupsPkColumnsInput!
  ): SubjectClassGroups

  # update multiples rows of table: "subject_class_groups"
  updateSubjectClassGroupsMany(
    # updates to execute, in order
    updates: [SubjectClassGroupsUpdates!]!
  ): [SubjectClassGroupsMutationResponse]

  # update multiples rows of table: "subject"
  updateSubjectMany(
    # updates to execute, in order
    updates: [SubjectUpdates!]!
  ): [SubjectMutationResponse]

  # update data of the table: "tag"
  updateTag(
    # increments the numeric columns with given value of the filtered values
    _inc: TagIncInput

    # sets the columns of the filtered rows to the given values
    _set: TagSetInput

    # filter the rows which have to be updated
    where: TagBoolExp!
  ): TagMutationResponse

  # update single row of the table: "tag"
  updateTagByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TagIncInput

    # sets the columns of the filtered rows to the given values
    _set: TagSetInput
    pkColumns: TagPkColumnsInput!
  ): Tag

  # update multiples rows of table: "tag"
  updateTagMany(
    # updates to execute, in order
    updates: [TagUpdates!]!
  ): [TagMutationResponse]

  # update data of the table: "team"
  updateTeam(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamSetInput

    # filter the rows which have to be updated
    where: TeamBoolExp!
  ): TeamMutationResponse

  # update single row of the table: "team"
  updateTeamByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamSetInput
    pkColumns: TeamPkColumnsInput!
  ): Team

  # update data of the table: "team_history"
  updateTeamHistory(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamHistoryIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamHistorySetInput

    # filter the rows which have to be updated
    where: TeamHistoryBoolExp!
  ): TeamHistoryMutationResponse

  # update single row of the table: "team_history"
  updateTeamHistoryByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamHistoryIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamHistorySetInput
    pkColumns: TeamHistoryPkColumnsInput!
  ): TeamHistory

  # update multiples rows of table: "team_history"
  updateTeamHistoryMany(
    # updates to execute, in order
    updates: [TeamHistoryUpdates!]!
  ): [TeamHistoryMutationResponse]

  # update data of the table: "team_join"
  updateTeamJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamJoinSetInput

    # filter the rows which have to be updated
    where: TeamJoinBoolExp!
  ): TeamJoinMutationResponse

  # update single row of the table: "team_join"
  updateTeamJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamJoinSetInput
    pkColumns: TeamJoinPkColumnsInput!
  ): TeamJoin

  # update multiples rows of table: "team_join"
  updateTeamJoinMany(
    # updates to execute, in order
    updates: [TeamJoinUpdates!]!
  ): [TeamJoinMutationResponse]

  # update multiples rows of table: "team"
  updateTeamMany(
    # updates to execute, in order
    updates: [TeamUpdates!]!
  ): [TeamMutationResponse]

  # update data of the table: "team_member"
  updateTeamMember(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberSetInput

    # filter the rows which have to be updated
    where: TeamMemberBoolExp!
  ): TeamMemberMutationResponse

  # update single row of the table: "team_member"
  updateTeamMemberByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberSetInput
    pkColumns: TeamMemberPkColumnsInput!
  ): TeamMember

  # update multiples rows of table: "team_member"
  updateTeamMemberMany(
    # updates to execute, in order
    updates: [TeamMemberUpdates!]!
  ): [TeamMemberMutationResponse]

  # update data of the table: "team_member_roles"
  updateTeamMemberRoles(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberRolesIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberRolesSetInput

    # filter the rows which have to be updated
    where: TeamMemberRolesBoolExp!
  ): TeamMemberRolesMutationResponse

  # update single row of the table: "team_member_roles"
  updateTeamMemberRolesByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberRolesIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberRolesSetInput
    pkColumns: TeamMemberRolesPkColumnsInput!
  ): TeamMemberRoles

  # update multiples rows of table: "team_member_roles"
  updateTeamMemberRolesMany(
    # updates to execute, in order
    updates: [TeamMemberRolesUpdates!]!
  ): [TeamMemberRolesMutationResponse]

  # update data of the table: "team_metric"
  updateTeamMetric(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMetricIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMetricSetInput

    # filter the rows which have to be updated
    where: TeamMetricBoolExp!
  ): TeamMetricMutationResponse

  # update single row of the table: "team_metric"
  updateTeamMetricByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMetricIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMetricSetInput
    pkColumns: TeamMetricPkColumnsInput!
  ): TeamMetric

  # update multiples rows of table: "team_metric"
  updateTeamMetricMany(
    # updates to execute, in order
    updates: [TeamMetricUpdates!]!
  ): [TeamMetricMutationResponse]

  # update data of the table: "tenant"
  updateTenant(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantSetInput

    # filter the rows which have to be updated
    where: TenantBoolExp!
  ): TenantMutationResponse

  # update single row of the table: "tenant"
  updateTenantByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantSetInput
    pkColumns: TenantPkColumnsInput!
  ): Tenant

  # update data of the table: "tenant_manage"
  updateTenantManage(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantManageIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantManageSetInput

    # filter the rows which have to be updated
    where: TenantManageBoolExp!
  ): TenantManageMutationResponse

  # update single row of the table: "tenant_manage"
  updateTenantManageByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantManageIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantManageSetInput
    pkColumns: TenantManagePkColumnsInput!
  ): TenantManage

  # update multiples rows of table: "tenant_manage"
  updateTenantManageMany(
    # updates to execute, in order
    updates: [TenantManageUpdates!]!
  ): [TenantManageMutationResponse]

  # update multiples rows of table: "tenant"
  updateTenantMany(
    # updates to execute, in order
    updates: [TenantUpdates!]!
  ): [TenantMutationResponse]

  # update data of the table: "thread"
  updateThread(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadSetInput

    # filter the rows which have to be updated
    where: ThreadBoolExp!
  ): ThreadMutationResponse

  # update single row of the table: "thread"
  updateThreadByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadSetInput
    pkColumns: ThreadPkColumnsInput!
  ): Thread

  # update data of the table: "thread_contributors"
  updateThreadContributors(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadContributorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadContributorsSetInput

    # filter the rows which have to be updated
    where: ThreadContributorsBoolExp!
  ): ThreadContributorsMutationResponse

  # update single row of the table: "thread_contributors"
  updateThreadContributorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadContributorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadContributorsSetInput
    pkColumns: ThreadContributorsPkColumnsInput!
  ): ThreadContributors

  # update multiples rows of table: "thread_contributors"
  updateThreadContributorsMany(
    # updates to execute, in order
    updates: [ThreadContributorsUpdates!]!
  ): [ThreadContributorsMutationResponse]

  # update multiples rows of table: "thread"
  updateThreadMany(
    # updates to execute, in order
    updates: [ThreadUpdates!]!
  ): [ThreadMutationResponse]

  # update data of the table: "thread_tags"
  updateThreadTags(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadTagsSetInput

    # filter the rows which have to be updated
    where: ThreadTagsBoolExp!
  ): ThreadTagsMutationResponse

  # update single row of the table: "thread_tags"
  updateThreadTagsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ThreadTagsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ThreadTagsSetInput
    pkColumns: ThreadTagsPkColumnsInput!
  ): ThreadTags

  # update multiples rows of table: "thread_tags"
  updateThreadTagsMany(
    # updates to execute, in order
    updates: [ThreadTagsUpdates!]!
  ): [ThreadTagsMutationResponse]

  # update data of the table: "user"
  updateUser(
    # increments the numeric columns with given value of the filtered values
    _inc: UserIncInput

    # sets the columns of the filtered rows to the given values
    _set: UserSetInput

    # filter the rows which have to be updated
    where: UserBoolExp!
  ): UserMutationResponse

  # update single row of the table: "user"
  updateUserByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: UserIncInput

    # sets the columns of the filtered rows to the given values
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  # update multiples rows of table: "user"
  updateUserMany(
    # updates to execute, in order
    updates: [UserUpdates!]!
  ): [UserMutationResponse]

  # update data of the table: "validation"
  updateValidation(
    # increments the numeric columns with given value of the filtered values
    _inc: ValidationIncInput

    # sets the columns of the filtered rows to the given values
    _set: ValidationSetInput

    # filter the rows which have to be updated
    where: ValidationBoolExp!
  ): ValidationMutationResponse

  # update single row of the table: "validation"
  updateValidationByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ValidationIncInput

    # sets the columns of the filtered rows to the given values
    _set: ValidationSetInput
    pkColumns: ValidationPkColumnsInput!
  ): Validation

  # update multiples rows of table: "validation"
  updateValidationMany(
    # updates to execute, in order
    updates: [ValidationUpdates!]!
  ): [ValidationMutationResponse]

  # update data of the table: "vote"
  updateVote(
    # increments the numeric columns with given value of the filtered values
    _inc: VoteIncInput

    # sets the columns of the filtered rows to the given values
    _set: VoteSetInput

    # filter the rows which have to be updated
    where: VoteBoolExp!
  ): VoteMutationResponse

  # update single row of the table: "vote"
  updateVoteByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: VoteIncInput

    # sets the columns of the filtered rows to the given values
    _set: VoteSetInput
    pkColumns: VotePkColumnsInput!
  ): Vote

  # update multiples rows of table: "vote"
  updateVoteMany(
    # updates to execute, in order
    updates: [VoteUpdates!]!
  ): [VoteMutationResponse]
}

# column ordering options
enum OrderBy {
  # in ascending order, nulls last
  ASC

  # in ascending order, nulls first
  ASC_NULLS_FIRST

  # in ascending order, nulls last
  ASC_NULLS_LAST

  # in descending order, nulls first
  DESC

  # in descending order, nulls first
  DESC_NULLS_FIRST

  # in descending order, nulls last
  DESC_NULLS_LAST
}

# columns and relationships of "pole"
type Pole {
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  hiddenAt: timestamptz
  id: bigint!
  isRequired: Boolean!
  name: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "pole"
type PoleAggregate {
  aggregate: PoleAggregateFields
  nodes: [Pole!]!
}

input PoleAggregateBoolExp {
  bool_and: poleAggregateBoolExpBool_and
  bool_or: poleAggregateBoolExpBool_or
  count: poleAggregateBoolExpCount
}

input poleAggregateBoolExpBool_and {
  arguments: PoleSelectColumnPoleAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PoleBoolExp
  predicate: BooleanComparisonExp!
}

input poleAggregateBoolExpBool_or {
  arguments: PoleSelectColumnPoleAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PoleBoolExp
  predicate: BooleanComparisonExp!
}

input poleAggregateBoolExpCount {
  arguments: [PoleSelectColumn!]
  distinct: Boolean
  filter: PoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "pole"
type PoleAggregateFields {
  avg: PoleAvgFields
  count(columns: [PoleSelectColumn!], distinct: Boolean): Int!
  max: PoleMaxFields
  min: PoleMinFields
  stddev: PoleStddevFields
  stddevPop: PoleStddevPopFields
  stddevSamp: PoleStddevSampFields
  sum: PoleSumFields
  varPop: PoleVarPopFields
  varSamp: PoleVarSampFields
  variance: PoleVarianceFields
}

# order by aggregate values of table "pole"
input PoleAggregateOrderBy {
  avg: PoleAvgOrderBy
  count: OrderBy
  max: PoleMaxOrderBy
  min: PoleMinOrderBy
  stddev: PoleStddevOrderBy
  stddevPop: PoleStddevPopOrderBy
  stddevSamp: PoleStddevSampOrderBy
  sum: PoleSumOrderBy
  varPop: PoleVarPopOrderBy
  varSamp: PoleVarSampOrderBy
  variance: PoleVarianceOrderBy
}

# input type for inserting array relation for remote table "pole"
input PoleArrRelInsertInput {
  data: [PoleInsertInput!]!

  # upsert condition
  onConflict: PoleOnConflict
}

# aggregate avg on columns
type PoleAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "pole"
input PoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "pole". All fields are combined with a logical 'AND'.
input PoleBoolExp {
  _and: [PoleBoolExp!]
  _not: PoleBoolExp
  _or: [PoleBoolExp!]
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isRequired: BooleanComparisonExp
  name: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "pole"
enum PoleConstraint {
  # unique or primary key constraint on columns "id"
  pole_pkey
}

# input type for incrementing numeric columns in table "pole"
input PoleIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "pole"
input PoleInsertInput {
  category: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  team: TeamObjRelInsertInput
  teamId: bigint
  teamJoins: TeamJoinArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type PoleMaxFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "pole"
input PoleMaxOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type PoleMinFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "pole"
input PoleMinOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "pole"
type PoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Pole!]!
}

# input type for inserting object relation for remote table "pole"
input PoleObjRelInsertInput {
  data: PoleInsertInput!

  # upsert condition
  onConflict: PoleOnConflict
}

# on_conflict condition type for table "pole"
input PoleOnConflict {
  constraint: PoleConstraint!
  updateColumns: [PoleUpdateColumn!]! = []
  where: PoleBoolExp
}

# Ordering options when selecting data from "pole".
input PoleOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isRequired: OrderBy
  name: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: pole
input PolePkColumnsInput {
  id: bigint!
}

# select columns of table "pole"
enum PoleSelectColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  isRequired

  # column name
  name

  # column name
  teamId

  # column name
  tenantId
}

# select "poleAggregateBoolExpBool_andArgumentsColumns" columns of table "pole"
enum PoleSelectColumnPoleAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isRequired
}

# select "poleAggregateBoolExpBool_orArgumentsColumns" columns of table "pole"
enum PoleSelectColumnPoleAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isRequired
}

# input type for updating data in table "pole"
input PoleSetInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type PoleStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "pole"
input PoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type PoleStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "pole"
input PoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type PoleStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "pole"
input PoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "pole"
input PoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: PoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input PoleStreamCursorValueInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type PoleSumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "pole"
input PoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "pole"
enum PoleUpdateColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  isRequired

  # column name
  name

  # column name
  teamId

  # column name
  tenantId
}

input PoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: PoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: PoleSetInput

  # filter the rows which have to be updated
  where: PoleBoolExp!
}

# aggregate variance on columns
type PoleVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "pole"
input PoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type PoleVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "pole"
input PoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type PoleVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "pole"
input PoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "project"
type Project {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  banner: FileUpload
  bannerId: bigint
  budget: Float!
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  finances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  financesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An object relationship
  grant: Grant
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isPrivate: Boolean!
  isTemplate: Boolean!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!
  name: String!

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # An array relationship
  projectTags(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): [ProjectTags!]!

  # An aggregate relationship
  projectTagsAggregate(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): ProjectTagsAggregate!
  regularEventInterval: String!
  slug: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "project"
type ProjectAggregate {
  aggregate: ProjectAggregateFields
  nodes: [Project!]!
}

input ProjectAggregateBoolExp {
  bool_and: projectAggregateBoolExpBool_and
  bool_or: projectAggregateBoolExpBool_or
  count: projectAggregateBoolExpCount
}

input projectAggregateBoolExpBool_and {
  arguments: ProjectSelectColumnProjectAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: BooleanComparisonExp!
}

input projectAggregateBoolExpBool_or {
  arguments: ProjectSelectColumnProjectAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: BooleanComparisonExp!
}

input projectAggregateBoolExpCount {
  arguments: [ProjectSelectColumn!]
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "project"
type ProjectAggregateFields {
  avg: ProjectAvgFields
  count(columns: [ProjectSelectColumn!], distinct: Boolean): Int!
  max: ProjectMaxFields
  min: ProjectMinFields
  stddev: ProjectStddevFields
  stddevPop: ProjectStddevPopFields
  stddevSamp: ProjectStddevSampFields
  sum: ProjectSumFields
  varPop: ProjectVarPopFields
  varSamp: ProjectVarSampFields
  variance: ProjectVarianceFields
}

# order by aggregate values of table "project"
input ProjectAggregateOrderBy {
  avg: ProjectAvgOrderBy
  count: OrderBy
  max: ProjectMaxOrderBy
  min: ProjectMinOrderBy
  stddev: ProjectStddevOrderBy
  stddevPop: ProjectStddevPopOrderBy
  stddevSamp: ProjectStddevSampOrderBy
  sum: ProjectSumOrderBy
  varPop: ProjectVarPopOrderBy
  varSamp: ProjectVarSampOrderBy
  variance: ProjectVarianceOrderBy
}

# input type for inserting array relation for remote table "project"
input ProjectArrRelInsertInput {
  data: [ProjectInsertInput!]!

  # upsert condition
  onConflict: ProjectOnConflict
}

# aggregate avg on columns
type ProjectAvgFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "project"
input ProjectAvgOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "project". All fields are combined with a logical 'AND'.
input ProjectBoolExp {
  _and: [ProjectBoolExp!]
  _not: ProjectBoolExp
  _or: [ProjectBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  banner: FileUploadBoolExp
  bannerId: BigintComparisonExp
  budget: FloatComparisonExp
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  finances: FinanceBoolExp
  financesAggregate: FinanceAggregateBoolExp
  grant: GrantBoolExp
  grantId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isPrivate: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  name: StringComparisonExp
  projectSupervisors: ProjectSupervisorsBoolExp
  projectSupervisorsAggregate: ProjectSupervisorsAggregateBoolExp
  projectTags: ProjectTagsBoolExp
  projectTagsAggregate: ProjectTagsAggregateBoolExp
  regularEventInterval: StringComparisonExp
  slug: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "project"
enum ProjectConstraint {
  # unique or primary key constraint on columns "id"
  project_pkey
}

# input type for incrementing numeric columns in table "project"
input ProjectIncInput {
  bannerId: bigint
  budget: Float
  createdById: bigint
  grantId: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "project"
input ProjectInsertInput {
  actions: ActionArrRelInsertInput
  banner: FileUploadObjRelInsertInput
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  events: EventArrRelInsertInput
  finances: FinanceArrRelInsertInput
  grant: GrantObjRelInsertInput
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  missionJoins: MissionJoinArrRelInsertInput
  missions: MissionArrRelInsertInput
  name: String
  projectSupervisors: ProjectSupervisorsArrRelInsertInput
  projectTags: ProjectTagsArrRelInsertInput
  regularEventInterval: String
  slug: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type ProjectMaxFields {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  regularEventInterval: String
  slug: String
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "project"
input ProjectMaxOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type ProjectMinFields {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  regularEventInterval: String
  slug: String
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "project"
input ProjectMinOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "project"
type ProjectMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Project!]!
}

# input type for inserting object relation for remote table "project"
input ProjectObjRelInsertInput {
  data: ProjectInsertInput!

  # upsert condition
  onConflict: ProjectOnConflict
}

# on_conflict condition type for table "project"
input ProjectOnConflict {
  constraint: ProjectConstraint!
  updateColumns: [ProjectUpdateColumn!]! = []
  where: ProjectBoolExp
}

# Ordering options when selecting data from "project".
input ProjectOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  banner: FileUploadOrderBy
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventsAggregate: EventAggregateOrderBy
  financesAggregate: FinanceAggregateOrderBy
  grant: GrantOrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isPrivate: OrderBy
  isTemplate: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  missionsAggregate: MissionAggregateOrderBy
  name: OrderBy
  projectSupervisorsAggregate: ProjectSupervisorsAggregateOrderBy
  projectTagsAggregate: ProjectTagsAggregateOrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: project
input ProjectPkColumnsInput {
  id: bigint!
}

# select columns of table "project"
enum ProjectSelectColumn {
  # column name
  bannerId

  # column name
  budget

  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  name

  # column name
  regularEventInterval

  # column name
  slug

  # column name
  teamId

  # column name
  tenantId
}

# select "projectAggregateBoolExpBool_andArgumentsColumns" columns of table "project"
enum ProjectSelectColumnProjectAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isPrivate

  # column name
  isTemplate
}

# select "projectAggregateBoolExpBool_orArgumentsColumns" columns of table "project"
enum ProjectSelectColumnProjectAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isPrivate

  # column name
  isTemplate
}

# input type for updating data in table "project"
input ProjectSetInput {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  name: String
  regularEventInterval: String
  slug: String
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type ProjectStddevFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "project"
input ProjectStddevOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ProjectStddevPopFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "project"
input ProjectStddevPopOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ProjectStddevSampFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "project"
input ProjectStddevSampOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "project"
input ProjectStreamCursorInput {
  # Stream column input with initial value
  initialValue: ProjectStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ProjectStreamCursorValueInput {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  name: String
  regularEventInterval: String
  slug: String
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type ProjectSumFields {
  bannerId: bigint
  budget: Float
  createdById: bigint
  grantId: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "project"
input ProjectSumOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "project_supervisors"
type ProjectSupervisors {
  # An object relationship
  project: Project!
  projectId: bigint!

  # An object relationship
  teamMember: TeamMember!
  teamMemberId: bigint!
}

# aggregated selection of "project_supervisors"
type ProjectSupervisorsAggregate {
  aggregate: ProjectSupervisorsAggregateFields
  nodes: [ProjectSupervisors!]!
}

input ProjectSupervisorsAggregateBoolExp {
  count: projectSupervisorsAggregateBoolExpCount
}

input projectSupervisorsAggregateBoolExpCount {
  arguments: [ProjectSupervisorsSelectColumn!]
  distinct: Boolean
  filter: ProjectSupervisorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "project_supervisors"
type ProjectSupervisorsAggregateFields {
  avg: ProjectSupervisorsAvgFields
  count(columns: [ProjectSupervisorsSelectColumn!], distinct: Boolean): Int!
  max: ProjectSupervisorsMaxFields
  min: ProjectSupervisorsMinFields
  stddev: ProjectSupervisorsStddevFields
  stddevPop: ProjectSupervisorsStddevPopFields
  stddevSamp: ProjectSupervisorsStddevSampFields
  sum: ProjectSupervisorsSumFields
  varPop: ProjectSupervisorsVarPopFields
  varSamp: ProjectSupervisorsVarSampFields
  variance: ProjectSupervisorsVarianceFields
}

# order by aggregate values of table "project_supervisors"
input ProjectSupervisorsAggregateOrderBy {
  avg: ProjectSupervisorsAvgOrderBy
  count: OrderBy
  max: ProjectSupervisorsMaxOrderBy
  min: ProjectSupervisorsMinOrderBy
  stddev: ProjectSupervisorsStddevOrderBy
  stddevPop: ProjectSupervisorsStddevPopOrderBy
  stddevSamp: ProjectSupervisorsStddevSampOrderBy
  sum: ProjectSupervisorsSumOrderBy
  varPop: ProjectSupervisorsVarPopOrderBy
  varSamp: ProjectSupervisorsVarSampOrderBy
  variance: ProjectSupervisorsVarianceOrderBy
}

# input type for inserting array relation for remote table "project_supervisors"
input ProjectSupervisorsArrRelInsertInput {
  data: [ProjectSupervisorsInsertInput!]!

  # upsert condition
  onConflict: ProjectSupervisorsOnConflict
}

# aggregate avg on columns
type ProjectSupervisorsAvgFields {
  projectId: Float
  teamMemberId: Float
}

# order by avg() on columns of table "project_supervisors"
input ProjectSupervisorsAvgOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# Boolean expression to filter rows from the table "project_supervisors". All fields are combined with a logical 'AND'.
input ProjectSupervisorsBoolExp {
  _and: [ProjectSupervisorsBoolExp!]
  _not: ProjectSupervisorsBoolExp
  _or: [ProjectSupervisorsBoolExp!]
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  teamMember: TeamMemberBoolExp
  teamMemberId: BigintComparisonExp
}

# unique or primary key constraints on table "project_supervisors"
enum ProjectSupervisorsConstraint {
  # unique or primary key constraint on columns "project_id", "team_member_id"
  project_supervisors_pkey
}

# input type for incrementing numeric columns in table "project_supervisors"
input ProjectSupervisorsIncInput {
  projectId: bigint
  teamMemberId: bigint
}

# input type for inserting data into table "project_supervisors"
input ProjectSupervisorsInsertInput {
  project: ProjectObjRelInsertInput
  projectId: bigint
  teamMember: TeamMemberObjRelInsertInput
  teamMemberId: bigint
}

# aggregate max on columns
type ProjectSupervisorsMaxFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by max() on columns of table "project_supervisors"
input ProjectSupervisorsMaxOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate min on columns
type ProjectSupervisorsMinFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by min() on columns of table "project_supervisors"
input ProjectSupervisorsMinOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# response of any mutation on the table "project_supervisors"
type ProjectSupervisorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ProjectSupervisors!]!
}

# on_conflict condition type for table "project_supervisors"
input ProjectSupervisorsOnConflict {
  constraint: ProjectSupervisorsConstraint!
  updateColumns: [ProjectSupervisorsUpdateColumn!]! = []
  where: ProjectSupervisorsBoolExp
}

# Ordering options when selecting data from "project_supervisors".
input ProjectSupervisorsOrderBy {
  project: ProjectOrderBy
  projectId: OrderBy
  teamMember: TeamMemberOrderBy
  teamMemberId: OrderBy
}

# primary key columns input for table: project_supervisors
input ProjectSupervisorsPkColumnsInput {
  projectId: bigint!
  teamMemberId: bigint!
}

# select columns of table "project_supervisors"
enum ProjectSupervisorsSelectColumn {
  # column name
  projectId

  # column name
  teamMemberId
}

# input type for updating data in table "project_supervisors"
input ProjectSupervisorsSetInput {
  projectId: bigint
  teamMemberId: bigint
}

# aggregate stddev on columns
type ProjectSupervisorsStddevFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddev() on columns of table "project_supervisors"
input ProjectSupervisorsStddevOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevPop on columns
type ProjectSupervisorsStddevPopFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddevPop() on columns of table "project_supervisors"
input ProjectSupervisorsStddevPopOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevSamp on columns
type ProjectSupervisorsStddevSampFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddevSamp() on columns of table "project_supervisors"
input ProjectSupervisorsStddevSampOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# Streaming cursor of the table "project_supervisors"
input ProjectSupervisorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ProjectSupervisorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ProjectSupervisorsStreamCursorValueInput {
  projectId: bigint
  teamMemberId: bigint
}

# aggregate sum on columns
type ProjectSupervisorsSumFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by sum() on columns of table "project_supervisors"
input ProjectSupervisorsSumOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# update columns of table "project_supervisors"
enum ProjectSupervisorsUpdateColumn {
  # column name
  projectId

  # column name
  teamMemberId
}

input ProjectSupervisorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ProjectSupervisorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ProjectSupervisorsSetInput

  # filter the rows which have to be updated
  where: ProjectSupervisorsBoolExp!
}

# aggregate variance on columns
type ProjectSupervisorsVarianceFields {
  projectId: Float
  teamMemberId: Float
}

# order by variance() on columns of table "project_supervisors"
input ProjectSupervisorsVarianceOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varPop on columns
type ProjectSupervisorsVarPopFields {
  projectId: Float
  teamMemberId: Float
}

# order by varPop() on columns of table "project_supervisors"
input ProjectSupervisorsVarPopOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varSamp on columns
type ProjectSupervisorsVarSampFields {
  projectId: Float
  teamMemberId: Float
}

# order by varSamp() on columns of table "project_supervisors"
input ProjectSupervisorsVarSampOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# columns and relationships of "project_tags"
type ProjectTags {
  # An object relationship
  project: Project!
  projectId: bigint!

  # An object relationship
  tag: Tag!
  tagId: bigint!
}

# aggregated selection of "project_tags"
type ProjectTagsAggregate {
  aggregate: ProjectTagsAggregateFields
  nodes: [ProjectTags!]!
}

input ProjectTagsAggregateBoolExp {
  count: projectTagsAggregateBoolExpCount
}

input projectTagsAggregateBoolExpCount {
  arguments: [ProjectTagsSelectColumn!]
  distinct: Boolean
  filter: ProjectTagsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "project_tags"
type ProjectTagsAggregateFields {
  avg: ProjectTagsAvgFields
  count(columns: [ProjectTagsSelectColumn!], distinct: Boolean): Int!
  max: ProjectTagsMaxFields
  min: ProjectTagsMinFields
  stddev: ProjectTagsStddevFields
  stddevPop: ProjectTagsStddevPopFields
  stddevSamp: ProjectTagsStddevSampFields
  sum: ProjectTagsSumFields
  varPop: ProjectTagsVarPopFields
  varSamp: ProjectTagsVarSampFields
  variance: ProjectTagsVarianceFields
}

# order by aggregate values of table "project_tags"
input ProjectTagsAggregateOrderBy {
  avg: ProjectTagsAvgOrderBy
  count: OrderBy
  max: ProjectTagsMaxOrderBy
  min: ProjectTagsMinOrderBy
  stddev: ProjectTagsStddevOrderBy
  stddevPop: ProjectTagsStddevPopOrderBy
  stddevSamp: ProjectTagsStddevSampOrderBy
  sum: ProjectTagsSumOrderBy
  varPop: ProjectTagsVarPopOrderBy
  varSamp: ProjectTagsVarSampOrderBy
  variance: ProjectTagsVarianceOrderBy
}

# input type for inserting array relation for remote table "project_tags"
input ProjectTagsArrRelInsertInput {
  data: [ProjectTagsInsertInput!]!

  # upsert condition
  onConflict: ProjectTagsOnConflict
}

# aggregate avg on columns
type ProjectTagsAvgFields {
  projectId: Float
  tagId: Float
}

# order by avg() on columns of table "project_tags"
input ProjectTagsAvgOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# Boolean expression to filter rows from the table "project_tags". All fields are combined with a logical 'AND'.
input ProjectTagsBoolExp {
  _and: [ProjectTagsBoolExp!]
  _not: ProjectTagsBoolExp
  _or: [ProjectTagsBoolExp!]
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  tag: TagBoolExp
  tagId: BigintComparisonExp
}

# unique or primary key constraints on table "project_tags"
enum ProjectTagsConstraint {
  # unique or primary key constraint on columns "project_id", "tag_id"
  project_tags_pkey
}

# input type for incrementing numeric columns in table "project_tags"
input ProjectTagsIncInput {
  projectId: bigint
  tagId: bigint
}

# input type for inserting data into table "project_tags"
input ProjectTagsInsertInput {
  project: ProjectObjRelInsertInput
  projectId: bigint
  tag: TagObjRelInsertInput
  tagId: bigint
}

# aggregate max on columns
type ProjectTagsMaxFields {
  projectId: bigint
  tagId: bigint
}

# order by max() on columns of table "project_tags"
input ProjectTagsMaxOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# aggregate min on columns
type ProjectTagsMinFields {
  projectId: bigint
  tagId: bigint
}

# order by min() on columns of table "project_tags"
input ProjectTagsMinOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# response of any mutation on the table "project_tags"
type ProjectTagsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ProjectTags!]!
}

# on_conflict condition type for table "project_tags"
input ProjectTagsOnConflict {
  constraint: ProjectTagsConstraint!
  updateColumns: [ProjectTagsUpdateColumn!]! = []
  where: ProjectTagsBoolExp
}

# Ordering options when selecting data from "project_tags".
input ProjectTagsOrderBy {
  project: ProjectOrderBy
  projectId: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
}

# primary key columns input for table: project_tags
input ProjectTagsPkColumnsInput {
  projectId: bigint!
  tagId: bigint!
}

# select columns of table "project_tags"
enum ProjectTagsSelectColumn {
  # column name
  projectId

  # column name
  tagId
}

# input type for updating data in table "project_tags"
input ProjectTagsSetInput {
  projectId: bigint
  tagId: bigint
}

# aggregate stddev on columns
type ProjectTagsStddevFields {
  projectId: Float
  tagId: Float
}

# order by stddev() on columns of table "project_tags"
input ProjectTagsStddevOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# aggregate stddevPop on columns
type ProjectTagsStddevPopFields {
  projectId: Float
  tagId: Float
}

# order by stddevPop() on columns of table "project_tags"
input ProjectTagsStddevPopOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# aggregate stddevSamp on columns
type ProjectTagsStddevSampFields {
  projectId: Float
  tagId: Float
}

# order by stddevSamp() on columns of table "project_tags"
input ProjectTagsStddevSampOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# Streaming cursor of the table "project_tags"
input ProjectTagsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ProjectTagsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ProjectTagsStreamCursorValueInput {
  projectId: bigint
  tagId: bigint
}

# aggregate sum on columns
type ProjectTagsSumFields {
  projectId: bigint
  tagId: bigint
}

# order by sum() on columns of table "project_tags"
input ProjectTagsSumOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# update columns of table "project_tags"
enum ProjectTagsUpdateColumn {
  # column name
  projectId

  # column name
  tagId
}

input ProjectTagsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ProjectTagsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ProjectTagsSetInput

  # filter the rows which have to be updated
  where: ProjectTagsBoolExp!
}

# aggregate variance on columns
type ProjectTagsVarianceFields {
  projectId: Float
  tagId: Float
}

# order by variance() on columns of table "project_tags"
input ProjectTagsVarianceOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# aggregate varPop on columns
type ProjectTagsVarPopFields {
  projectId: Float
  tagId: Float
}

# order by varPop() on columns of table "project_tags"
input ProjectTagsVarPopOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# aggregate varSamp on columns
type ProjectTagsVarSampFields {
  projectId: Float
  tagId: Float
}

# order by varSamp() on columns of table "project_tags"
input ProjectTagsVarSampOrderBy {
  projectId: OrderBy
  tagId: OrderBy
}

# update columns of table "project"
enum ProjectUpdateColumn {
  # column name
  bannerId

  # column name
  budget

  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  name

  # column name
  regularEventInterval

  # column name
  slug

  # column name
  teamId

  # column name
  tenantId
}

input ProjectUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ProjectIncInput

  # sets the columns of the filtered rows to the given values
  _set: ProjectSetInput

  # filter the rows which have to be updated
  where: ProjectBoolExp!
}

# aggregate variance on columns
type ProjectVarianceFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "project"
input ProjectVarianceOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ProjectVarPopFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "project"
input ProjectVarPopOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ProjectVarSampFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "project"
input ProjectVarSampOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

type Query {
  # fetch data from the table: "account"
  account(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # fetch aggregated fields from the table: "account"
  accountAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # fetch data from the table: "account_allocate"
  accountAllocate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # fetch aggregated fields from the table: "account_allocate"
  accountAllocateAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!

  # fetch data from the table: "account_allocate" using primary key columns
  accountAllocateByPk(id: bigint!): AccountAllocate

  # fetch data from the table: "account" using primary key columns
  accountByPk(id: bigint!): Account

  # fetch data from the table: "action"
  action(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch aggregated fields from the table: "action"
  actionAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # fetch data from the table: "action" using primary key columns
  actionByPk(id: bigint!): Action

  # fetch data from the table: "actor"
  actor(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # fetch aggregated fields from the table: "actor"
  actorAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # fetch data from the table: "actor" using primary key columns
  actorByPk(id: bigint!): Actor

  # fetch data from the table: "actor_image"
  actorImage(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch aggregated fields from the table: "actor_image"
  actorImageAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # fetch data from the table: "actor_image" using primary key columns
  actorImageByPk(id: bigint!): ActorImage

  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): [ActorTags!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): ActorTagsAggregate!

  # fetch data from the table: "actor_tags" using primary key columns
  actorTagsByPk(actorId: bigint!, tagId: bigint!): ActorTags

  # fetch data from the table: "address"
  address(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch aggregated fields from the table: "address"
  addressAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # fetch data from the table: "address" using primary key columns
  addressByPk(id: bigint!): Address

  # fetch data from the table: "bank_info"
  bankInfo(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch aggregated fields from the table: "bank_info"
  bankInfoAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # fetch data from the table: "bank_info" using primary key columns
  bankInfoByPk(id: bigint!): BankInfo

  # fetch data from the table: "bot"
  bot(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # fetch aggregated fields from the table: "bot"
  botAggregate(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): BotAggregate!

  # fetch data from the table: "bot" using primary key columns
  botByPk(id: bigint!): Bot

  # fetch data from the table: "campus"
  campus(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch aggregated fields from the table: "campus"
  campusAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # fetch data from the table: "campus" using primary key columns
  campusByPk(id: bigint!): Campus

  # fetch data from the table: "campus_cluster"
  campusCluster(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch aggregated fields from the table: "campus_cluster"
  campusClusterAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # fetch data from the table: "campus_cluster" using primary key columns
  campusClusterByPk(id: bigint!): CampusCluster

  # fetch data from the table: "canteen"
  canteen(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): [Canteen!]!

  # fetch aggregated fields from the table: "canteen"
  canteenAggregate(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): CanteenAggregate!

  # fetch data from the table: "canteen" using primary key columns
  canteenByPk(id: bigint!): Canteen

  # fetch data from the table: "canteen_food"
  canteenFood(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # fetch aggregated fields from the table: "canteen_food"
  canteenFoodAggregate(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): CanteenFoodAggregate!

  # fetch data from the table: "canteen_food" using primary key columns
  canteenFoodByPk(id: bigint!): CanteenFood

  # fetch data from the table: "canteen_menu"
  canteenMenu(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # fetch aggregated fields from the table: "canteen_menu"
  canteenMenuAggregate(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): CanteenMenuAggregate!

  # fetch data from the table: "canteen_menu" using primary key columns
  canteenMenuByPk(id: bigint!): CanteenMenu

  # fetch data from the table: "class_group"
  classGroup(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): [ClassGroup!]!

  # fetch aggregated fields from the table: "class_group"
  classGroupAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): ClassGroupAggregate!

  # fetch data from the table: "class_group" using primary key columns
  classGroupByPk(id: bigint!): ClassGroup

  # fetch data from the table: "class_group_teacher"
  classGroupTeacher(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # fetch aggregated fields from the table: "class_group_teacher"
  classGroupTeacherAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!

  # fetch data from the table: "class_group_teacher" using primary key columns
  classGroupTeacherByPk(id: bigint!): ClassGroupTeacher

  # An array relationship
  classGroupTeacherSubjects(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): [ClassGroupTeacherSubjects!]!

  # An aggregate relationship
  classGroupTeacherSubjectsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): ClassGroupTeacherSubjectsAggregate!

  # fetch data from the table: "class_group_teacher_subjects" using primary key columns
  classGroupTeacherSubjectsByPk(classGroupTeacherId: bigint!, subjectId: bigint!): ClassGroupTeacherSubjects

  # fetch data from the table: "cohort"
  cohort(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): [Cohort!]!

  # fetch aggregated fields from the table: "cohort"
  cohortAggregate(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): CohortAggregate!

  # fetch data from the table: "cohort" using primary key columns
  cohortByPk(id: bigint!): Cohort

  # fetch data from the table: "content"
  content(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # fetch aggregated fields from the table: "content"
  contentAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!

  # An array relationship
  contentAttachments(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): [ContentAttachments!]!

  # An aggregate relationship
  contentAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): ContentAttachmentsAggregate!

  # fetch data from the table: "content_attachments" using primary key columns
  contentAttachmentsByPk(contentId: bigint!, fileUploadId: bigint!): ContentAttachments

  # fetch data from the table: "content" using primary key columns
  contentByPk(id: bigint!): Content

  # fetch data from the table: "document"
  document(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # fetch aggregated fields from the table: "document"
  documentAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!

  # fetch data from the table: "document" using primary key columns
  documentByPk(id: bigint!): Document

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # fetch aggregated fields from the table: "event"
  eventAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # fetch data from the table: "event_approval"
  eventApproval(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch aggregated fields from the table: "event_approval"
  eventApprovalAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # fetch data from the table: "event_approval" using primary key columns
  eventApprovalByPk(id: bigint!): EventApproval

  # fetch data from the table: "event_approval_step"
  eventApprovalStep(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # fetch aggregated fields from the table: "event_approval_step"
  eventApprovalStepAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # fetch data from the table: "event_approval_step" using primary key columns
  eventApprovalStepByPk(id: bigint!): EventApprovalStep

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # fetch data from the table: "event_approval_step_notifiees" using primary key columns
  eventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepNotifiees

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # fetch data from the table: "event_approval_step_validators" using primary key columns
  eventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepValidators

  # fetch data from the table: "event" using primary key columns
  eventByPk(id: bigint!): Event

  # fetch data from the table: "event_join"
  eventJoin(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch aggregated fields from the table: "event_join"
  eventJoinAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # fetch data from the table: "event_join" using primary key columns
  eventJoinByPk(id: bigint!): EventJoin

  # fetch data from the table: "event_manage"
  eventManage(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # fetch aggregated fields from the table: "event_manage"
  eventManageAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # fetch data from the table: "event_manage" using primary key columns
  eventManageByPk(id: bigint!): EventManage

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): [EventSupervisors!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): EventSupervisorsAggregate!

  # fetch data from the table: "event_supervisors" using primary key columns
  eventSupervisorsByPk(eventId: bigint!, userId: bigint!): EventSupervisors

  # An array relationship
  eventTags(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): [EventTags!]!

  # An aggregate relationship
  eventTagsAggregate(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): EventTagsAggregate!

  # fetch data from the table: "event_tags" using primary key columns
  eventTagsByPk(eventId: bigint!, tagId: bigint!): EventTags

  # fetch data from the table: "expense"
  expense(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch aggregated fields from the table: "expense"
  expenseAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # fetch data from the table: "expense" using primary key columns
  expenseByPk(id: bigint!): Expense

  # fetch data from the table: "expense_item"
  expenseItem(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch aggregated fields from the table: "expense_item"
  expenseItemAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # fetch data from the table: "expense_item_attachments" using primary key columns
  expenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # fetch data from the table: "expense_item" using primary key columns
  expenseItemByPk(id: bigint!): ExpenseItem

  # fetch data from the table: "favorite"
  favorite(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # fetch aggregated fields from the table: "favorite"
  favoriteAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!

  # fetch data from the table: "favorite" using primary key columns
  favoriteByPk(id: bigint!): Favorite

  # fetch data from the table: "file_upload"
  fileUpload(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch aggregated fields from the table: "file_upload"
  fileUploadAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # fetch data from the table: "file_upload" using primary key columns
  fileUploadByPk(id: bigint!): FileUpload

  # fetch data from the table: "finance"
  finance(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # fetch aggregated fields from the table: "finance"
  financeAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  financeAttachments(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): [FinanceAttachments!]!

  # An aggregate relationship
  financeAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): FinanceAttachmentsAggregate!

  # fetch data from the table: "finance_attachments" using primary key columns
  financeAttachmentsByPk(fileUploadId: bigint!, financeId: bigint!): FinanceAttachments

  # fetch data from the table: "finance" using primary key columns
  financeByPk(id: bigint!): Finance

  # fetch data from the table: "follow"
  follow(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch aggregated fields from the table: "follow"
  followAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # fetch data from the table: "follow" using primary key columns
  followByPk(id: bigint!): Follow

  # fetch data from the table: "form"
  form(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch aggregated fields from the table: "form"
  formAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # fetch data from the table: "form" using primary key columns
  formByPk(id: bigint!): Form

  # fetch data from the table: "form_submission"
  formSubmission(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch aggregated fields from the table: "form_submission"
  formSubmissionAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # fetch data from the table: "form_submission" using primary key columns
  formSubmissionByPk(id: bigint!): FormSubmission

  # fetch data from the table: "grant"
  grant(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch aggregated fields from the table: "grant"
  grantAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # fetch data from the table: "grant_attachments" using primary key columns
  grantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # fetch data from the table: "grant" using primary key columns
  grantByPk(id: bigint!): Grant

  # fetch data from the table: "grant_unlock"
  grantUnlock(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # fetch aggregated fields from the table: "grant_unlock"
  grantUnlockAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  grantUnlockAttachments(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): [GrantUnlockAttachments!]!

  # An aggregate relationship
  grantUnlockAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): GrantUnlockAttachmentsAggregate!

  # fetch data from the table: "grant_unlock_attachments" using primary key columns
  grantUnlockAttachmentsByPk(fileUploadId: bigint!, grantUnlockId: bigint!): GrantUnlockAttachments

  # fetch data from the table: "grant_unlock" using primary key columns
  grantUnlockByPk(id: bigint!): GrantUnlock

  # fetch data from the table: "individual"
  individual(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): [Individual!]!

  # fetch aggregated fields from the table: "individual"
  individualAggregate(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): IndividualAggregate!

  # fetch data from the table: "individual" using primary key columns
  individualByPk(id: bigint!): Individual

  # fetch data from the table: "issue"
  issue(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): [Issue!]!

  # fetch aggregated fields from the table: "issue"
  issueAggregate(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): IssueAggregate!

  # fetch data from the table: "issue" using primary key columns
  issueByPk(id: bigint!): Issue

  # An array relationship
  issueContributors(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): [IssueContributors!]!

  # An aggregate relationship
  issueContributorsAggregate(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): IssueContributorsAggregate!

  # fetch data from the table: "issue_contributors" using primary key columns
  issueContributorsByPk(individualId: bigint!, issueId: bigint!): IssueContributors

  # An array relationship
  issueTags(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): [IssueTags!]!

  # An aggregate relationship
  issueTagsAggregate(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): IssueTagsAggregate!

  # fetch data from the table: "issue_tags" using primary key columns
  issueTagsByPk(issueId: bigint!, tagId: bigint!): IssueTags

  # fetch data from the table: "legal_unit"
  legalUnit(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch aggregated fields from the table: "legal_unit"
  legalUnitAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # fetch data from the table: "legal_unit" using primary key columns
  legalUnitByPk(id: bigint!): LegalUnit

  # fetch data from the table: "mission"
  mission(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch aggregated fields from the table: "mission"
  missionAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # fetch data from the table: "mission" using primary key columns
  missionByPk(id: bigint!): Mission

  # fetch data from the table: "mission_join"
  missionJoin(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch aggregated fields from the table: "mission_join"
  missionJoinAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # fetch data from the table: "mission_join" using primary key columns
  missionJoinByPk(id: bigint!): MissionJoin

  # fetch data from the table: "pole"
  pole(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch aggregated fields from the table: "pole"
  poleAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # fetch data from the table: "pole" using primary key columns
  poleByPk(id: bigint!): Pole

  # fetch data from the table: "project"
  project(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # fetch aggregated fields from the table: "project"
  projectAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # fetch data from the table: "project" using primary key columns
  projectByPk(id: bigint!): Project

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # fetch data from the table: "project_supervisors" using primary key columns
  projectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # An array relationship
  projectTags(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): [ProjectTags!]!

  # An aggregate relationship
  projectTagsAggregate(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): ProjectTagsAggregate!

  # fetch data from the table: "project_tags" using primary key columns
  projectTagsByPk(projectId: bigint!, tagId: bigint!): ProjectTags

  # fetch data from the table: "reaction"
  reaction(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # fetch aggregated fields from the table: "reaction"
  reactionAggregate(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): ReactionAggregate!

  # fetch data from the table: "reaction" using primary key columns
  reactionByPk(id: bigint!): Reaction

  # fetch data from the table: "report"
  report(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # fetch aggregated fields from the table: "report"
  reportAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # fetch data from the table: "report" using primary key columns
  reportByPk(id: bigint!): Report

  # fetch data from the table: "role"
  role(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # fetch aggregated fields from the table: "role"
  roleAggregate(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): RoleAggregate!

  # fetch data from the table: "role" using primary key columns
  roleByPk(id: bigint!): Role

  # fetch data from the table: "session"
  session(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # fetch aggregated fields from the table: "session"
  sessionAggregate(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): SessionAggregate!

  # fetch data from the table: "session" using primary key columns
  sessionByPk(id: bigint!): Session

  # fetch data from the table: "shortcut"
  shortcut(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # fetch aggregated fields from the table: "shortcut"
  shortcutAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!

  # fetch data from the table: "shortcut" using primary key columns
  shortcutByPk(id: bigint!): Shortcut

  # fetch data from the table: "social"
  social(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch aggregated fields from the table: "social"
  socialAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # fetch data from the table: "social" using primary key columns
  socialByPk(id: bigint!): Social

  # fetch data from the table: "subject"
  subject(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): [Subject!]!

  # fetch aggregated fields from the table: "subject"
  subjectAggregate(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): SubjectAggregate!

  # fetch data from the table: "subject" using primary key columns
  subjectByPk(id: bigint!): Subject

  # An array relationship
  subjectClassGroups(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): [SubjectClassGroups!]!

  # An aggregate relationship
  subjectClassGroupsAggregate(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): SubjectClassGroupsAggregate!

  # fetch data from the table: "subject_class_groups" using primary key columns
  subjectClassGroupsByPk(classGroupId: bigint!, subjectId: bigint!): SubjectClassGroups

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch aggregated fields from the table: "tag"
  tagAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # fetch data from the table: "tag" using primary key columns
  tagByPk(id: bigint!): Tag

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch aggregated fields from the table: "team"
  teamAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # fetch data from the table: "team" using primary key columns
  teamByPk(id: bigint!): Team

  # fetch data from the table: "team_history"
  teamHistory(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch aggregated fields from the table: "team_history"
  teamHistoryAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # fetch data from the table: "team_history" using primary key columns
  teamHistoryByPk(id: bigint!): TeamHistory

  # fetch data from the table: "team_join"
  teamJoin(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch aggregated fields from the table: "team_join"
  teamJoinAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # fetch data from the table: "team_join" using primary key columns
  teamJoinByPk(id: bigint!): TeamJoin

  # fetch data from the table: "team_member"
  teamMember(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch aggregated fields from the table: "team_member"
  teamMemberAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # fetch data from the table: "team_member" using primary key columns
  teamMemberByPk(id: bigint!): TeamMember

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): [TeamMemberRoles!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): TeamMemberRolesAggregate!

  # fetch data from the table: "team_member_roles" using primary key columns
  teamMemberRolesByPk(roleId: bigint!, teamMemberId: bigint!): TeamMemberRoles

  # fetch data from the table: "team_metric"
  teamMetric(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): [TeamMetric!]!

  # fetch aggregated fields from the table: "team_metric"
  teamMetricAggregate(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): TeamMetricAggregate!

  # fetch data from the table: "team_metric" using primary key columns
  teamMetricByPk(id: bigint!): TeamMetric

  # fetch data from the table: "tenant"
  tenant(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch aggregated fields from the table: "tenant"
  tenantAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # fetch data from the table: "tenant" using primary key columns
  tenantByPk(id: bigint!): Tenant

  # fetch data from the table: "tenant_manage"
  tenantManage(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # fetch aggregated fields from the table: "tenant_manage"
  tenantManageAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!

  # fetch data from the table: "tenant_manage" using primary key columns
  tenantManageByPk(id: bigint!): TenantManage

  # fetch data from the table: "thread"
  thread(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): [Thread!]!

  # fetch aggregated fields from the table: "thread"
  threadAggregate(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): ThreadAggregate!

  # fetch data from the table: "thread" using primary key columns
  threadByPk(id: bigint!): Thread

  # An array relationship
  threadContributors(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): [ThreadContributors!]!

  # An aggregate relationship
  threadContributorsAggregate(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): ThreadContributorsAggregate!

  # fetch data from the table: "thread_contributors" using primary key columns
  threadContributorsByPk(individualId: bigint!, threadId: bigint!): ThreadContributors

  # An array relationship
  threadTags(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): [ThreadTags!]!

  # An aggregate relationship
  threadTagsAggregate(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): ThreadTagsAggregate!

  # fetch data from the table: "thread_tags" using primary key columns
  threadTagsByPk(tagId: bigint!, threadId: bigint!): ThreadTags

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # fetch aggregated fields from the table: "user"
  userAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # fetch data from the table: "user" using primary key columns
  userByPk(id: bigint!): User

  # fetch data from the table: "validation"
  validation(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # fetch aggregated fields from the table: "validation"
  validationAggregate(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): ValidationAggregate!

  # fetch data from the table: "validation" using primary key columns
  validationByPk(id: bigint!): Validation

  # fetch data from the table: "vote"
  vote(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!

  # fetch aggregated fields from the table: "vote"
  voteAggregate(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): VoteAggregate!

  # fetch data from the table: "vote" using primary key columns
  voteByPk(id: bigint!): Vote
}

# columns and relationships of "reaction"
type Reaction {
  # An object relationship
  content: Content
  contentId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz
  reactionType: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "reaction"
type ReactionAggregate {
  aggregate: ReactionAggregateFields
  nodes: [Reaction!]!
}

input ReactionAggregateBoolExp {
  count: reactionAggregateBoolExpCount
}

input reactionAggregateBoolExpCount {
  arguments: [ReactionSelectColumn!]
  distinct: Boolean
  filter: ReactionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "reaction"
type ReactionAggregateFields {
  avg: ReactionAvgFields
  count(columns: [ReactionSelectColumn!], distinct: Boolean): Int!
  max: ReactionMaxFields
  min: ReactionMinFields
  stddev: ReactionStddevFields
  stddevPop: ReactionStddevPopFields
  stddevSamp: ReactionStddevSampFields
  sum: ReactionSumFields
  varPop: ReactionVarPopFields
  varSamp: ReactionVarSampFields
  variance: ReactionVarianceFields
}

# order by aggregate values of table "reaction"
input ReactionAggregateOrderBy {
  avg: ReactionAvgOrderBy
  count: OrderBy
  max: ReactionMaxOrderBy
  min: ReactionMinOrderBy
  stddev: ReactionStddevOrderBy
  stddevPop: ReactionStddevPopOrderBy
  stddevSamp: ReactionStddevSampOrderBy
  sum: ReactionSumOrderBy
  varPop: ReactionVarPopOrderBy
  varSamp: ReactionVarSampOrderBy
  variance: ReactionVarianceOrderBy
}

# input type for inserting array relation for remote table "reaction"
input ReactionArrRelInsertInput {
  data: [ReactionInsertInput!]!

  # upsert condition
  onConflict: ReactionOnConflict
}

# aggregate avg on columns
type ReactionAvgFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "reaction"
input ReactionAvgOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "reaction". All fields are combined with a logical 'AND'.
input ReactionBoolExp {
  _and: [ReactionBoolExp!]
  _not: ReactionBoolExp
  _or: [ReactionBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  reactionType: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "reaction"
enum ReactionConstraint {
  # unique or primary key constraint on columns "id"
  reaction_pkey
}

# input type for incrementing numeric columns in table "reaction"
input ReactionIncInput {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "reaction"
input ReactionInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reactionType: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type ReactionMaxFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reactionType: String
  tenantId: bigint
}

# order by max() on columns of table "reaction"
input ReactionMaxOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reactionType: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type ReactionMinFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reactionType: String
  tenantId: bigint
}

# order by min() on columns of table "reaction"
input ReactionMinOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reactionType: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "reaction"
type ReactionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Reaction!]!
}

# on_conflict condition type for table "reaction"
input ReactionOnConflict {
  constraint: ReactionConstraint!
  updateColumns: [ReactionUpdateColumn!]! = []
  where: ReactionBoolExp
}

# Ordering options when selecting data from "reaction".
input ReactionOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reactionType: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: reaction
input ReactionPkColumnsInput {
  id: bigint!
}

# select columns of table "reaction"
enum ReactionSelectColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  reactionType

  # column name
  tenantId
}

# input type for updating data in table "reaction"
input ReactionSetInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reactionType: String
  tenantId: bigint
}

# aggregate stddev on columns
type ReactionStddevFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "reaction"
input ReactionStddevOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ReactionStddevPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "reaction"
input ReactionStddevPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ReactionStddevSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "reaction"
input ReactionStddevSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "reaction"
input ReactionStreamCursorInput {
  # Stream column input with initial value
  initialValue: ReactionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ReactionStreamCursorValueInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reactionType: String
  tenantId: bigint
}

# aggregate sum on columns
type ReactionSumFields {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "reaction"
input ReactionSumOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "reaction"
enum ReactionUpdateColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  reactionType

  # column name
  tenantId
}

input ReactionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ReactionIncInput

  # sets the columns of the filtered rows to the given values
  _set: ReactionSetInput

  # filter the rows which have to be updated
  where: ReactionBoolExp!
}

# aggregate variance on columns
type ReactionVarianceFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "reaction"
input ReactionVarianceOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ReactionVarPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "reaction"
input ReactionVarPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ReactionVarSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "reaction"
input ReactionVarSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "report"
type Report {
  # An object relationship
  actor: Actor
  actorId: bigint

  # An object relationship
  content: Content
  contentId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz
  reason: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "report"
type ReportAggregate {
  aggregate: ReportAggregateFields
  nodes: [Report!]!
}

input ReportAggregateBoolExp {
  count: reportAggregateBoolExpCount
}

input reportAggregateBoolExpCount {
  arguments: [ReportSelectColumn!]
  distinct: Boolean
  filter: ReportBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "report"
type ReportAggregateFields {
  avg: ReportAvgFields
  count(columns: [ReportSelectColumn!], distinct: Boolean): Int!
  max: ReportMaxFields
  min: ReportMinFields
  stddev: ReportStddevFields
  stddevPop: ReportStddevPopFields
  stddevSamp: ReportStddevSampFields
  sum: ReportSumFields
  varPop: ReportVarPopFields
  varSamp: ReportVarSampFields
  variance: ReportVarianceFields
}

# order by aggregate values of table "report"
input ReportAggregateOrderBy {
  avg: ReportAvgOrderBy
  count: OrderBy
  max: ReportMaxOrderBy
  min: ReportMinOrderBy
  stddev: ReportStddevOrderBy
  stddevPop: ReportStddevPopOrderBy
  stddevSamp: ReportStddevSampOrderBy
  sum: ReportSumOrderBy
  varPop: ReportVarPopOrderBy
  varSamp: ReportVarSampOrderBy
  variance: ReportVarianceOrderBy
}

# input type for inserting array relation for remote table "report"
input ReportArrRelInsertInput {
  data: [ReportInsertInput!]!

  # upsert condition
  onConflict: ReportOnConflict
}

# aggregate avg on columns
type ReportAvgFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "report"
input ReportAvgOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "report". All fields are combined with a logical 'AND'.
input ReportBoolExp {
  _and: [ReportBoolExp!]
  _not: ReportBoolExp
  _or: [ReportBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  reason: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "report"
enum ReportConstraint {
  # unique or primary key constraint on columns "id"
  report_pkey
}

# input type for incrementing numeric columns in table "report"
input ReportIncInput {
  actorId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "report"
input ReportInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reason: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type ReportMaxFields {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reason: String
  tenantId: bigint
  type: String
}

# order by max() on columns of table "report"
input ReportMaxOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reason: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ReportMinFields {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reason: String
  tenantId: bigint
  type: String
}

# order by min() on columns of table "report"
input ReportMinOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reason: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "report"
type ReportMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Report!]!
}

# on_conflict condition type for table "report"
input ReportOnConflict {
  constraint: ReportConstraint!
  updateColumns: [ReportUpdateColumn!]! = []
  where: ReportBoolExp
}

# Ordering options when selecting data from "report".
input ReportOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  reason: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: report
input ReportPkColumnsInput {
  id: bigint!
}

# select columns of table "report"
enum ReportSelectColumn {
  # column name
  actorId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  reason

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "report"
input ReportSetInput {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reason: String
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type ReportStddevFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "report"
input ReportStddevOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ReportStddevPopFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "report"
input ReportStddevPopOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ReportStddevSampFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "report"
input ReportStddevSampOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "report"
input ReportStreamCursorInput {
  # Stream column input with initial value
  initialValue: ReportStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ReportStreamCursorValueInput {
  actorId: bigint
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  reason: String
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type ReportSumFields {
  actorId: bigint
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "report"
input ReportSumOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "report"
enum ReportUpdateColumn {
  # column name
  actorId

  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  reason

  # column name
  tenantId

  # column name
  type
}

input ReportUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ReportIncInput

  # sets the columns of the filtered rows to the given values
  _set: ReportSetInput

  # filter the rows which have to be updated
  where: ReportBoolExp!
}

# aggregate variance on columns
type ReportVarianceFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "report"
input ReportVarianceOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ReportVarPopFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "report"
input ReportVarPopOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ReportVarSampFields {
  actorId: Float
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "report"
input ReportVarSampOrderBy {
  actorId: OrderBy
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "role"
type Role {
  # An array relationship
  askedTeamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  askedTeamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  isRequired: Boolean!
  name: String!
  permissions: _text!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): [TeamMemberRoles!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): TeamMemberRolesAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "role"
type RoleAggregate {
  aggregate: RoleAggregateFields
  nodes: [Role!]!
}

input RoleAggregateBoolExp {
  bool_and: roleAggregateBoolExpBool_and
  bool_or: roleAggregateBoolExpBool_or
  count: roleAggregateBoolExpCount
}

input roleAggregateBoolExpBool_and {
  arguments: RoleSelectColumnRoleAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: RoleBoolExp
  predicate: BooleanComparisonExp!
}

input roleAggregateBoolExpBool_or {
  arguments: RoleSelectColumnRoleAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: RoleBoolExp
  predicate: BooleanComparisonExp!
}

input roleAggregateBoolExpCount {
  arguments: [RoleSelectColumn!]
  distinct: Boolean
  filter: RoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "role"
type RoleAggregateFields {
  avg: RoleAvgFields
  count(columns: [RoleSelectColumn!], distinct: Boolean): Int!
  max: RoleMaxFields
  min: RoleMinFields
  stddev: RoleStddevFields
  stddevPop: RoleStddevPopFields
  stddevSamp: RoleStddevSampFields
  sum: RoleSumFields
  varPop: RoleVarPopFields
  varSamp: RoleVarSampFields
  variance: RoleVarianceFields
}

# order by aggregate values of table "role"
input RoleAggregateOrderBy {
  avg: RoleAvgOrderBy
  count: OrderBy
  max: RoleMaxOrderBy
  min: RoleMinOrderBy
  stddev: RoleStddevOrderBy
  stddevPop: RoleStddevPopOrderBy
  stddevSamp: RoleStddevSampOrderBy
  sum: RoleSumOrderBy
  varPop: RoleVarPopOrderBy
  varSamp: RoleVarSampOrderBy
  variance: RoleVarianceOrderBy
}

# input type for inserting array relation for remote table "role"
input RoleArrRelInsertInput {
  data: [RoleInsertInput!]!

  # upsert condition
  onConflict: RoleOnConflict
}

# aggregate avg on columns
type RoleAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "role"
input RoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
input RoleBoolExp {
  _and: [RoleBoolExp!]
  _not: RoleBoolExp
  _or: [RoleBoolExp!]
  askedTeamJoins: TeamJoinBoolExp
  askedTeamJoinsAggregate: TeamJoinAggregateBoolExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isRequired: BooleanComparisonExp
  name: StringComparisonExp
  permissions: _textComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMemberRoles: TeamMemberRolesBoolExp
  teamMemberRolesAggregate: TeamMemberRolesAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "role"
enum RoleConstraint {
  # unique or primary key constraint on columns "id"
  role_pkey
}

# input type for incrementing numeric columns in table "role"
input RoleIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "role"
input RoleInsertInput {
  askedTeamJoins: TeamJoinArrRelInsertInput
  category: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  permissions: _text
  team: TeamObjRelInsertInput
  teamId: bigint
  teamJoins: TeamJoinArrRelInsertInput
  teamMemberRoles: TeamMemberRolesArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type RoleMaxFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by max() on columns of table "role"
input RoleMaxOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type RoleMinFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantId: bigint
  type: String
}

# order by min() on columns of table "role"
input RoleMinOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "role"
type RoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Role!]!
}

# input type for inserting object relation for remote table "role"
input RoleObjRelInsertInput {
  data: RoleInsertInput!

  # upsert condition
  onConflict: RoleOnConflict
}

# on_conflict condition type for table "role"
input RoleOnConflict {
  constraint: RoleConstraint!
  updateColumns: [RoleUpdateColumn!]! = []
  where: RoleBoolExp
}

# Ordering options when selecting data from "role".
input RoleOrderBy {
  askedTeamJoinsAggregate: TeamJoinAggregateOrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isRequired: OrderBy
  name: OrderBy
  permissions: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMemberRolesAggregate: TeamMemberRolesAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: role
input RolePkColumnsInput {
  id: bigint!
}

# select columns of table "role"
enum RoleSelectColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isRequired

  # column name
  name

  # column name
  permissions

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

# select "roleAggregateBoolExpBool_andArgumentsColumns" columns of table "role"
enum RoleSelectColumnRoleAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isRequired
}

# select "roleAggregateBoolExpBool_orArgumentsColumns" columns of table "role"
enum RoleSelectColumnRoleAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isRequired
}

# input type for updating data in table "role"
input RoleSetInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  permissions: _text
  teamId: bigint
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type RoleStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "role"
input RoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type RoleStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "role"
input RoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type RoleStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "role"
input RoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "role"
input RoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: RoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input RoleStreamCursorValueInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isRequired: Boolean
  name: String
  permissions: _text
  teamId: bigint
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type RoleSumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "role"
input RoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "role"
enum RoleUpdateColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isRequired

  # column name
  name

  # column name
  permissions

  # column name
  teamId

  # column name
  tenantId

  # column name
  type
}

input RoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: RoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: RoleSetInput

  # filter the rows which have to be updated
  where: RoleBoolExp!
}

# aggregate variance on columns
type RoleVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "role"
input RoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type RoleVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "role"
input RoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type RoleVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "role"
input RoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "session"
type Session {
  clientType: String!
  country: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  ip: String!
  lastActivityAt: timestamptz!
  lastIssuedAt: timestamptz!
  refreshTokenHash: String!
  revokedAt: timestamptz

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  tokenFamily: String!

  # An object relationship
  user: User!
  userAgent(
    # JSON select path
    path: String
  ): jsonb!
  userId: bigint!
}

# aggregated selection of "session"
type SessionAggregate {
  aggregate: SessionAggregateFields
  nodes: [Session!]!
}

input SessionAggregateBoolExp {
  count: sessionAggregateBoolExpCount
}

input sessionAggregateBoolExpCount {
  arguments: [SessionSelectColumn!]
  distinct: Boolean
  filter: SessionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "session"
type SessionAggregateFields {
  avg: SessionAvgFields
  count(columns: [SessionSelectColumn!], distinct: Boolean): Int!
  max: SessionMaxFields
  min: SessionMinFields
  stddev: SessionStddevFields
  stddevPop: SessionStddevPopFields
  stddevSamp: SessionStddevSampFields
  sum: SessionSumFields
  varPop: SessionVarPopFields
  varSamp: SessionVarSampFields
  variance: SessionVarianceFields
}

# order by aggregate values of table "session"
input SessionAggregateOrderBy {
  avg: SessionAvgOrderBy
  count: OrderBy
  max: SessionMaxOrderBy
  min: SessionMinOrderBy
  stddev: SessionStddevOrderBy
  stddevPop: SessionStddevPopOrderBy
  stddevSamp: SessionStddevSampOrderBy
  sum: SessionSumOrderBy
  varPop: SessionVarPopOrderBy
  varSamp: SessionVarSampOrderBy
  variance: SessionVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input SessionAppendInput {
  userAgent: jsonb
}

# input type for inserting array relation for remote table "session"
input SessionArrRelInsertInput {
  data: [SessionInsertInput!]!

  # upsert condition
  onConflict: SessionOnConflict
}

# aggregate avg on columns
type SessionAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "session"
input SessionAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
input SessionBoolExp {
  _and: [SessionBoolExp!]
  _not: SessionBoolExp
  _or: [SessionBoolExp!]
  clientType: StringComparisonExp
  country: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  expiredAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  ip: StringComparisonExp
  lastActivityAt: TimestamptzComparisonExp
  lastIssuedAt: TimestamptzComparisonExp
  refreshTokenHash: StringComparisonExp
  revokedAt: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  tokenFamily: StringComparisonExp
  user: UserBoolExp
  userAgent: JsonbComparisonExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "session"
enum SessionConstraint {
  # unique or primary key constraint on columns "id"
  session_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input SessionDeleteAtPathInput {
  userAgent: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input SessionDeleteElemInput {
  userAgent: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input SessionDeleteKeyInput {
  userAgent: String
}

# input type for incrementing numeric columns in table "session"
input SessionIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "session"
input SessionInsertInput {
  clientType: String
  country: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ip: String
  lastActivityAt: timestamptz
  lastIssuedAt: timestamptz
  refreshTokenHash: String
  revokedAt: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  tokenFamily: String
  user: UserObjRelInsertInput
  userAgent: jsonb
  userId: bigint
}

# aggregate max on columns
type SessionMaxFields {
  clientType: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ip: String
  lastActivityAt: timestamptz
  lastIssuedAt: timestamptz
  refreshTokenHash: String
  revokedAt: timestamptz
  tenantId: bigint
  tokenFamily: String
  userId: bigint
}

# order by max() on columns of table "session"
input SessionMaxOrderBy {
  clientType: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expiredAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  ip: OrderBy
  lastActivityAt: OrderBy
  lastIssuedAt: OrderBy
  refreshTokenHash: OrderBy
  revokedAt: OrderBy
  tenantId: OrderBy
  tokenFamily: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type SessionMinFields {
  clientType: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ip: String
  lastActivityAt: timestamptz
  lastIssuedAt: timestamptz
  refreshTokenHash: String
  revokedAt: timestamptz
  tenantId: bigint
  tokenFamily: String
  userId: bigint
}

# order by min() on columns of table "session"
input SessionMinOrderBy {
  clientType: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expiredAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  ip: OrderBy
  lastActivityAt: OrderBy
  lastIssuedAt: OrderBy
  refreshTokenHash: OrderBy
  revokedAt: OrderBy
  tenantId: OrderBy
  tokenFamily: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "session"
type SessionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Session!]!
}

# on_conflict condition type for table "session"
input SessionOnConflict {
  constraint: SessionConstraint!
  updateColumns: [SessionUpdateColumn!]! = []
  where: SessionBoolExp
}

# Ordering options when selecting data from "session".
input SessionOrderBy {
  clientType: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expiredAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  ip: OrderBy
  lastActivityAt: OrderBy
  lastIssuedAt: OrderBy
  refreshTokenHash: OrderBy
  revokedAt: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  tokenFamily: OrderBy
  user: UserOrderBy
  userAgent: OrderBy
  userId: OrderBy
}

# primary key columns input for table: session
input SessionPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input SessionPrependInput {
  userAgent: jsonb
}

# select columns of table "session"
enum SessionSelectColumn {
  # column name
  clientType

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  expiredAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  ip

  # column name
  lastActivityAt

  # column name
  lastIssuedAt

  # column name
  refreshTokenHash

  # column name
  revokedAt

  # column name
  tenantId

  # column name
  tokenFamily

  # column name
  userAgent

  # column name
  userId
}

# input type for updating data in table "session"
input SessionSetInput {
  clientType: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ip: String
  lastActivityAt: timestamptz
  lastIssuedAt: timestamptz
  refreshTokenHash: String
  revokedAt: timestamptz
  tenantId: bigint
  tokenFamily: String
  userAgent: jsonb
  userId: bigint
}

# aggregate stddev on columns
type SessionStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "session"
input SessionStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type SessionStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "session"
input SessionStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type SessionStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "session"
input SessionStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "session"
input SessionStreamCursorInput {
  # Stream column input with initial value
  initialValue: SessionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input SessionStreamCursorValueInput {
  clientType: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  expiredAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  ip: String
  lastActivityAt: timestamptz
  lastIssuedAt: timestamptz
  refreshTokenHash: String
  revokedAt: timestamptz
  tenantId: bigint
  tokenFamily: String
  userAgent: jsonb
  userId: bigint
}

# aggregate sum on columns
type SessionSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "session"
input SessionSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "session"
enum SessionUpdateColumn {
  # column name
  clientType

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  expiredAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  ip

  # column name
  lastActivityAt

  # column name
  lastIssuedAt

  # column name
  refreshTokenHash

  # column name
  revokedAt

  # column name
  tenantId

  # column name
  tokenFamily

  # column name
  userAgent

  # column name
  userId
}

input SessionUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: SessionAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: SessionDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: SessionDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: SessionDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: SessionIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: SessionPrependInput

  # sets the columns of the filtered rows to the given values
  _set: SessionSetInput

  # filter the rows which have to be updated
  where: SessionBoolExp!
}

# aggregate variance on columns
type SessionVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "session"
input SessionVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type SessionVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "session"
input SessionVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type SessionVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "session"
input SessionVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# columns and relationships of "shortcut"
type Shortcut {
  # An object relationship
  actor: Actor!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  targetActorId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "shortcut"
type ShortcutAggregate {
  aggregate: ShortcutAggregateFields
  nodes: [Shortcut!]!
}

input ShortcutAggregateBoolExp {
  count: shortcutAggregateBoolExpCount
}

input shortcutAggregateBoolExpCount {
  arguments: [ShortcutSelectColumn!]
  distinct: Boolean
  filter: ShortcutBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "shortcut"
type ShortcutAggregateFields {
  avg: ShortcutAvgFields
  count(columns: [ShortcutSelectColumn!], distinct: Boolean): Int!
  max: ShortcutMaxFields
  min: ShortcutMinFields
  stddev: ShortcutStddevFields
  stddevPop: ShortcutStddevPopFields
  stddevSamp: ShortcutStddevSampFields
  sum: ShortcutSumFields
  varPop: ShortcutVarPopFields
  varSamp: ShortcutVarSampFields
  variance: ShortcutVarianceFields
}

# order by aggregate values of table "shortcut"
input ShortcutAggregateOrderBy {
  avg: ShortcutAvgOrderBy
  count: OrderBy
  max: ShortcutMaxOrderBy
  min: ShortcutMinOrderBy
  stddev: ShortcutStddevOrderBy
  stddevPop: ShortcutStddevPopOrderBy
  stddevSamp: ShortcutStddevSampOrderBy
  sum: ShortcutSumOrderBy
  varPop: ShortcutVarPopOrderBy
  varSamp: ShortcutVarSampOrderBy
  variance: ShortcutVarianceOrderBy
}

# input type for inserting array relation for remote table "shortcut"
input ShortcutArrRelInsertInput {
  data: [ShortcutInsertInput!]!

  # upsert condition
  onConflict: ShortcutOnConflict
}

# aggregate avg on columns
type ShortcutAvgFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "shortcut"
input ShortcutAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "shortcut". All fields are combined with a logical 'AND'.
input ShortcutBoolExp {
  _and: [ShortcutBoolExp!]
  _not: ShortcutBoolExp
  _or: [ShortcutBoolExp!]
  actor: ActorBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  targetActorId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "shortcut"
enum ShortcutConstraint {
  # unique or primary key constraint on columns "id"
  shortcut_pkey
}

# input type for incrementing numeric columns in table "shortcut"
input ShortcutIncInput {
  createdById: bigint
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "shortcut"
input ShortcutInsertInput {
  actor: ActorObjRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  targetActorId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type ShortcutMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  type: String
  userId: bigint
}

# order by max() on columns of table "shortcut"
input ShortcutMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type ShortcutMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  type: String
  userId: bigint
}

# order by min() on columns of table "shortcut"
input ShortcutMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "shortcut"
type ShortcutMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Shortcut!]!
}

# on_conflict condition type for table "shortcut"
input ShortcutOnConflict {
  constraint: ShortcutConstraint!
  updateColumns: [ShortcutUpdateColumn!]! = []
  where: ShortcutBoolExp
}

# Ordering options when selecting data from "shortcut".
input ShortcutOrderBy {
  actor: ActorOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: shortcut
input ShortcutPkColumnsInput {
  id: bigint!
}

# select columns of table "shortcut"
enum ShortcutSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  targetActorId

  # column name
  tenantId

  # column name
  type

  # column name
  userId
}

# input type for updating data in table "shortcut"
input ShortcutSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  type: String
  userId: bigint
}

# aggregate stddev on columns
type ShortcutStddevFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "shortcut"
input ShortcutStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type ShortcutStddevPopFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "shortcut"
input ShortcutStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type ShortcutStddevSampFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "shortcut"
input ShortcutStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "shortcut"
input ShortcutStreamCursorInput {
  # Stream column input with initial value
  initialValue: ShortcutStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ShortcutStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  type: String
  userId: bigint
}

# aggregate sum on columns
type ShortcutSumFields {
  createdById: bigint
  id: bigint
  targetActorId: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "shortcut"
input ShortcutSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "shortcut"
enum ShortcutUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  targetActorId

  # column name
  tenantId

  # column name
  type

  # column name
  userId
}

input ShortcutUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ShortcutIncInput

  # sets the columns of the filtered rows to the given values
  _set: ShortcutSetInput

  # filter the rows which have to be updated
  where: ShortcutBoolExp!
}

# aggregate variance on columns
type ShortcutVarianceFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "shortcut"
input ShortcutVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type ShortcutVarPopFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "shortcut"
input ShortcutVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type ShortcutVarSampFields {
  createdById: Float
  id: Float
  targetActorId: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "shortcut"
input ShortcutVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  targetActorId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

scalar smallint

# Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
input SmallintComparisonExp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _isNull: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# columns and relationships of "social"
type Social {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  order: smallint!
  pseudo: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
  url: String!
}

# aggregated selection of "social"
type SocialAggregate {
  aggregate: SocialAggregateFields
  nodes: [Social!]!
}

input SocialAggregateBoolExp {
  count: socialAggregateBoolExpCount
}

input socialAggregateBoolExpCount {
  arguments: [SocialSelectColumn!]
  distinct: Boolean
  filter: SocialBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "social"
type SocialAggregateFields {
  avg: SocialAvgFields
  count(columns: [SocialSelectColumn!], distinct: Boolean): Int!
  max: SocialMaxFields
  min: SocialMinFields
  stddev: SocialStddevFields
  stddevPop: SocialStddevPopFields
  stddevSamp: SocialStddevSampFields
  sum: SocialSumFields
  varPop: SocialVarPopFields
  varSamp: SocialVarSampFields
  variance: SocialVarianceFields
}

# order by aggregate values of table "social"
input SocialAggregateOrderBy {
  avg: SocialAvgOrderBy
  count: OrderBy
  max: SocialMaxOrderBy
  min: SocialMinOrderBy
  stddev: SocialStddevOrderBy
  stddevPop: SocialStddevPopOrderBy
  stddevSamp: SocialStddevSampOrderBy
  sum: SocialSumOrderBy
  varPop: SocialVarPopOrderBy
  varSamp: SocialVarSampOrderBy
  variance: SocialVarianceOrderBy
}

# input type for inserting array relation for remote table "social"
input SocialArrRelInsertInput {
  data: [SocialInsertInput!]!

  # upsert condition
  onConflict: SocialOnConflict
}

# aggregate avg on columns
type SocialAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by avg() on columns of table "social"
input SocialAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "social". All fields are combined with a logical 'AND'.
input SocialBoolExp {
  _and: [SocialBoolExp!]
  _not: SocialBoolExp
  _or: [SocialBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  order: SmallintComparisonExp
  pseudo: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
  url: StringComparisonExp
}

# unique or primary key constraints on table "social"
enum SocialConstraint {
  # unique or primary key constraint on columns "id"
  social_pkey
}

# input type for incrementing numeric columns in table "social"
input SocialIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  order: smallint
  tenantId: bigint
}

# input type for inserting data into table "social"
input SocialInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
  url: String
}

# aggregate max on columns
type SocialMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantId: bigint
  type: String
  url: String
}

# order by max() on columns of table "social"
input SocialMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# aggregate min on columns
type SocialMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantId: bigint
  type: String
  url: String
}

# order by min() on columns of table "social"
input SocialMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# response of any mutation on the table "social"
type SocialMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Social!]!
}

# on_conflict condition type for table "social"
input SocialOnConflict {
  constraint: SocialConstraint!
  updateColumns: [SocialUpdateColumn!]! = []
  where: SocialBoolExp
}

# Ordering options when selecting data from "social".
input SocialOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
  url: OrderBy
}

# primary key columns input for table: social
input SocialPkColumnsInput {
  id: bigint!
}

# select columns of table "social"
enum SocialSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  order

  # column name
  pseudo

  # column name
  tenantId

  # column name
  type

  # column name
  url
}

# input type for updating data in table "social"
input SocialSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantId: bigint
  type: String
  url: String
}

# aggregate stddev on columns
type SocialStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by stddev() on columns of table "social"
input SocialStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type SocialStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "social"
input SocialStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type SocialStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "social"
input SocialStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "social"
input SocialStreamCursorInput {
  # Stream column input with initial value
  initialValue: SocialStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input SocialStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantId: bigint
  type: String
  url: String
}

# aggregate sum on columns
type SocialSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  order: smallint
  tenantId: bigint
}

# order by sum() on columns of table "social"
input SocialSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# update columns of table "social"
enum SocialUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  order

  # column name
  pseudo

  # column name
  tenantId

  # column name
  type

  # column name
  url
}

input SocialUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: SocialIncInput

  # sets the columns of the filtered rows to the given values
  _set: SocialSetInput

  # filter the rows which have to be updated
  where: SocialBoolExp!
}

# aggregate variance on columns
type SocialVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by variance() on columns of table "social"
input SocialVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type SocialVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by varPop() on columns of table "social"
input SocialVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type SocialVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantId: Float
}

# order by varSamp() on columns of table "social"
input SocialVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantId: OrderBy
}

# Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  # does the column match the given case-insensitive pattern
  _ilike: String
  _in: [String!]

  # does the column match the given POSIX regular expression, case insensitive
  _iregex: String
  _isNull: Boolean

  # does the column match the given pattern
  _like: String
  _lt: String
  _lte: String
  _neq: String

  # does the column NOT match the given case-insensitive pattern
  _nilike: String
  _nin: [String!]

  # does the column NOT match the given POSIX regular expression, case insensitive
  _niregex: String

  # does the column NOT match the given pattern
  _nlike: String

  # does the column NOT match the given POSIX regular expression, case sensitive
  _nregex: String

  # does the column NOT match the given SQL regular expression
  _nsimilar: String

  # does the column match the given POSIX regular expression, case sensitive
  _regex: String

  # does the column match the given SQL regular expression
  _similar: String
}

# columns and relationships of "subject"
type Subject {
  # An array relationship
  classGroupTeacherSubjects(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): [ClassGroupTeacherSubjects!]!

  # An aggregate relationship
  classGroupTeacherSubjectsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): ClassGroupTeacherSubjectsAggregate!
  code: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  documents(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # An aggregate relationship
  documentsAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!
  englishName: String!
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz
  name: String!

  # An array relationship
  subjectClassGroups(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): [SubjectClassGroups!]!

  # An aggregate relationship
  subjectClassGroupsAggregate(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): SubjectClassGroupsAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "subject"
type SubjectAggregate {
  aggregate: SubjectAggregateFields
  nodes: [Subject!]!
}

input SubjectAggregateBoolExp {
  count: subjectAggregateBoolExpCount
}

input subjectAggregateBoolExpCount {
  arguments: [SubjectSelectColumn!]
  distinct: Boolean
  filter: SubjectBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "subject"
type SubjectAggregateFields {
  avg: SubjectAvgFields
  count(columns: [SubjectSelectColumn!], distinct: Boolean): Int!
  max: SubjectMaxFields
  min: SubjectMinFields
  stddev: SubjectStddevFields
  stddevPop: SubjectStddevPopFields
  stddevSamp: SubjectStddevSampFields
  sum: SubjectSumFields
  varPop: SubjectVarPopFields
  varSamp: SubjectVarSampFields
  variance: SubjectVarianceFields
}

# order by aggregate values of table "subject"
input SubjectAggregateOrderBy {
  avg: SubjectAvgOrderBy
  count: OrderBy
  max: SubjectMaxOrderBy
  min: SubjectMinOrderBy
  stddev: SubjectStddevOrderBy
  stddevPop: SubjectStddevPopOrderBy
  stddevSamp: SubjectStddevSampOrderBy
  sum: SubjectSumOrderBy
  varPop: SubjectVarPopOrderBy
  varSamp: SubjectVarSampOrderBy
  variance: SubjectVarianceOrderBy
}

# input type for inserting array relation for remote table "subject"
input SubjectArrRelInsertInput {
  data: [SubjectInsertInput!]!

  # upsert condition
  onConflict: SubjectOnConflict
}

# aggregate avg on columns
type SubjectAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "subject"
input SubjectAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "subject". All fields are combined with a logical 'AND'.
input SubjectBoolExp {
  _and: [SubjectBoolExp!]
  _not: SubjectBoolExp
  _or: [SubjectBoolExp!]
  classGroupTeacherSubjects: ClassGroupTeacherSubjectsBoolExp
  classGroupTeacherSubjectsAggregate: ClassGroupTeacherSubjectsAggregateBoolExp
  code: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  documents: DocumentBoolExp
  documentsAggregate: DocumentAggregateBoolExp
  englishName: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  name: StringComparisonExp
  subjectClassGroups: SubjectClassGroupsBoolExp
  subjectClassGroupsAggregate: SubjectClassGroupsAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# columns and relationships of "subject_class_groups"
type SubjectClassGroups {
  # An object relationship
  classGroup: ClassGroup!
  classGroupId: bigint!

  # An object relationship
  subject: Subject!
  subjectId: bigint!
}

# aggregated selection of "subject_class_groups"
type SubjectClassGroupsAggregate {
  aggregate: SubjectClassGroupsAggregateFields
  nodes: [SubjectClassGroups!]!
}

input SubjectClassGroupsAggregateBoolExp {
  count: subjectClassGroupsAggregateBoolExpCount
}

input subjectClassGroupsAggregateBoolExpCount {
  arguments: [SubjectClassGroupsSelectColumn!]
  distinct: Boolean
  filter: SubjectClassGroupsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "subject_class_groups"
type SubjectClassGroupsAggregateFields {
  avg: SubjectClassGroupsAvgFields
  count(columns: [SubjectClassGroupsSelectColumn!], distinct: Boolean): Int!
  max: SubjectClassGroupsMaxFields
  min: SubjectClassGroupsMinFields
  stddev: SubjectClassGroupsStddevFields
  stddevPop: SubjectClassGroupsStddevPopFields
  stddevSamp: SubjectClassGroupsStddevSampFields
  sum: SubjectClassGroupsSumFields
  varPop: SubjectClassGroupsVarPopFields
  varSamp: SubjectClassGroupsVarSampFields
  variance: SubjectClassGroupsVarianceFields
}

# order by aggregate values of table "subject_class_groups"
input SubjectClassGroupsAggregateOrderBy {
  avg: SubjectClassGroupsAvgOrderBy
  count: OrderBy
  max: SubjectClassGroupsMaxOrderBy
  min: SubjectClassGroupsMinOrderBy
  stddev: SubjectClassGroupsStddevOrderBy
  stddevPop: SubjectClassGroupsStddevPopOrderBy
  stddevSamp: SubjectClassGroupsStddevSampOrderBy
  sum: SubjectClassGroupsSumOrderBy
  varPop: SubjectClassGroupsVarPopOrderBy
  varSamp: SubjectClassGroupsVarSampOrderBy
  variance: SubjectClassGroupsVarianceOrderBy
}

# input type for inserting array relation for remote table "subject_class_groups"
input SubjectClassGroupsArrRelInsertInput {
  data: [SubjectClassGroupsInsertInput!]!

  # upsert condition
  onConflict: SubjectClassGroupsOnConflict
}

# aggregate avg on columns
type SubjectClassGroupsAvgFields {
  classGroupId: Float
  subjectId: Float
}

# order by avg() on columns of table "subject_class_groups"
input SubjectClassGroupsAvgOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# Boolean expression to filter rows from the table "subject_class_groups". All fields are combined with a logical 'AND'.
input SubjectClassGroupsBoolExp {
  _and: [SubjectClassGroupsBoolExp!]
  _not: SubjectClassGroupsBoolExp
  _or: [SubjectClassGroupsBoolExp!]
  classGroup: ClassGroupBoolExp
  classGroupId: BigintComparisonExp
  subject: SubjectBoolExp
  subjectId: BigintComparisonExp
}

# unique or primary key constraints on table "subject_class_groups"
enum SubjectClassGroupsConstraint {
  # unique or primary key constraint on columns "class_group_id", "subject_id"
  subject_class_groups_pkey
}

# input type for incrementing numeric columns in table "subject_class_groups"
input SubjectClassGroupsIncInput {
  classGroupId: bigint
  subjectId: bigint
}

# input type for inserting data into table "subject_class_groups"
input SubjectClassGroupsInsertInput {
  classGroup: ClassGroupObjRelInsertInput
  classGroupId: bigint
  subject: SubjectObjRelInsertInput
  subjectId: bigint
}

# aggregate max on columns
type SubjectClassGroupsMaxFields {
  classGroupId: bigint
  subjectId: bigint
}

# order by max() on columns of table "subject_class_groups"
input SubjectClassGroupsMaxOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# aggregate min on columns
type SubjectClassGroupsMinFields {
  classGroupId: bigint
  subjectId: bigint
}

# order by min() on columns of table "subject_class_groups"
input SubjectClassGroupsMinOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# response of any mutation on the table "subject_class_groups"
type SubjectClassGroupsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [SubjectClassGroups!]!
}

# on_conflict condition type for table "subject_class_groups"
input SubjectClassGroupsOnConflict {
  constraint: SubjectClassGroupsConstraint!
  updateColumns: [SubjectClassGroupsUpdateColumn!]! = []
  where: SubjectClassGroupsBoolExp
}

# Ordering options when selecting data from "subject_class_groups".
input SubjectClassGroupsOrderBy {
  classGroup: ClassGroupOrderBy
  classGroupId: OrderBy
  subject: SubjectOrderBy
  subjectId: OrderBy
}

# primary key columns input for table: subject_class_groups
input SubjectClassGroupsPkColumnsInput {
  classGroupId: bigint!
  subjectId: bigint!
}

# select columns of table "subject_class_groups"
enum SubjectClassGroupsSelectColumn {
  # column name
  classGroupId

  # column name
  subjectId
}

# input type for updating data in table "subject_class_groups"
input SubjectClassGroupsSetInput {
  classGroupId: bigint
  subjectId: bigint
}

# aggregate stddev on columns
type SubjectClassGroupsStddevFields {
  classGroupId: Float
  subjectId: Float
}

# order by stddev() on columns of table "subject_class_groups"
input SubjectClassGroupsStddevOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# aggregate stddevPop on columns
type SubjectClassGroupsStddevPopFields {
  classGroupId: Float
  subjectId: Float
}

# order by stddevPop() on columns of table "subject_class_groups"
input SubjectClassGroupsStddevPopOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# aggregate stddevSamp on columns
type SubjectClassGroupsStddevSampFields {
  classGroupId: Float
  subjectId: Float
}

# order by stddevSamp() on columns of table "subject_class_groups"
input SubjectClassGroupsStddevSampOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# Streaming cursor of the table "subject_class_groups"
input SubjectClassGroupsStreamCursorInput {
  # Stream column input with initial value
  initialValue: SubjectClassGroupsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input SubjectClassGroupsStreamCursorValueInput {
  classGroupId: bigint
  subjectId: bigint
}

# aggregate sum on columns
type SubjectClassGroupsSumFields {
  classGroupId: bigint
  subjectId: bigint
}

# order by sum() on columns of table "subject_class_groups"
input SubjectClassGroupsSumOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# update columns of table "subject_class_groups"
enum SubjectClassGroupsUpdateColumn {
  # column name
  classGroupId

  # column name
  subjectId
}

input SubjectClassGroupsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: SubjectClassGroupsIncInput

  # sets the columns of the filtered rows to the given values
  _set: SubjectClassGroupsSetInput

  # filter the rows which have to be updated
  where: SubjectClassGroupsBoolExp!
}

# aggregate variance on columns
type SubjectClassGroupsVarianceFields {
  classGroupId: Float
  subjectId: Float
}

# order by variance() on columns of table "subject_class_groups"
input SubjectClassGroupsVarianceOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# aggregate varPop on columns
type SubjectClassGroupsVarPopFields {
  classGroupId: Float
  subjectId: Float
}

# order by varPop() on columns of table "subject_class_groups"
input SubjectClassGroupsVarPopOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# aggregate varSamp on columns
type SubjectClassGroupsVarSampFields {
  classGroupId: Float
  subjectId: Float
}

# order by varSamp() on columns of table "subject_class_groups"
input SubjectClassGroupsVarSampOrderBy {
  classGroupId: OrderBy
  subjectId: OrderBy
}

# unique or primary key constraints on table "subject"
enum SubjectConstraint {
  # unique or primary key constraint on columns "id"
  subject_pkey
}

# input type for incrementing numeric columns in table "subject"
input SubjectIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "subject"
input SubjectInsertInput {
  classGroupTeacherSubjects: ClassGroupTeacherSubjectsArrRelInsertInput
  code: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  documents: DocumentArrRelInsertInput
  englishName: String
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  name: String
  subjectClassGroups: SubjectClassGroupsArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type SubjectMaxFields {
  code: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  englishName: String
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  name: String
  tenantId: bigint
  type: String
}

# order by max() on columns of table "subject"
input SubjectMaxOrderBy {
  code: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  englishName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  name: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type SubjectMinFields {
  code: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  englishName: String
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  name: String
  tenantId: bigint
  type: String
}

# order by min() on columns of table "subject"
input SubjectMinOrderBy {
  code: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  englishName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  name: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "subject"
type SubjectMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Subject!]!
}

# input type for inserting object relation for remote table "subject"
input SubjectObjRelInsertInput {
  data: SubjectInsertInput!

  # upsert condition
  onConflict: SubjectOnConflict
}

# on_conflict condition type for table "subject"
input SubjectOnConflict {
  constraint: SubjectConstraint!
  updateColumns: [SubjectUpdateColumn!]! = []
  where: SubjectBoolExp
}

# Ordering options when selecting data from "subject".
input SubjectOrderBy {
  classGroupTeacherSubjectsAggregate: ClassGroupTeacherSubjectsAggregateOrderBy
  code: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  documentsAggregate: DocumentAggregateOrderBy
  englishName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  name: OrderBy
  subjectClassGroupsAggregate: SubjectClassGroupsAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: subject
input SubjectPkColumnsInput {
  id: bigint!
}

# select columns of table "subject"
enum SubjectSelectColumn {
  # column name
  code

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  englishName

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  name

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "subject"
input SubjectSetInput {
  code: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  englishName: String
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  name: String
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type SubjectStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "subject"
input SubjectStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type SubjectStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "subject"
input SubjectStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type SubjectStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "subject"
input SubjectStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "subject"
input SubjectStreamCursorInput {
  # Stream column input with initial value
  initialValue: SubjectStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input SubjectStreamCursorValueInput {
  code: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  englishName: String
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  name: String
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type SubjectSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "subject"
input SubjectSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "subject"
enum SubjectUpdateColumn {
  # column name
  code

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  englishName

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  name

  # column name
  tenantId

  # column name
  type
}

input SubjectUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: SubjectIncInput

  # sets the columns of the filtered rows to the given values
  _set: SubjectSetInput

  # filter the rows which have to be updated
  where: SubjectBoolExp!
}

# aggregate variance on columns
type SubjectVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "subject"
input SubjectVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type SubjectVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "subject"
input SubjectVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type SubjectVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "subject"
input SubjectVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

type Subscription {
  # fetch data from the table: "account"
  account(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # fetch aggregated fields from the table: "account"
  accountAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # fetch data from the table: "account_allocate"
  accountAllocate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # fetch aggregated fields from the table: "account_allocate"
  accountAllocateAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!

  # fetch data from the table: "account_allocate" using primary key columns
  accountAllocateByPk(id: bigint!): AccountAllocate

  # fetch data from the table in a streaming manner: "account_allocate"
  accountAllocateStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [AccountAllocateStreamCursorInput]!

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # fetch data from the table: "account" using primary key columns
  accountByPk(id: bigint!): Account

  # fetch data from the table in a streaming manner: "account"
  accountStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [AccountStreamCursorInput]!

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # fetch data from the table: "action"
  action(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch aggregated fields from the table: "action"
  actionAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # fetch data from the table: "action" using primary key columns
  actionByPk(id: bigint!): Action

  # fetch data from the table in a streaming manner: "action"
  actionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActionStreamCursorInput]!

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch data from the table: "actor"
  actor(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # fetch aggregated fields from the table: "actor"
  actorAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # fetch data from the table: "actor" using primary key columns
  actorByPk(id: bigint!): Actor

  # fetch data from the table: "actor_image"
  actorImage(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch aggregated fields from the table: "actor_image"
  actorImageAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # fetch data from the table: "actor_image" using primary key columns
  actorImageByPk(id: bigint!): ActorImage

  # fetch data from the table in a streaming manner: "actor_image"
  actorImageStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorImageStreamCursorInput]!

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch data from the table in a streaming manner: "actor"
  actorStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorStreamCursorInput]!

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): [ActorTags!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): ActorTagsAggregate!

  # fetch data from the table: "actor_tags" using primary key columns
  actorTagsByPk(actorId: bigint!, tagId: bigint!): ActorTags

  # fetch data from the table in a streaming manner: "actor_tags"
  actorTagsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorTagsStreamCursorInput]!

    # filter the rows returned
    where: ActorTagsBoolExp
  ): [ActorTags!]!

  # fetch data from the table: "address"
  address(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch aggregated fields from the table: "address"
  addressAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # fetch data from the table: "address" using primary key columns
  addressByPk(id: bigint!): Address

  # fetch data from the table in a streaming manner: "address"
  addressStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [AddressStreamCursorInput]!

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch data from the table: "bank_info"
  bankInfo(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch aggregated fields from the table: "bank_info"
  bankInfoAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # fetch data from the table: "bank_info" using primary key columns
  bankInfoByPk(id: bigint!): BankInfo

  # fetch data from the table in a streaming manner: "bank_info"
  bankInfoStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [BankInfoStreamCursorInput]!

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch data from the table: "bot"
  bot(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # fetch aggregated fields from the table: "bot"
  botAggregate(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): BotAggregate!

  # fetch data from the table: "bot" using primary key columns
  botByPk(id: bigint!): Bot

  # fetch data from the table in a streaming manner: "bot"
  botStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [BotStreamCursorInput]!

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # fetch data from the table: "campus"
  campus(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch aggregated fields from the table: "campus"
  campusAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # fetch data from the table: "campus" using primary key columns
  campusByPk(id: bigint!): Campus

  # fetch data from the table: "campus_cluster"
  campusCluster(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch aggregated fields from the table: "campus_cluster"
  campusClusterAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # fetch data from the table: "campus_cluster" using primary key columns
  campusClusterByPk(id: bigint!): CampusCluster

  # fetch data from the table in a streaming manner: "campus_cluster"
  campusClusterStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CampusClusterStreamCursorInput]!

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch data from the table in a streaming manner: "campus"
  campusStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CampusStreamCursorInput]!

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch data from the table: "canteen"
  canteen(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): [Canteen!]!

  # fetch aggregated fields from the table: "canteen"
  canteenAggregate(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): CanteenAggregate!

  # fetch data from the table: "canteen" using primary key columns
  canteenByPk(id: bigint!): Canteen

  # fetch data from the table: "canteen_food"
  canteenFood(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # fetch aggregated fields from the table: "canteen_food"
  canteenFoodAggregate(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): CanteenFoodAggregate!

  # fetch data from the table: "canteen_food" using primary key columns
  canteenFoodByPk(id: bigint!): CanteenFood

  # fetch data from the table in a streaming manner: "canteen_food"
  canteenFoodStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CanteenFoodStreamCursorInput]!

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # fetch data from the table: "canteen_menu"
  canteenMenu(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # fetch aggregated fields from the table: "canteen_menu"
  canteenMenuAggregate(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): CanteenMenuAggregate!

  # fetch data from the table: "canteen_menu" using primary key columns
  canteenMenuByPk(id: bigint!): CanteenMenu

  # fetch data from the table in a streaming manner: "canteen_menu"
  canteenMenuStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CanteenMenuStreamCursorInput]!

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # fetch data from the table in a streaming manner: "canteen"
  canteenStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CanteenStreamCursorInput]!

    # filter the rows returned
    where: CanteenBoolExp
  ): [Canteen!]!

  # fetch data from the table: "class_group"
  classGroup(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): [ClassGroup!]!

  # fetch aggregated fields from the table: "class_group"
  classGroupAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): ClassGroupAggregate!

  # fetch data from the table: "class_group" using primary key columns
  classGroupByPk(id: bigint!): ClassGroup

  # fetch data from the table in a streaming manner: "class_group"
  classGroupStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ClassGroupStreamCursorInput]!

    # filter the rows returned
    where: ClassGroupBoolExp
  ): [ClassGroup!]!

  # fetch data from the table: "class_group_teacher"
  classGroupTeacher(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # fetch aggregated fields from the table: "class_group_teacher"
  classGroupTeacherAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!

  # fetch data from the table: "class_group_teacher" using primary key columns
  classGroupTeacherByPk(id: bigint!): ClassGroupTeacher

  # fetch data from the table in a streaming manner: "class_group_teacher"
  classGroupTeacherStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ClassGroupTeacherStreamCursorInput]!

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # An array relationship
  classGroupTeacherSubjects(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): [ClassGroupTeacherSubjects!]!

  # An aggregate relationship
  classGroupTeacherSubjectsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSubjectsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherSubjectsOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): ClassGroupTeacherSubjectsAggregate!

  # fetch data from the table: "class_group_teacher_subjects" using primary key columns
  classGroupTeacherSubjectsByPk(classGroupTeacherId: bigint!, subjectId: bigint!): ClassGroupTeacherSubjects

  # fetch data from the table in a streaming manner: "class_group_teacher_subjects"
  classGroupTeacherSubjectsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ClassGroupTeacherSubjectsStreamCursorInput]!

    # filter the rows returned
    where: ClassGroupTeacherSubjectsBoolExp
  ): [ClassGroupTeacherSubjects!]!

  # fetch data from the table: "cohort"
  cohort(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): [Cohort!]!

  # fetch aggregated fields from the table: "cohort"
  cohortAggregate(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): CohortAggregate!

  # fetch data from the table: "cohort" using primary key columns
  cohortByPk(id: bigint!): Cohort

  # fetch data from the table in a streaming manner: "cohort"
  cohortStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CohortStreamCursorInput]!

    # filter the rows returned
    where: CohortBoolExp
  ): [Cohort!]!

  # fetch data from the table: "content"
  content(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # fetch aggregated fields from the table: "content"
  contentAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!

  # An array relationship
  contentAttachments(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): [ContentAttachments!]!

  # An aggregate relationship
  contentAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ContentAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentAttachmentsOrderBy!]

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): ContentAttachmentsAggregate!

  # fetch data from the table: "content_attachments" using primary key columns
  contentAttachmentsByPk(contentId: bigint!, fileUploadId: bigint!): ContentAttachments

  # fetch data from the table in a streaming manner: "content_attachments"
  contentAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ContentAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: ContentAttachmentsBoolExp
  ): [ContentAttachments!]!

  # fetch data from the table: "content" using primary key columns
  contentByPk(id: bigint!): Content

  # fetch data from the table in a streaming manner: "content"
  contentStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ContentStreamCursorInput]!

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # fetch data from the table: "document"
  document(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # fetch aggregated fields from the table: "document"
  documentAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!

  # fetch data from the table: "document" using primary key columns
  documentByPk(id: bigint!): Document

  # fetch data from the table in a streaming manner: "document"
  documentStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [DocumentStreamCursorInput]!

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # fetch aggregated fields from the table: "event"
  eventAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # fetch data from the table: "event_approval"
  eventApproval(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch aggregated fields from the table: "event_approval"
  eventApprovalAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # fetch data from the table: "event_approval" using primary key columns
  eventApprovalByPk(id: bigint!): EventApproval

  # fetch data from the table: "event_approval_step"
  eventApprovalStep(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # fetch aggregated fields from the table: "event_approval_step"
  eventApprovalStepAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # fetch data from the table: "event_approval_step" using primary key columns
  eventApprovalStepByPk(id: bigint!): EventApprovalStep

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # fetch data from the table: "event_approval_step_notifiees" using primary key columns
  eventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepNotifiees

  # fetch data from the table in a streaming manner: "event_approval_step_notifiees"
  eventApprovalStepNotifieesStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepNotifieesStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # fetch data from the table in a streaming manner: "event_approval_step"
  eventApprovalStepStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # fetch data from the table: "event_approval_step_validators" using primary key columns
  eventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, individualId: bigint!): EventApprovalStepValidators

  # fetch data from the table in a streaming manner: "event_approval_step_validators"
  eventApprovalStepValidatorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepValidatorsStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # fetch data from the table in a streaming manner: "event_approval"
  eventApprovalStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch data from the table: "event" using primary key columns
  eventByPk(id: bigint!): Event

  # fetch data from the table: "event_join"
  eventJoin(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch aggregated fields from the table: "event_join"
  eventJoinAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # fetch data from the table: "event_join" using primary key columns
  eventJoinByPk(id: bigint!): EventJoin

  # fetch data from the table in a streaming manner: "event_join"
  eventJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventJoinStreamCursorInput]!

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch data from the table: "event_manage"
  eventManage(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # fetch aggregated fields from the table: "event_manage"
  eventManageAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # fetch data from the table: "event_manage" using primary key columns
  eventManageByPk(id: bigint!): EventManage

  # fetch data from the table in a streaming manner: "event_manage"
  eventManageStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventManageStreamCursorInput]!

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # fetch data from the table in a streaming manner: "event"
  eventStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventStreamCursorInput]!

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): [EventSupervisors!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): EventSupervisorsAggregate!

  # fetch data from the table: "event_supervisors" using primary key columns
  eventSupervisorsByPk(eventId: bigint!, userId: bigint!): EventSupervisors

  # fetch data from the table in a streaming manner: "event_supervisors"
  eventSupervisorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventSupervisorsStreamCursorInput]!

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): [EventSupervisors!]!

  # An array relationship
  eventTags(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): [EventTags!]!

  # An aggregate relationship
  eventTagsAggregate(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): EventTagsAggregate!

  # fetch data from the table: "event_tags" using primary key columns
  eventTagsByPk(eventId: bigint!, tagId: bigint!): EventTags

  # fetch data from the table in a streaming manner: "event_tags"
  eventTagsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventTagsStreamCursorInput]!

    # filter the rows returned
    where: EventTagsBoolExp
  ): [EventTags!]!

  # fetch data from the table: "expense"
  expense(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch aggregated fields from the table: "expense"
  expenseAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # fetch data from the table: "expense" using primary key columns
  expenseByPk(id: bigint!): Expense

  # fetch data from the table: "expense_item"
  expenseItem(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch aggregated fields from the table: "expense_item"
  expenseItemAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # fetch data from the table: "expense_item_attachments" using primary key columns
  expenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # fetch data from the table in a streaming manner: "expense_item_attachments"
  expenseItemAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseItemAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # fetch data from the table: "expense_item" using primary key columns
  expenseItemByPk(id: bigint!): ExpenseItem

  # fetch data from the table in a streaming manner: "expense_item"
  expenseItemStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseItemStreamCursorInput]!

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch data from the table in a streaming manner: "expense"
  expenseStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseStreamCursorInput]!

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch data from the table: "favorite"
  favorite(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # fetch aggregated fields from the table: "favorite"
  favoriteAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!

  # fetch data from the table: "favorite" using primary key columns
  favoriteByPk(id: bigint!): Favorite

  # fetch data from the table in a streaming manner: "favorite"
  favoriteStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FavoriteStreamCursorInput]!

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # fetch data from the table: "file_upload"
  fileUpload(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch aggregated fields from the table: "file_upload"
  fileUploadAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # fetch data from the table: "file_upload" using primary key columns
  fileUploadByPk(id: bigint!): FileUpload

  # fetch data from the table in a streaming manner: "file_upload"
  fileUploadStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FileUploadStreamCursorInput]!

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch data from the table: "finance"
  finance(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # fetch aggregated fields from the table: "finance"
  financeAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  financeAttachments(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): [FinanceAttachments!]!

  # An aggregate relationship
  financeAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FinanceAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceAttachmentsOrderBy!]

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): FinanceAttachmentsAggregate!

  # fetch data from the table: "finance_attachments" using primary key columns
  financeAttachmentsByPk(fileUploadId: bigint!, financeId: bigint!): FinanceAttachments

  # fetch data from the table in a streaming manner: "finance_attachments"
  financeAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FinanceAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: FinanceAttachmentsBoolExp
  ): [FinanceAttachments!]!

  # fetch data from the table: "finance" using primary key columns
  financeByPk(id: bigint!): Finance

  # fetch data from the table in a streaming manner: "finance"
  financeStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FinanceStreamCursorInput]!

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # fetch data from the table: "follow"
  follow(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch aggregated fields from the table: "follow"
  followAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # fetch data from the table: "follow" using primary key columns
  followByPk(id: bigint!): Follow

  # fetch data from the table in a streaming manner: "follow"
  followStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FollowStreamCursorInput]!

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch data from the table: "form"
  form(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch aggregated fields from the table: "form"
  formAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # fetch data from the table: "form" using primary key columns
  formByPk(id: bigint!): Form

  # fetch data from the table in a streaming manner: "form"
  formStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FormStreamCursorInput]!

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch data from the table: "form_submission"
  formSubmission(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch aggregated fields from the table: "form_submission"
  formSubmissionAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # fetch data from the table: "form_submission" using primary key columns
  formSubmissionByPk(id: bigint!): FormSubmission

  # fetch data from the table in a streaming manner: "form_submission"
  formSubmissionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FormSubmissionStreamCursorInput]!

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch data from the table: "grant"
  grant(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch aggregated fields from the table: "grant"
  grantAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # fetch data from the table: "grant_attachments" using primary key columns
  grantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # fetch data from the table in a streaming manner: "grant_attachments"
  grantAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # fetch data from the table: "grant" using primary key columns
  grantByPk(id: bigint!): Grant

  # fetch data from the table in a streaming manner: "grant"
  grantStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantStreamCursorInput]!

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch data from the table: "grant_unlock"
  grantUnlock(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # fetch aggregated fields from the table: "grant_unlock"
  grantUnlockAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  grantUnlockAttachments(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): [GrantUnlockAttachments!]!

  # An aggregate relationship
  grantUnlockAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): GrantUnlockAttachmentsAggregate!

  # fetch data from the table: "grant_unlock_attachments" using primary key columns
  grantUnlockAttachmentsByPk(fileUploadId: bigint!, grantUnlockId: bigint!): GrantUnlockAttachments

  # fetch data from the table in a streaming manner: "grant_unlock_attachments"
  grantUnlockAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantUnlockAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: GrantUnlockAttachmentsBoolExp
  ): [GrantUnlockAttachments!]!

  # fetch data from the table: "grant_unlock" using primary key columns
  grantUnlockByPk(id: bigint!): GrantUnlock

  # fetch data from the table in a streaming manner: "grant_unlock"
  grantUnlockStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantUnlockStreamCursorInput]!

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # fetch data from the table: "individual"
  individual(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): [Individual!]!

  # fetch aggregated fields from the table: "individual"
  individualAggregate(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): IndividualAggregate!

  # fetch data from the table: "individual" using primary key columns
  individualByPk(id: bigint!): Individual

  # fetch data from the table in a streaming manner: "individual"
  individualStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [IndividualStreamCursorInput]!

    # filter the rows returned
    where: IndividualBoolExp
  ): [Individual!]!

  # fetch data from the table: "issue"
  issue(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): [Issue!]!

  # fetch aggregated fields from the table: "issue"
  issueAggregate(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): IssueAggregate!

  # fetch data from the table: "issue" using primary key columns
  issueByPk(id: bigint!): Issue

  # An array relationship
  issueContributors(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): [IssueContributors!]!

  # An aggregate relationship
  issueContributorsAggregate(
    # distinct select on columns
    distinctOn: [IssueContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueContributorsOrderBy!]

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): IssueContributorsAggregate!

  # fetch data from the table: "issue_contributors" using primary key columns
  issueContributorsByPk(individualId: bigint!, issueId: bigint!): IssueContributors

  # fetch data from the table in a streaming manner: "issue_contributors"
  issueContributorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [IssueContributorsStreamCursorInput]!

    # filter the rows returned
    where: IssueContributorsBoolExp
  ): [IssueContributors!]!

  # fetch data from the table in a streaming manner: "issue"
  issueStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [IssueStreamCursorInput]!

    # filter the rows returned
    where: IssueBoolExp
  ): [Issue!]!

  # An array relationship
  issueTags(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): [IssueTags!]!

  # An aggregate relationship
  issueTagsAggregate(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): IssueTagsAggregate!

  # fetch data from the table: "issue_tags" using primary key columns
  issueTagsByPk(issueId: bigint!, tagId: bigint!): IssueTags

  # fetch data from the table in a streaming manner: "issue_tags"
  issueTagsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [IssueTagsStreamCursorInput]!

    # filter the rows returned
    where: IssueTagsBoolExp
  ): [IssueTags!]!

  # fetch data from the table: "legal_unit"
  legalUnit(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch aggregated fields from the table: "legal_unit"
  legalUnitAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # fetch data from the table: "legal_unit" using primary key columns
  legalUnitByPk(id: bigint!): LegalUnit

  # fetch data from the table in a streaming manner: "legal_unit"
  legalUnitStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [LegalUnitStreamCursorInput]!

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch data from the table: "mission"
  mission(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch aggregated fields from the table: "mission"
  missionAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # fetch data from the table: "mission" using primary key columns
  missionByPk(id: bigint!): Mission

  # fetch data from the table: "mission_join"
  missionJoin(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch aggregated fields from the table: "mission_join"
  missionJoinAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # fetch data from the table: "mission_join" using primary key columns
  missionJoinByPk(id: bigint!): MissionJoin

  # fetch data from the table in a streaming manner: "mission_join"
  missionJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [MissionJoinStreamCursorInput]!

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch data from the table in a streaming manner: "mission"
  missionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [MissionStreamCursorInput]!

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch data from the table: "pole"
  pole(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch aggregated fields from the table: "pole"
  poleAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # fetch data from the table: "pole" using primary key columns
  poleByPk(id: bigint!): Pole

  # fetch data from the table in a streaming manner: "pole"
  poleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [PoleStreamCursorInput]!

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch data from the table: "project"
  project(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # fetch aggregated fields from the table: "project"
  projectAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # fetch data from the table: "project" using primary key columns
  projectByPk(id: bigint!): Project

  # fetch data from the table in a streaming manner: "project"
  projectStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ProjectStreamCursorInput]!

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # fetch data from the table: "project_supervisors" using primary key columns
  projectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # fetch data from the table in a streaming manner: "project_supervisors"
  projectSupervisorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ProjectSupervisorsStreamCursorInput]!

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An array relationship
  projectTags(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): [ProjectTags!]!

  # An aggregate relationship
  projectTagsAggregate(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): ProjectTagsAggregate!

  # fetch data from the table: "project_tags" using primary key columns
  projectTagsByPk(projectId: bigint!, tagId: bigint!): ProjectTags

  # fetch data from the table in a streaming manner: "project_tags"
  projectTagsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ProjectTagsStreamCursorInput]!

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): [ProjectTags!]!

  # fetch data from the table: "reaction"
  reaction(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # fetch aggregated fields from the table: "reaction"
  reactionAggregate(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): ReactionAggregate!

  # fetch data from the table: "reaction" using primary key columns
  reactionByPk(id: bigint!): Reaction

  # fetch data from the table in a streaming manner: "reaction"
  reactionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ReactionStreamCursorInput]!

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # fetch data from the table: "report"
  report(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # fetch aggregated fields from the table: "report"
  reportAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # fetch data from the table: "report" using primary key columns
  reportByPk(id: bigint!): Report

  # fetch data from the table in a streaming manner: "report"
  reportStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ReportStreamCursorInput]!

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # fetch data from the table: "role"
  role(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # fetch aggregated fields from the table: "role"
  roleAggregate(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): RoleAggregate!

  # fetch data from the table: "role" using primary key columns
  roleByPk(id: bigint!): Role

  # fetch data from the table in a streaming manner: "role"
  roleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [RoleStreamCursorInput]!

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # fetch data from the table: "session"
  session(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # fetch aggregated fields from the table: "session"
  sessionAggregate(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): SessionAggregate!

  # fetch data from the table: "session" using primary key columns
  sessionByPk(id: bigint!): Session

  # fetch data from the table in a streaming manner: "session"
  sessionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [SessionStreamCursorInput]!

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # fetch data from the table: "shortcut"
  shortcut(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # fetch aggregated fields from the table: "shortcut"
  shortcutAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!

  # fetch data from the table: "shortcut" using primary key columns
  shortcutByPk(id: bigint!): Shortcut

  # fetch data from the table in a streaming manner: "shortcut"
  shortcutStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ShortcutStreamCursorInput]!

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # fetch data from the table: "social"
  social(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch aggregated fields from the table: "social"
  socialAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # fetch data from the table: "social" using primary key columns
  socialByPk(id: bigint!): Social

  # fetch data from the table in a streaming manner: "social"
  socialStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [SocialStreamCursorInput]!

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch data from the table: "subject"
  subject(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): [Subject!]!

  # fetch aggregated fields from the table: "subject"
  subjectAggregate(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): SubjectAggregate!

  # fetch data from the table: "subject" using primary key columns
  subjectByPk(id: bigint!): Subject

  # An array relationship
  subjectClassGroups(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): [SubjectClassGroups!]!

  # An aggregate relationship
  subjectClassGroupsAggregate(
    # distinct select on columns
    distinctOn: [SubjectClassGroupsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectClassGroupsOrderBy!]

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): SubjectClassGroupsAggregate!

  # fetch data from the table: "subject_class_groups" using primary key columns
  subjectClassGroupsByPk(classGroupId: bigint!, subjectId: bigint!): SubjectClassGroups

  # fetch data from the table in a streaming manner: "subject_class_groups"
  subjectClassGroupsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [SubjectClassGroupsStreamCursorInput]!

    # filter the rows returned
    where: SubjectClassGroupsBoolExp
  ): [SubjectClassGroups!]!

  # fetch data from the table in a streaming manner: "subject"
  subjectStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [SubjectStreamCursorInput]!

    # filter the rows returned
    where: SubjectBoolExp
  ): [Subject!]!

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch aggregated fields from the table: "tag"
  tagAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # fetch data from the table: "tag" using primary key columns
  tagByPk(id: bigint!): Tag

  # fetch data from the table in a streaming manner: "tag"
  tagStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TagStreamCursorInput]!

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch aggregated fields from the table: "team"
  teamAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # fetch data from the table: "team" using primary key columns
  teamByPk(id: bigint!): Team

  # fetch data from the table: "team_history"
  teamHistory(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch aggregated fields from the table: "team_history"
  teamHistoryAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # fetch data from the table: "team_history" using primary key columns
  teamHistoryByPk(id: bigint!): TeamHistory

  # fetch data from the table in a streaming manner: "team_history"
  teamHistoryStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamHistoryStreamCursorInput]!

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch data from the table: "team_join"
  teamJoin(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch aggregated fields from the table: "team_join"
  teamJoinAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # fetch data from the table: "team_join" using primary key columns
  teamJoinByPk(id: bigint!): TeamJoin

  # fetch data from the table in a streaming manner: "team_join"
  teamJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamJoinStreamCursorInput]!

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch data from the table: "team_member"
  teamMember(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch aggregated fields from the table: "team_member"
  teamMemberAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # fetch data from the table: "team_member" using primary key columns
  teamMemberByPk(id: bigint!): TeamMember

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): [TeamMemberRoles!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): TeamMemberRolesAggregate!

  # fetch data from the table: "team_member_roles" using primary key columns
  teamMemberRolesByPk(roleId: bigint!, teamMemberId: bigint!): TeamMemberRoles

  # fetch data from the table in a streaming manner: "team_member_roles"
  teamMemberRolesStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamMemberRolesStreamCursorInput]!

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): [TeamMemberRoles!]!

  # fetch data from the table in a streaming manner: "team_member"
  teamMemberStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamMemberStreamCursorInput]!

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch data from the table: "team_metric"
  teamMetric(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): [TeamMetric!]!

  # fetch aggregated fields from the table: "team_metric"
  teamMetricAggregate(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): TeamMetricAggregate!

  # fetch data from the table: "team_metric" using primary key columns
  teamMetricByPk(id: bigint!): TeamMetric

  # fetch data from the table in a streaming manner: "team_metric"
  teamMetricStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamMetricStreamCursorInput]!

    # filter the rows returned
    where: TeamMetricBoolExp
  ): [TeamMetric!]!

  # fetch data from the table in a streaming manner: "team"
  teamStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamStreamCursorInput]!

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch data from the table: "tenant"
  tenant(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch aggregated fields from the table: "tenant"
  tenantAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # fetch data from the table: "tenant" using primary key columns
  tenantByPk(id: bigint!): Tenant

  # fetch data from the table: "tenant_manage"
  tenantManage(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # fetch aggregated fields from the table: "tenant_manage"
  tenantManageAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!

  # fetch data from the table: "tenant_manage" using primary key columns
  tenantManageByPk(id: bigint!): TenantManage

  # fetch data from the table in a streaming manner: "tenant_manage"
  tenantManageStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantManageStreamCursorInput]!

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # fetch data from the table in a streaming manner: "tenant"
  tenantStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantStreamCursorInput]!

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch data from the table: "thread"
  thread(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): [Thread!]!

  # fetch aggregated fields from the table: "thread"
  threadAggregate(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): ThreadAggregate!

  # fetch data from the table: "thread" using primary key columns
  threadByPk(id: bigint!): Thread

  # An array relationship
  threadContributors(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): [ThreadContributors!]!

  # An aggregate relationship
  threadContributorsAggregate(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): ThreadContributorsAggregate!

  # fetch data from the table: "thread_contributors" using primary key columns
  threadContributorsByPk(individualId: bigint!, threadId: bigint!): ThreadContributors

  # fetch data from the table in a streaming manner: "thread_contributors"
  threadContributorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ThreadContributorsStreamCursorInput]!

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): [ThreadContributors!]!

  # fetch data from the table in a streaming manner: "thread"
  threadStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ThreadStreamCursorInput]!

    # filter the rows returned
    where: ThreadBoolExp
  ): [Thread!]!

  # An array relationship
  threadTags(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): [ThreadTags!]!

  # An aggregate relationship
  threadTagsAggregate(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): ThreadTagsAggregate!

  # fetch data from the table: "thread_tags" using primary key columns
  threadTagsByPk(tagId: bigint!, threadId: bigint!): ThreadTags

  # fetch data from the table in a streaming manner: "thread_tags"
  threadTagsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ThreadTagsStreamCursorInput]!

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): [ThreadTags!]!

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # fetch aggregated fields from the table: "user"
  userAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # fetch data from the table: "user" using primary key columns
  userByPk(id: bigint!): User

  # fetch data from the table in a streaming manner: "user"
  userStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [UserStreamCursorInput]!

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # fetch data from the table: "validation"
  validation(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # fetch aggregated fields from the table: "validation"
  validationAggregate(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): ValidationAggregate!

  # fetch data from the table: "validation" using primary key columns
  validationByPk(id: bigint!): Validation

  # fetch data from the table in a streaming manner: "validation"
  validationStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ValidationStreamCursorInput]!

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # fetch data from the table: "vote"
  vote(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!

  # fetch aggregated fields from the table: "vote"
  voteAggregate(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): VoteAggregate!

  # fetch data from the table: "vote" using primary key columns
  voteByPk(id: bigint!): Vote

  # fetch data from the table in a streaming manner: "vote"
  voteStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [VoteStreamCursorInput]!

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!
}

# columns and relationships of "tag"
type Tag {
  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): [ActorTags!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagsOrderBy!]

    # filter the rows returned
    where: ActorTagsBoolExp
  ): ActorTagsAggregate!
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  eventTags(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): [EventTags!]!

  # An aggregate relationship
  eventTagsAggregate(
    # distinct select on columns
    distinctOn: [EventTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventTagsOrderBy!]

    # filter the rows returned
    where: EventTagsBoolExp
  ): EventTagsAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  image: FileUpload
  imageId: bigint

  # An array relationship
  issueTags(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): [IssueTags!]!

  # An aggregate relationship
  issueTagsAggregate(
    # distinct select on columns
    distinctOn: [IssueTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueTagsOrderBy!]

    # filter the rows returned
    where: IssueTagsBoolExp
  ): IssueTagsAggregate!
  name: String!

  # An array relationship
  projectTags(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): [ProjectTags!]!

  # An aggregate relationship
  projectTagsAggregate(
    # distinct select on columns
    distinctOn: [ProjectTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectTagsOrderBy!]

    # filter the rows returned
    where: ProjectTagsBoolExp
  ): ProjectTagsAggregate!
  slug: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An array relationship
  threadTags(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): [ThreadTags!]!

  # An aggregate relationship
  threadTagsAggregate(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): ThreadTagsAggregate!
  type: String!
}

# aggregated selection of "tag"
type TagAggregate {
  aggregate: TagAggregateFields
  nodes: [Tag!]!
}

input TagAggregateBoolExp {
  count: tagAggregateBoolExpCount
}

input tagAggregateBoolExpCount {
  arguments: [TagSelectColumn!]
  distinct: Boolean
  filter: TagBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tag"
type TagAggregateFields {
  avg: TagAvgFields
  count(columns: [TagSelectColumn!], distinct: Boolean): Int!
  max: TagMaxFields
  min: TagMinFields
  stddev: TagStddevFields
  stddevPop: TagStddevPopFields
  stddevSamp: TagStddevSampFields
  sum: TagSumFields
  varPop: TagVarPopFields
  varSamp: TagVarSampFields
  variance: TagVarianceFields
}

# order by aggregate values of table "tag"
input TagAggregateOrderBy {
  avg: TagAvgOrderBy
  count: OrderBy
  max: TagMaxOrderBy
  min: TagMinOrderBy
  stddev: TagStddevOrderBy
  stddevPop: TagStddevPopOrderBy
  stddevSamp: TagStddevSampOrderBy
  sum: TagSumOrderBy
  varPop: TagVarPopOrderBy
  varSamp: TagVarSampOrderBy
  variance: TagVarianceOrderBy
}

# input type for inserting array relation for remote table "tag"
input TagArrRelInsertInput {
  data: [TagInsertInput!]!

  # upsert condition
  onConflict: TagOnConflict
}

# aggregate avg on columns
type TagAvgFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by avg() on columns of table "tag"
input TagAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
input TagBoolExp {
  _and: [TagBoolExp!]
  _not: TagBoolExp
  _or: [TagBoolExp!]
  actorTags: ActorTagsBoolExp
  actorTagsAggregate: ActorTagsAggregateBoolExp
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventTags: EventTagsBoolExp
  eventTagsAggregate: EventTagsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  image: FileUploadBoolExp
  imageId: BigintComparisonExp
  issueTags: IssueTagsBoolExp
  issueTagsAggregate: IssueTagsAggregateBoolExp
  name: StringComparisonExp
  projectTags: ProjectTagsBoolExp
  projectTagsAggregate: ProjectTagsAggregateBoolExp
  slug: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  threadTags: ThreadTagsBoolExp
  threadTagsAggregate: ThreadTagsAggregateBoolExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "tag"
enum TagConstraint {
  # unique or primary key constraint on columns "id"
  tag_pkey
}

# input type for incrementing numeric columns in table "tag"
input TagIncInput {
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantId: bigint
}

# input type for inserting data into table "tag"
input TagInsertInput {
  actorTags: ActorTagsArrRelInsertInput
  color: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventTags: EventTagsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  image: FileUploadObjRelInsertInput
  imageId: bigint
  issueTags: IssueTagsArrRelInsertInput
  name: String
  projectTags: ProjectTagsArrRelInsertInput
  slug: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  threadTags: ThreadTagsArrRelInsertInput
  type: String
}

# aggregate max on columns
type TagMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantId: bigint
  type: String
}

# order by max() on columns of table "tag"
input TagMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type TagMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantId: bigint
  type: String
}

# order by min() on columns of table "tag"
input TagMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "tag"
type TagMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Tag!]!
}

# input type for inserting object relation for remote table "tag"
input TagObjRelInsertInput {
  data: TagInsertInput!

  # upsert condition
  onConflict: TagOnConflict
}

# on_conflict condition type for table "tag"
input TagOnConflict {
  constraint: TagConstraint!
  updateColumns: [TagUpdateColumn!]! = []
  where: TagBoolExp
}

# Ordering options when selecting data from "tag".
input TagOrderBy {
  actorTagsAggregate: ActorTagsAggregateOrderBy
  color: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventTagsAggregate: EventTagsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  image: FileUploadOrderBy
  imageId: OrderBy
  issueTagsAggregate: IssueTagsAggregateOrderBy
  name: OrderBy
  projectTagsAggregate: ProjectTagsAggregateOrderBy
  slug: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  threadTagsAggregate: ThreadTagsAggregateOrderBy
  type: OrderBy
}

# primary key columns input for table: tag
input TagPkColumnsInput {
  id: bigint!
}

# select columns of table "tag"
enum TagSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  name

  # column name
  slug

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "tag"
input TagSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type TagStddevFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddev() on columns of table "tag"
input TagStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type TagStddevPopFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "tag"
input TagStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type TagStddevSampFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "tag"
input TagStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "tag"
input TagStreamCursorInput {
  # Stream column input with initial value
  initialValue: TagStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TagStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type TagSumFields {
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "tag"
input TagSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# update columns of table "tag"
enum TagUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  name

  # column name
  slug

  # column name
  tenantId

  # column name
  type
}

input TagUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TagIncInput

  # sets the columns of the filtered rows to the given values
  _set: TagSetInput

  # filter the rows which have to be updated
  where: TagBoolExp!
}

# aggregate variance on columns
type TagVarianceFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by variance() on columns of table "tag"
input TagVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type TagVarPopFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by varPop() on columns of table "tag"
input TagVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type TagVarSampFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "tag"
input TagVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "team"
type Team {
  # An array relationship
  accountAllocates(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # An aggregate relationship
  accountAllocatesAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!

  # An array relationship
  accounts(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # An aggregate relationship
  accountsAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  actor: Actor

  # An object relationship
  canteen: Canteen
  canteenId: bigint

  # An object relationship
  classGroup: ClassGroup
  classGroupId: bigint

  # An object relationship
  cohort: Cohort
  cohortId: bigint

  # An array relationship
  contents(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # An aggregate relationship
  contentsAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  currentFinance: Float!
  deletedAt: timestamptz
  directorsCategoryName: String!

  # An array relationship
  documents(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # An aggregate relationship
  documentsAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!

  # An array relationship
  eventManages(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # An aggregate relationship
  eventManagesAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # An array relationship
  finances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  financesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An object relationship
  form: Form

  # An object relationship
  grantFund: LegalUnit

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isJoinFormActive: Boolean!
  managersCategoryName: String!
  membersCategoryName: String!
  membershipDuration: String!
  membershipFees: Float!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!
  parentId: bigint

  # An array relationship
  poles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  polesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  roles(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # An aggregate relationship
  rolesAggregate(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): RoleAggregate!

  # An object relationship
  team: Team

  # An array relationship
  teamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  teamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  teams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  teamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An object relationship
  tenant: Tenant!
  tenantGrantFundId: bigint
  tenantId: bigint!

  # An array relationship
  tenantManages(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # An aggregate relationship
  tenantManagesAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!
  type: String!

  # An object relationship
  video: FileUpload
  videoId: bigint
}

# aggregated selection of "team"
type TeamAggregate {
  aggregate: TeamAggregateFields
  nodes: [Team!]!
}

input TeamAggregateBoolExp {
  bool_and: teamAggregateBoolExpBool_and
  bool_or: teamAggregateBoolExpBool_or
  count: teamAggregateBoolExpCount
}

input teamAggregateBoolExpBool_and {
  arguments: TeamSelectColumnTeamAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TeamBoolExp
  predicate: BooleanComparisonExp!
}

input teamAggregateBoolExpBool_or {
  arguments: TeamSelectColumnTeamAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TeamBoolExp
  predicate: BooleanComparisonExp!
}

input teamAggregateBoolExpCount {
  arguments: [TeamSelectColumn!]
  distinct: Boolean
  filter: TeamBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team"
type TeamAggregateFields {
  avg: TeamAvgFields
  count(columns: [TeamSelectColumn!], distinct: Boolean): Int!
  max: TeamMaxFields
  min: TeamMinFields
  stddev: TeamStddevFields
  stddevPop: TeamStddevPopFields
  stddevSamp: TeamStddevSampFields
  sum: TeamSumFields
  varPop: TeamVarPopFields
  varSamp: TeamVarSampFields
  variance: TeamVarianceFields
}

# order by aggregate values of table "team"
input TeamAggregateOrderBy {
  avg: TeamAvgOrderBy
  count: OrderBy
  max: TeamMaxOrderBy
  min: TeamMinOrderBy
  stddev: TeamStddevOrderBy
  stddevPop: TeamStddevPopOrderBy
  stddevSamp: TeamStddevSampOrderBy
  sum: TeamSumOrderBy
  varPop: TeamVarPopOrderBy
  varSamp: TeamVarSampOrderBy
  variance: TeamVarianceOrderBy
}

# input type for inserting array relation for remote table "team"
input TeamArrRelInsertInput {
  data: [TeamInsertInput!]!

  # upsert condition
  onConflict: TeamOnConflict
}

# aggregate avg on columns
type TeamAvgFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by avg() on columns of table "team"
input TeamAvgOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
input TeamBoolExp {
  _and: [TeamBoolExp!]
  _not: TeamBoolExp
  _or: [TeamBoolExp!]
  accountAllocates: AccountAllocateBoolExp
  accountAllocatesAggregate: AccountAllocateAggregateBoolExp
  accounts: AccountBoolExp
  accountsAggregate: AccountAggregateBoolExp
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  actor: ActorBoolExp
  canteen: CanteenBoolExp
  canteenId: BigintComparisonExp
  classGroup: ClassGroupBoolExp
  classGroupId: BigintComparisonExp
  cohort: CohortBoolExp
  cohortId: BigintComparisonExp
  contents: ContentBoolExp
  contentsAggregate: ContentAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  currentFinance: FloatComparisonExp
  deletedAt: TimestamptzComparisonExp
  directorsCategoryName: StringComparisonExp
  documents: DocumentBoolExp
  documentsAggregate: DocumentAggregateBoolExp
  eventManages: EventManageBoolExp
  eventManagesAggregate: EventManageAggregateBoolExp
  finances: FinanceBoolExp
  financesAggregate: FinanceAggregateBoolExp
  form: FormBoolExp
  grantFund: LegalUnitBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isJoinFormActive: BooleanComparisonExp
  managersCategoryName: StringComparisonExp
  membersCategoryName: StringComparisonExp
  membershipDuration: StringComparisonExp
  membershipFees: FloatComparisonExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  parentId: BigintComparisonExp
  poles: PoleBoolExp
  polesAggregate: PoleAggregateBoolExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  roles: RoleBoolExp
  rolesAggregate: RoleAggregateBoolExp
  team: TeamBoolExp
  teamHistories: TeamHistoryBoolExp
  teamHistoriesAggregate: TeamHistoryAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMembers: TeamMemberBoolExp
  teamMembersAggregate: TeamMemberAggregateBoolExp
  teams: TeamBoolExp
  teamsAggregate: TeamAggregateBoolExp
  tenant: TenantBoolExp
  tenantGrantFundId: BigintComparisonExp
  tenantId: BigintComparisonExp
  tenantManages: TenantManageBoolExp
  tenantManagesAggregate: TenantManageAggregateBoolExp
  type: StringComparisonExp
  video: FileUploadBoolExp
  videoId: BigintComparisonExp
}

# unique or primary key constraints on table "team"
enum TeamConstraint {
  # unique or primary key constraint on columns "canteen_id"
  team_canteen_id_unique

  # unique or primary key constraint on columns "class_group_id"
  team_class_group_id_unique

  # unique or primary key constraint on columns "cohort_id"
  team_cohort_id_unique

  # unique or primary key constraint on columns "id"
  team_pkey
}

# columns and relationships of "team_history"
type TeamHistory {
  approximateDate: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz!
  eventType: String!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "team_history"
type TeamHistoryAggregate {
  aggregate: TeamHistoryAggregateFields
  nodes: [TeamHistory!]!
}

input TeamHistoryAggregateBoolExp {
  count: teamHistoryAggregateBoolExpCount
}

input teamHistoryAggregateBoolExpCount {
  arguments: [TeamHistorySelectColumn!]
  distinct: Boolean
  filter: TeamHistoryBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_history"
type TeamHistoryAggregateFields {
  avg: TeamHistoryAvgFields
  count(columns: [TeamHistorySelectColumn!], distinct: Boolean): Int!
  max: TeamHistoryMaxFields
  min: TeamHistoryMinFields
  stddev: TeamHistoryStddevFields
  stddevPop: TeamHistoryStddevPopFields
  stddevSamp: TeamHistoryStddevSampFields
  sum: TeamHistorySumFields
  varPop: TeamHistoryVarPopFields
  varSamp: TeamHistoryVarSampFields
  variance: TeamHistoryVarianceFields
}

# order by aggregate values of table "team_history"
input TeamHistoryAggregateOrderBy {
  avg: TeamHistoryAvgOrderBy
  count: OrderBy
  max: TeamHistoryMaxOrderBy
  min: TeamHistoryMinOrderBy
  stddev: TeamHistoryStddevOrderBy
  stddevPop: TeamHistoryStddevPopOrderBy
  stddevSamp: TeamHistoryStddevSampOrderBy
  sum: TeamHistorySumOrderBy
  varPop: TeamHistoryVarPopOrderBy
  varSamp: TeamHistoryVarSampOrderBy
  variance: TeamHistoryVarianceOrderBy
}

# input type for inserting array relation for remote table "team_history"
input TeamHistoryArrRelInsertInput {
  data: [TeamHistoryInsertInput!]!

  # upsert condition
  onConflict: TeamHistoryOnConflict
}

# aggregate avg on columns
type TeamHistoryAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "team_history"
input TeamHistoryAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "team_history". All fields are combined with a logical 'AND'.
input TeamHistoryBoolExp {
  _and: [TeamHistoryBoolExp!]
  _not: TeamHistoryBoolExp
  _or: [TeamHistoryBoolExp!]
  approximateDate: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventDate: TimestamptzComparisonExp
  eventType: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "team_history"
enum TeamHistoryConstraint {
  # unique or primary key constraint on columns "id"
  team_history_pkey
}

# input type for incrementing numeric columns in table "team_history"
input TeamHistoryIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "team_history"
input TeamHistoryInsertInput {
  approximateDate: String
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type TeamHistoryMaxFields {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "team_history"
input TeamHistoryMaxOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type TeamHistoryMinFields {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "team_history"
input TeamHistoryMinOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "team_history"
type TeamHistoryMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamHistory!]!
}

# on_conflict condition type for table "team_history"
input TeamHistoryOnConflict {
  constraint: TeamHistoryConstraint!
  updateColumns: [TeamHistoryUpdateColumn!]! = []
  where: TeamHistoryBoolExp
}

# Ordering options when selecting data from "team_history".
input TeamHistoryOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: team_history
input TeamHistoryPkColumnsInput {
  id: bigint!
}

# select columns of table "team_history"
enum TeamHistorySelectColumn {
  # column name
  approximateDate

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventDate

  # column name
  eventType

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "team_history"
input TeamHistorySetInput {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type TeamHistoryStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "team_history"
input TeamHistoryStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type TeamHistoryStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "team_history"
input TeamHistoryStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type TeamHistoryStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "team_history"
input TeamHistoryStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "team_history"
input TeamHistoryStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamHistoryStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamHistoryStreamCursorValueInput {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type TeamHistorySumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "team_history"
input TeamHistorySumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "team_history"
enum TeamHistoryUpdateColumn {
  # column name
  approximateDate

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventDate

  # column name
  eventType

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

input TeamHistoryUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamHistoryIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamHistorySetInput

  # filter the rows which have to be updated
  where: TeamHistoryBoolExp!
}

# aggregate variance on columns
type TeamHistoryVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "team_history"
input TeamHistoryVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type TeamHistoryVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "team_history"
input TeamHistoryVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type TeamHistoryVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "team_history"
input TeamHistoryVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# input type for incrementing numeric columns in table "team"
input TeamIncInput {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdById: bigint
  currentFinance: Float
  id: bigint
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  videoId: bigint
}

# input type for inserting data into table "team"
input TeamInsertInput {
  accountAllocates: AccountAllocateArrRelInsertInput
  accounts: AccountArrRelInsertInput
  actions: ActionArrRelInsertInput
  actor: ActorObjRelInsertInput
  canteen: CanteenObjRelInsertInput
  canteenId: bigint
  classGroup: ClassGroupObjRelInsertInput
  classGroupId: bigint
  cohort: CohortObjRelInsertInput
  cohortId: bigint
  contents: ContentArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  currentFinance: Float
  deletedAt: timestamptz
  directorsCategoryName: String
  documents: DocumentArrRelInsertInput
  eventManages: EventManageArrRelInsertInput
  finances: FinanceArrRelInsertInput
  form: FormObjRelInsertInput
  grantFund: LegalUnitObjRelInsertInput
  grants: GrantArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  missions: MissionArrRelInsertInput
  parentId: bigint
  poles: PoleArrRelInsertInput
  projects: ProjectArrRelInsertInput
  roles: RoleArrRelInsertInput
  team: TeamObjRelInsertInput
  teamHistories: TeamHistoryArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMembers: TeamMemberArrRelInsertInput
  teams: TeamArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantGrantFundId: bigint
  tenantId: bigint
  tenantManages: TenantManageArrRelInsertInput
  type: String
  video: FileUploadObjRelInsertInput
  videoId: bigint
}

# columns and relationships of "team_join"
type TeamJoin {
  # An object relationship
  askedRole: Role!
  askedRoleId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  formSubmission: FormSubmission
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  joiner: User!
  joinerId: bigint!

  # An object relationship
  receivedPole: Pole
  receivedPoleId: bigint

  # An object relationship
  receivedRole: Role
  receivedRoleId: bigint
  settledAt: timestamptz

  # An object relationship
  settledBy: Individual
  settledById: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "team_join"
type TeamJoinAggregate {
  aggregate: TeamJoinAggregateFields
  nodes: [TeamJoin!]!
}

input TeamJoinAggregateBoolExp {
  count: teamJoinAggregateBoolExpCount
}

input teamJoinAggregateBoolExpCount {
  arguments: [TeamJoinSelectColumn!]
  distinct: Boolean
  filter: TeamJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_join"
type TeamJoinAggregateFields {
  avg: TeamJoinAvgFields
  count(columns: [TeamJoinSelectColumn!], distinct: Boolean): Int!
  max: TeamJoinMaxFields
  min: TeamJoinMinFields
  stddev: TeamJoinStddevFields
  stddevPop: TeamJoinStddevPopFields
  stddevSamp: TeamJoinStddevSampFields
  sum: TeamJoinSumFields
  varPop: TeamJoinVarPopFields
  varSamp: TeamJoinVarSampFields
  variance: TeamJoinVarianceFields
}

# order by aggregate values of table "team_join"
input TeamJoinAggregateOrderBy {
  avg: TeamJoinAvgOrderBy
  count: OrderBy
  max: TeamJoinMaxOrderBy
  min: TeamJoinMinOrderBy
  stddev: TeamJoinStddevOrderBy
  stddevPop: TeamJoinStddevPopOrderBy
  stddevSamp: TeamJoinStddevSampOrderBy
  sum: TeamJoinSumOrderBy
  varPop: TeamJoinVarPopOrderBy
  varSamp: TeamJoinVarSampOrderBy
  variance: TeamJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "team_join"
input TeamJoinArrRelInsertInput {
  data: [TeamJoinInsertInput!]!

  # upsert condition
  onConflict: TeamJoinOnConflict
}

# aggregate avg on columns
type TeamJoinAvgFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "team_join"
input TeamJoinAvgOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "team_join". All fields are combined with a logical 'AND'.
input TeamJoinBoolExp {
  _and: [TeamJoinBoolExp!]
  _not: TeamJoinBoolExp
  _or: [TeamJoinBoolExp!]
  askedRole: RoleBoolExp
  askedRoleId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  formSubmission: FormSubmissionBoolExp
  formSubmissionId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  joiner: UserBoolExp
  joinerId: BigintComparisonExp
  receivedPole: PoleBoolExp
  receivedPoleId: BigintComparisonExp
  receivedRole: RoleBoolExp
  receivedRoleId: BigintComparisonExp
  settledAt: TimestamptzComparisonExp
  settledBy: IndividualBoolExp
  settledById: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "team_join"
enum TeamJoinConstraint {
  # unique or primary key constraint on columns "id"
  team_join_pkey
}

# input type for incrementing numeric columns in table "team_join"
input TeamJoinIncInput {
  askedRoleId: bigint
  createdById: bigint
  formSubmissionId: bigint
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledById: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "team_join"
input TeamJoinInsertInput {
  askedRole: RoleObjRelInsertInput
  askedRoleId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  formSubmission: FormSubmissionObjRelInsertInput
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joiner: UserObjRelInsertInput
  joinerId: bigint
  receivedPole: PoleObjRelInsertInput
  receivedPoleId: bigint
  receivedRole: RoleObjRelInsertInput
  receivedRoleId: bigint
  settledAt: timestamptz
  settledBy: IndividualObjRelInsertInput
  settledById: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type TeamJoinMaxFields {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "team_join"
input TeamJoinMaxOrderBy {
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type TeamJoinMinFields {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "team_join"
input TeamJoinMinOrderBy {
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledAt: OrderBy
  settledById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "team_join"
type TeamJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamJoin!]!
}

# on_conflict condition type for table "team_join"
input TeamJoinOnConflict {
  constraint: TeamJoinConstraint!
  updateColumns: [TeamJoinUpdateColumn!]! = []
  where: TeamJoinBoolExp
}

# Ordering options when selecting data from "team_join".
input TeamJoinOrderBy {
  askedRole: RoleOrderBy
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmission: FormSubmissionOrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joiner: UserOrderBy
  joinerId: OrderBy
  receivedPole: PoleOrderBy
  receivedPoleId: OrderBy
  receivedRole: RoleOrderBy
  receivedRoleId: OrderBy
  settledAt: OrderBy
  settledBy: IndividualOrderBy
  settledById: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: team_join
input TeamJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "team_join"
enum TeamJoinSelectColumn {
  # column name
  askedRoleId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinerId

  # column name
  receivedPoleId

  # column name
  receivedRoleId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "team_join"
input TeamJoinSetInput {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type TeamJoinStddevFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "team_join"
input TeamJoinStddevOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type TeamJoinStddevPopFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "team_join"
input TeamJoinStddevPopOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type TeamJoinStddevSampFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "team_join"
input TeamJoinStddevSampOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "team_join"
input TeamJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamJoinStreamCursorValueInput {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledAt: timestamptz
  settledById: bigint
  state: String
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type TeamJoinSumFields {
  askedRoleId: bigint
  createdById: bigint
  formSubmissionId: bigint
  id: bigint
  joinerId: bigint
  receivedPoleId: bigint
  receivedRoleId: bigint
  settledById: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "team_join"
input TeamJoinSumOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "team_join"
enum TeamJoinUpdateColumn {
  # column name
  askedRoleId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinerId

  # column name
  receivedPoleId

  # column name
  receivedRoleId

  # column name
  settledAt

  # column name
  settledById

  # column name
  state

  # column name
  teamId

  # column name
  tenantId
}

input TeamJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamJoinSetInput

  # filter the rows which have to be updated
  where: TeamJoinBoolExp!
}

# aggregate variance on columns
type TeamJoinVarianceFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "team_join"
input TeamJoinVarianceOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type TeamJoinVarPopFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "team_join"
input TeamJoinVarPopOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type TeamJoinVarSampFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinerId: Float
  receivedPoleId: Float
  receivedRoleId: Float
  settledById: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "team_join"
input TeamJoinVarSampOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinerId: OrderBy
  receivedPoleId: OrderBy
  receivedRoleId: OrderBy
  settledById: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate max on columns
type TeamMaxFields {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdAt: timestamptz
  createdById: bigint
  currentFinance: Float
  deletedAt: timestamptz
  directorsCategoryName: String
  hiddenAt: timestamptz
  id: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  type: String
  videoId: bigint
}

# order by max() on columns of table "team"
input TeamMaxOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  videoId: OrderBy
}

# columns and relationships of "team_member"
type TeamMember {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  permissions: Int!

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!
  startDate: timestamptz!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): [TeamMemberRoles!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRolesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRolesOrderBy!]

    # filter the rows returned
    where: TeamMemberRolesBoolExp
  ): TeamMemberRolesAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "team_member"
type TeamMemberAggregate {
  aggregate: TeamMemberAggregateFields
  nodes: [TeamMember!]!
}

input TeamMemberAggregateBoolExp {
  count: teamMemberAggregateBoolExpCount
}

input teamMemberAggregateBoolExpCount {
  arguments: [TeamMemberSelectColumn!]
  distinct: Boolean
  filter: TeamMemberBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_member"
type TeamMemberAggregateFields {
  avg: TeamMemberAvgFields
  count(columns: [TeamMemberSelectColumn!], distinct: Boolean): Int!
  max: TeamMemberMaxFields
  min: TeamMemberMinFields
  stddev: TeamMemberStddevFields
  stddevPop: TeamMemberStddevPopFields
  stddevSamp: TeamMemberStddevSampFields
  sum: TeamMemberSumFields
  varPop: TeamMemberVarPopFields
  varSamp: TeamMemberVarSampFields
  variance: TeamMemberVarianceFields
}

# order by aggregate values of table "team_member"
input TeamMemberAggregateOrderBy {
  avg: TeamMemberAvgOrderBy
  count: OrderBy
  max: TeamMemberMaxOrderBy
  min: TeamMemberMinOrderBy
  stddev: TeamMemberStddevOrderBy
  stddevPop: TeamMemberStddevPopOrderBy
  stddevSamp: TeamMemberStddevSampOrderBy
  sum: TeamMemberSumOrderBy
  varPop: TeamMemberVarPopOrderBy
  varSamp: TeamMemberVarSampOrderBy
  variance: TeamMemberVarianceOrderBy
}

# input type for inserting array relation for remote table "team_member"
input TeamMemberArrRelInsertInput {
  data: [TeamMemberInsertInput!]!

  # upsert condition
  onConflict: TeamMemberOnConflict
}

# aggregate avg on columns
type TeamMemberAvgFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by avg() on columns of table "team_member"
input TeamMemberAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "team_member". All fields are combined with a logical 'AND'.
input TeamMemberBoolExp {
  _and: [TeamMemberBoolExp!]
  _not: TeamMemberBoolExp
  _or: [TeamMemberBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  endDate: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  permissions: IntComparisonExp
  projectSupervisors: ProjectSupervisorsBoolExp
  projectSupervisorsAggregate: ProjectSupervisorsAggregateBoolExp
  startDate: TimestamptzComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamMemberRoles: TeamMemberRolesBoolExp
  teamMemberRolesAggregate: TeamMemberRolesAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "team_member"
enum TeamMemberConstraint {
  # unique or primary key constraint on columns "id"
  team_member_pkey
}

# input type for incrementing numeric columns in table "team_member"
input TeamMemberIncInput {
  createdById: bigint
  id: bigint
  permissions: Int
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# input type for inserting data into table "team_member"
input TeamMemberInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  projectSupervisors: ProjectSupervisorsArrRelInsertInput
  startDate: timestamptz
  team: TeamObjRelInsertInput
  teamId: bigint
  teamMemberRoles: TeamMemberRolesArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type TeamMemberMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  startDate: timestamptz
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by max() on columns of table "team_member"
input TeamMemberMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  startDate: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type TeamMemberMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  startDate: timestamptz
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by min() on columns of table "team_member"
input TeamMemberMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  startDate: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "team_member"
type TeamMemberMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamMember!]!
}

# input type for inserting object relation for remote table "team_member"
input TeamMemberObjRelInsertInput {
  data: TeamMemberInsertInput!

  # upsert condition
  onConflict: TeamMemberOnConflict
}

# on_conflict condition type for table "team_member"
input TeamMemberOnConflict {
  constraint: TeamMemberConstraint!
  updateColumns: [TeamMemberUpdateColumn!]! = []
  where: TeamMemberBoolExp
}

# Ordering options when selecting data from "team_member".
input TeamMemberOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  endDate: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  projectSupervisorsAggregate: ProjectSupervisorsAggregateOrderBy
  startDate: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamMemberRolesAggregate: TeamMemberRolesAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: team_member
input TeamMemberPkColumnsInput {
  id: bigint!
}

# columns and relationships of "team_member_roles"
type TeamMemberRoles {
  # An object relationship
  role: Role!
  roleId: bigint!

  # An object relationship
  teamMember: TeamMember!
  teamMemberId: bigint!
}

# aggregated selection of "team_member_roles"
type TeamMemberRolesAggregate {
  aggregate: TeamMemberRolesAggregateFields
  nodes: [TeamMemberRoles!]!
}

input TeamMemberRolesAggregateBoolExp {
  count: teamMemberRolesAggregateBoolExpCount
}

input teamMemberRolesAggregateBoolExpCount {
  arguments: [TeamMemberRolesSelectColumn!]
  distinct: Boolean
  filter: TeamMemberRolesBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_member_roles"
type TeamMemberRolesAggregateFields {
  avg: TeamMemberRolesAvgFields
  count(columns: [TeamMemberRolesSelectColumn!], distinct: Boolean): Int!
  max: TeamMemberRolesMaxFields
  min: TeamMemberRolesMinFields
  stddev: TeamMemberRolesStddevFields
  stddevPop: TeamMemberRolesStddevPopFields
  stddevSamp: TeamMemberRolesStddevSampFields
  sum: TeamMemberRolesSumFields
  varPop: TeamMemberRolesVarPopFields
  varSamp: TeamMemberRolesVarSampFields
  variance: TeamMemberRolesVarianceFields
}

# order by aggregate values of table "team_member_roles"
input TeamMemberRolesAggregateOrderBy {
  avg: TeamMemberRolesAvgOrderBy
  count: OrderBy
  max: TeamMemberRolesMaxOrderBy
  min: TeamMemberRolesMinOrderBy
  stddev: TeamMemberRolesStddevOrderBy
  stddevPop: TeamMemberRolesStddevPopOrderBy
  stddevSamp: TeamMemberRolesStddevSampOrderBy
  sum: TeamMemberRolesSumOrderBy
  varPop: TeamMemberRolesVarPopOrderBy
  varSamp: TeamMemberRolesVarSampOrderBy
  variance: TeamMemberRolesVarianceOrderBy
}

# input type for inserting array relation for remote table "team_member_roles"
input TeamMemberRolesArrRelInsertInput {
  data: [TeamMemberRolesInsertInput!]!

  # upsert condition
  onConflict: TeamMemberRolesOnConflict
}

# aggregate avg on columns
type TeamMemberRolesAvgFields {
  roleId: Float
  teamMemberId: Float
}

# order by avg() on columns of table "team_member_roles"
input TeamMemberRolesAvgOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# Boolean expression to filter rows from the table "team_member_roles". All fields are combined with a logical 'AND'.
input TeamMemberRolesBoolExp {
  _and: [TeamMemberRolesBoolExp!]
  _not: TeamMemberRolesBoolExp
  _or: [TeamMemberRolesBoolExp!]
  role: RoleBoolExp
  roleId: BigintComparisonExp
  teamMember: TeamMemberBoolExp
  teamMemberId: BigintComparisonExp
}

# unique or primary key constraints on table "team_member_roles"
enum TeamMemberRolesConstraint {
  # unique or primary key constraint on columns "role_id", "team_member_id"
  team_member_roles_pkey
}

# input type for incrementing numeric columns in table "team_member_roles"
input TeamMemberRolesIncInput {
  roleId: bigint
  teamMemberId: bigint
}

# input type for inserting data into table "team_member_roles"
input TeamMemberRolesInsertInput {
  role: RoleObjRelInsertInput
  roleId: bigint
  teamMember: TeamMemberObjRelInsertInput
  teamMemberId: bigint
}

# aggregate max on columns
type TeamMemberRolesMaxFields {
  roleId: bigint
  teamMemberId: bigint
}

# order by max() on columns of table "team_member_roles"
input TeamMemberRolesMaxOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# aggregate min on columns
type TeamMemberRolesMinFields {
  roleId: bigint
  teamMemberId: bigint
}

# order by min() on columns of table "team_member_roles"
input TeamMemberRolesMinOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# response of any mutation on the table "team_member_roles"
type TeamMemberRolesMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamMemberRoles!]!
}

# on_conflict condition type for table "team_member_roles"
input TeamMemberRolesOnConflict {
  constraint: TeamMemberRolesConstraint!
  updateColumns: [TeamMemberRolesUpdateColumn!]! = []
  where: TeamMemberRolesBoolExp
}

# Ordering options when selecting data from "team_member_roles".
input TeamMemberRolesOrderBy {
  role: RoleOrderBy
  roleId: OrderBy
  teamMember: TeamMemberOrderBy
  teamMemberId: OrderBy
}

# primary key columns input for table: team_member_roles
input TeamMemberRolesPkColumnsInput {
  roleId: bigint!
  teamMemberId: bigint!
}

# select columns of table "team_member_roles"
enum TeamMemberRolesSelectColumn {
  # column name
  roleId

  # column name
  teamMemberId
}

# input type for updating data in table "team_member_roles"
input TeamMemberRolesSetInput {
  roleId: bigint
  teamMemberId: bigint
}

# aggregate stddev on columns
type TeamMemberRolesStddevFields {
  roleId: Float
  teamMemberId: Float
}

# order by stddev() on columns of table "team_member_roles"
input TeamMemberRolesStddevOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevPop on columns
type TeamMemberRolesStddevPopFields {
  roleId: Float
  teamMemberId: Float
}

# order by stddevPop() on columns of table "team_member_roles"
input TeamMemberRolesStddevPopOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevSamp on columns
type TeamMemberRolesStddevSampFields {
  roleId: Float
  teamMemberId: Float
}

# order by stddevSamp() on columns of table "team_member_roles"
input TeamMemberRolesStddevSampOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# Streaming cursor of the table "team_member_roles"
input TeamMemberRolesStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamMemberRolesStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamMemberRolesStreamCursorValueInput {
  roleId: bigint
  teamMemberId: bigint
}

# aggregate sum on columns
type TeamMemberRolesSumFields {
  roleId: bigint
  teamMemberId: bigint
}

# order by sum() on columns of table "team_member_roles"
input TeamMemberRolesSumOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# update columns of table "team_member_roles"
enum TeamMemberRolesUpdateColumn {
  # column name
  roleId

  # column name
  teamMemberId
}

input TeamMemberRolesUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamMemberRolesIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamMemberRolesSetInput

  # filter the rows which have to be updated
  where: TeamMemberRolesBoolExp!
}

# aggregate variance on columns
type TeamMemberRolesVarianceFields {
  roleId: Float
  teamMemberId: Float
}

# order by variance() on columns of table "team_member_roles"
input TeamMemberRolesVarianceOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varPop on columns
type TeamMemberRolesVarPopFields {
  roleId: Float
  teamMemberId: Float
}

# order by varPop() on columns of table "team_member_roles"
input TeamMemberRolesVarPopOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varSamp on columns
type TeamMemberRolesVarSampFields {
  roleId: Float
  teamMemberId: Float
}

# order by varSamp() on columns of table "team_member_roles"
input TeamMemberRolesVarSampOrderBy {
  roleId: OrderBy
  teamMemberId: OrderBy
}

# select columns of table "team_member"
enum TeamMemberSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  endDate

  # column name
  hiddenAt

  # column name
  id

  # column name
  permissions

  # column name
  startDate

  # column name
  teamId

  # column name
  tenantId

  # column name
  userId
}

# input type for updating data in table "team_member"
input TeamMemberSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  startDate: timestamptz
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# aggregate stddev on columns
type TeamMemberStddevFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddev() on columns of table "team_member"
input TeamMemberStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type TeamMemberStddevPopFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddevPop() on columns of table "team_member"
input TeamMemberStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type TeamMemberStddevSampFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "team_member"
input TeamMemberStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "team_member"
input TeamMemberStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamMemberStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamMemberStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  endDate: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  startDate: timestamptz
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# aggregate sum on columns
type TeamMemberSumFields {
  createdById: bigint
  id: bigint
  permissions: Int
  teamId: bigint
  tenantId: bigint
  userId: bigint
}

# order by sum() on columns of table "team_member"
input TeamMemberSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# update columns of table "team_member"
enum TeamMemberUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  endDate

  # column name
  hiddenAt

  # column name
  id

  # column name
  permissions

  # column name
  startDate

  # column name
  teamId

  # column name
  tenantId

  # column name
  userId
}

input TeamMemberUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamMemberIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamMemberSetInput

  # filter the rows which have to be updated
  where: TeamMemberBoolExp!
}

# aggregate variance on columns
type TeamMemberVarianceFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by variance() on columns of table "team_member"
input TeamMemberVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type TeamMemberVarPopFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by varPop() on columns of table "team_member"
input TeamMemberVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type TeamMemberVarSampFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantId: Float
  userId: Float
}

# order by varSamp() on columns of table "team_member"
input TeamMemberVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
  userId: OrderBy
}

# columns and relationships of "team_metric"
type TeamMetric {
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
  value: String!
}

# aggregated selection of "team_metric"
type TeamMetricAggregate {
  aggregate: TeamMetricAggregateFields
  nodes: [TeamMetric!]!
}

input TeamMetricAggregateBoolExp {
  count: teamMetricAggregateBoolExpCount
}

input teamMetricAggregateBoolExpCount {
  arguments: [TeamMetricSelectColumn!]
  distinct: Boolean
  filter: TeamMetricBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_metric"
type TeamMetricAggregateFields {
  avg: TeamMetricAvgFields
  count(columns: [TeamMetricSelectColumn!], distinct: Boolean): Int!
  max: TeamMetricMaxFields
  min: TeamMetricMinFields
  stddev: TeamMetricStddevFields
  stddevPop: TeamMetricStddevPopFields
  stddevSamp: TeamMetricStddevSampFields
  sum: TeamMetricSumFields
  varPop: TeamMetricVarPopFields
  varSamp: TeamMetricVarSampFields
  variance: TeamMetricVarianceFields
}

# order by aggregate values of table "team_metric"
input TeamMetricAggregateOrderBy {
  avg: TeamMetricAvgOrderBy
  count: OrderBy
  max: TeamMetricMaxOrderBy
  min: TeamMetricMinOrderBy
  stddev: TeamMetricStddevOrderBy
  stddevPop: TeamMetricStddevPopOrderBy
  stddevSamp: TeamMetricStddevSampOrderBy
  sum: TeamMetricSumOrderBy
  varPop: TeamMetricVarPopOrderBy
  varSamp: TeamMetricVarSampOrderBy
  variance: TeamMetricVarianceOrderBy
}

# input type for inserting array relation for remote table "team_metric"
input TeamMetricArrRelInsertInput {
  data: [TeamMetricInsertInput!]!

  # upsert condition
  onConflict: TeamMetricOnConflict
}

# aggregate avg on columns
type TeamMetricAvgFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "team_metric"
input TeamMetricAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "team_metric". All fields are combined with a logical 'AND'.
input TeamMetricBoolExp {
  _and: [TeamMetricBoolExp!]
  _not: TeamMetricBoolExp
  _or: [TeamMetricBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
  value: StringComparisonExp
}

# unique or primary key constraints on table "team_metric"
enum TeamMetricConstraint {
  # unique or primary key constraint on columns "id"
  team_metric_pkey
}

# input type for incrementing numeric columns in table "team_metric"
input TeamMetricIncInput {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "team_metric"
input TeamMetricInsertInput {
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
  value: String
}

# aggregate max on columns
type TeamMetricMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
  value: String
}

# order by max() on columns of table "team_metric"
input TeamMetricMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
  value: OrderBy
}

# aggregate min on columns
type TeamMetricMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
  value: String
}

# order by min() on columns of table "team_metric"
input TeamMetricMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  type: OrderBy
  value: OrderBy
}

# response of any mutation on the table "team_metric"
type TeamMetricMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamMetric!]!
}

# on_conflict condition type for table "team_metric"
input TeamMetricOnConflict {
  constraint: TeamMetricConstraint!
  updateColumns: [TeamMetricUpdateColumn!]! = []
  where: TeamMetricBoolExp
}

# Ordering options when selecting data from "team_metric".
input TeamMetricOrderBy {
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
  value: OrderBy
}

# primary key columns input for table: team_metric
input TeamMetricPkColumnsInput {
  id: bigint!
}

# select columns of table "team_metric"
enum TeamMetricSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type

  # column name
  value
}

# input type for updating data in table "team_metric"
input TeamMetricSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
  value: String
}

# aggregate stddev on columns
type TeamMetricStddevFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "team_metric"
input TeamMetricStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type TeamMetricStddevPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "team_metric"
input TeamMetricStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type TeamMetricStddevSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "team_metric"
input TeamMetricStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "team_metric"
input TeamMetricStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamMetricStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamMetricStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantId: bigint
  type: String
  value: String
}

# aggregate sum on columns
type TeamMetricSumFields {
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "team_metric"
input TeamMetricSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "team_metric"
enum TeamMetricUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantId

  # column name
  type

  # column name
  value
}

input TeamMetricUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamMetricIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamMetricSetInput

  # filter the rows which have to be updated
  where: TeamMetricBoolExp!
}

# aggregate variance on columns
type TeamMetricVarianceFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "team_metric"
input TeamMetricVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type TeamMetricVarPopFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "team_metric"
input TeamMetricVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type TeamMetricVarSampFields {
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "team_metric"
input TeamMetricVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type TeamMinFields {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdAt: timestamptz
  createdById: bigint
  currentFinance: Float
  deletedAt: timestamptz
  directorsCategoryName: String
  hiddenAt: timestamptz
  id: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  type: String
  videoId: bigint
}

# order by min() on columns of table "team"
input TeamMinOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  type: OrderBy
  videoId: OrderBy
}

# response of any mutation on the table "team"
type TeamMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Team!]!
}

# input type for inserting object relation for remote table "team"
input TeamObjRelInsertInput {
  data: TeamInsertInput!

  # upsert condition
  onConflict: TeamOnConflict
}

# on_conflict condition type for table "team"
input TeamOnConflict {
  constraint: TeamConstraint!
  updateColumns: [TeamUpdateColumn!]! = []
  where: TeamBoolExp
}

# Ordering options when selecting data from "team".
input TeamOrderBy {
  accountAllocatesAggregate: AccountAllocateAggregateOrderBy
  accountsAggregate: AccountAggregateOrderBy
  actionsAggregate: ActionAggregateOrderBy
  actor: ActorOrderBy
  canteen: CanteenOrderBy
  canteenId: OrderBy
  classGroup: ClassGroupOrderBy
  classGroupId: OrderBy
  cohort: CohortOrderBy
  cohortId: OrderBy
  contentsAggregate: ContentAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  documentsAggregate: DocumentAggregateOrderBy
  eventManagesAggregate: EventManageAggregateOrderBy
  financesAggregate: FinanceAggregateOrderBy
  form: FormOrderBy
  grantFund: LegalUnitOrderBy
  grantsAggregate: GrantAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isJoinFormActive: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  missionsAggregate: MissionAggregateOrderBy
  parentId: OrderBy
  polesAggregate: PoleAggregateOrderBy
  projectsAggregate: ProjectAggregateOrderBy
  rolesAggregate: RoleAggregateOrderBy
  team: TeamOrderBy
  teamHistoriesAggregate: TeamHistoryAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMembersAggregate: TeamMemberAggregateOrderBy
  teamsAggregate: TeamAggregateOrderBy
  tenant: TenantOrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  tenantManagesAggregate: TenantManageAggregateOrderBy
  type: OrderBy
  video: FileUploadOrderBy
  videoId: OrderBy
}

# primary key columns input for table: team
input TeamPkColumnsInput {
  id: bigint!
}

# select columns of table "team"
enum TeamSelectColumn {
  # column name
  canteenId

  # column name
  classGroupId

  # column name
  cohortId

  # column name
  createdAt

  # column name
  createdById

  # column name
  currentFinance

  # column name
  deletedAt

  # column name
  directorsCategoryName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isJoinFormActive

  # column name
  managersCategoryName

  # column name
  membersCategoryName

  # column name
  membershipDuration

  # column name
  membershipFees

  # column name
  parentId

  # column name
  tenantGrantFundId

  # column name
  tenantId

  # column name
  type

  # column name
  videoId
}

# select "teamAggregateBoolExpBool_andArgumentsColumns" columns of table "team"
enum TeamSelectColumnTeamAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isJoinFormActive
}

# select "teamAggregateBoolExpBool_orArgumentsColumns" columns of table "team"
enum TeamSelectColumnTeamAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isJoinFormActive
}

# input type for updating data in table "team"
input TeamSetInput {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdAt: timestamptz
  createdById: bigint
  currentFinance: Float
  deletedAt: timestamptz
  directorsCategoryName: String
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  type: String
  videoId: bigint
}

# aggregate stddev on columns
type TeamStddevFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by stddev() on columns of table "team"
input TeamStddevOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# aggregate stddevPop on columns
type TeamStddevPopFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by stddevPop() on columns of table "team"
input TeamStddevPopOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# aggregate stddevSamp on columns
type TeamStddevSampFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by stddevSamp() on columns of table "team"
input TeamStddevSampOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# Streaming cursor of the table "team"
input TeamStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamStreamCursorValueInput {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdAt: timestamptz
  createdById: bigint
  currentFinance: Float
  deletedAt: timestamptz
  directorsCategoryName: String
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  type: String
  videoId: bigint
}

# aggregate sum on columns
type TeamSumFields {
  canteenId: bigint
  classGroupId: bigint
  cohortId: bigint
  createdById: bigint
  currentFinance: Float
  id: bigint
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantId: bigint
  videoId: bigint
}

# order by sum() on columns of table "team"
input TeamSumOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# update columns of table "team"
enum TeamUpdateColumn {
  # column name
  canteenId

  # column name
  classGroupId

  # column name
  cohortId

  # column name
  createdAt

  # column name
  createdById

  # column name
  currentFinance

  # column name
  deletedAt

  # column name
  directorsCategoryName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isJoinFormActive

  # column name
  managersCategoryName

  # column name
  membersCategoryName

  # column name
  membershipDuration

  # column name
  membershipFees

  # column name
  parentId

  # column name
  tenantGrantFundId

  # column name
  tenantId

  # column name
  type

  # column name
  videoId
}

input TeamUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamSetInput

  # filter the rows which have to be updated
  where: TeamBoolExp!
}

# aggregate variance on columns
type TeamVarianceFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by variance() on columns of table "team"
input TeamVarianceOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# aggregate varPop on columns
type TeamVarPopFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by varPop() on columns of table "team"
input TeamVarPopOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# aggregate varSamp on columns
type TeamVarSampFields {
  canteenId: Float
  classGroupId: Float
  cohortId: Float
  createdById: Float
  currentFinance: Float
  id: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantId: Float
  videoId: Float
}

# order by varSamp() on columns of table "team"
input TeamVarSampOrderBy {
  canteenId: OrderBy
  classGroupId: OrderBy
  cohortId: OrderBy
  createdById: OrderBy
  currentFinance: OrderBy
  id: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantId: OrderBy
  videoId: OrderBy
}

# columns and relationships of "tenant"
type Tenant {
  # An array relationship
  accountAllocates(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): [AccountAllocate!]!

  # An aggregate relationship
  accountAllocatesAggregate(
    # distinct select on columns
    distinctOn: [AccountAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountAllocateOrderBy!]

    # filter the rows returned
    where: AccountAllocateBoolExp
  ): AccountAllocateAggregate!

  # An array relationship
  accounts(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): [Account!]!

  # An aggregate relationship
  accountsAggregate(
    # distinct select on columns
    distinctOn: [AccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AccountOrderBy!]

    # filter the rows returned
    where: AccountBoolExp
  ): AccountAggregate!

  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  actorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  actorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  actors(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # An aggregate relationship
  actorsAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # An array relationship
  addresses(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # An aggregate relationship
  addressesAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # An array relationship
  bots(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): [Bot!]!

  # An aggregate relationship
  botsAggregate(
    # distinct select on columns
    distinctOn: [BotSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BotOrderBy!]

    # filter the rows returned
    where: BotBoolExp
  ): BotAggregate!

  # An array relationship
  campusClusters(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # An aggregate relationship
  campusClustersAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # An array relationship
  campuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  campusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # An array relationship
  canteenFoods(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): [CanteenFood!]!

  # An aggregate relationship
  canteenFoodsAggregate(
    # distinct select on columns
    distinctOn: [CanteenFoodSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenFoodOrderBy!]

    # filter the rows returned
    where: CanteenFoodBoolExp
  ): CanteenFoodAggregate!

  # An array relationship
  canteenMenus(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): [CanteenMenu!]!

  # An aggregate relationship
  canteenMenusAggregate(
    # distinct select on columns
    distinctOn: [CanteenMenuSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenMenuOrderBy!]

    # filter the rows returned
    where: CanteenMenuBoolExp
  ): CanteenMenuAggregate!

  # An array relationship
  canteens(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): [Canteen!]!

  # An aggregate relationship
  canteensAggregate(
    # distinct select on columns
    distinctOn: [CanteenSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CanteenOrderBy!]

    # filter the rows returned
    where: CanteenBoolExp
  ): CanteenAggregate!

  # An array relationship
  classGroupTeachers(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # An aggregate relationship
  classGroupTeachersAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!

  # An array relationship
  classGroups(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): [ClassGroup!]!

  # An aggregate relationship
  classGroupsAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupOrderBy!]

    # filter the rows returned
    where: ClassGroupBoolExp
  ): ClassGroupAggregate!

  # An array relationship
  cohorts(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): [Cohort!]!

  # An aggregate relationship
  cohortsAggregate(
    # distinct select on columns
    distinctOn: [CohortSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CohortOrderBy!]

    # filter the rows returned
    where: CohortBoolExp
  ): CohortAggregate!

  # An array relationship
  contents(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): [Content!]!

  # An aggregate relationship
  contentsAggregate(
    # distinct select on columns
    distinctOn: [ContentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ContentOrderBy!]

    # filter the rows returned
    where: ContentBoolExp
  ): ContentAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  documents(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): [Document!]!

  # An aggregate relationship
  documentsAggregate(
    # distinct select on columns
    distinctOn: [DocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [DocumentOrderBy!]

    # filter the rows returned
    where: DocumentBoolExp
  ): DocumentAggregate!
  domain: String!

  # An array relationship
  eventApprovalSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  eventApprovalStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  eventManages(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): [EventManage!]!

  # An aggregate relationship
  eventManagesAggregate(
    # distinct select on columns
    distinctOn: [EventManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventManageOrderBy!]

    # filter the rows returned
    where: EventManageBoolExp
  ): EventManageAggregate!

  # An object relationship
  eventValidationForm: Form
  eventValidationFormId: bigint

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  favorites(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): [Favorite!]!

  # An aggregate relationship
  favoritesAggregate(
    # distinct select on columns
    distinctOn: [FavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FavoriteOrderBy!]

    # filter the rows returned
    where: FavoriteBoolExp
  ): FavoriteAggregate!

  # An array relationship
  fileUploads(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # An aggregate relationship
  fileUploadsAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # An array relationship
  finances(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): [Finance!]!

  # An aggregate relationship
  financesAggregate(
    # distinct select on columns
    distinctOn: [FinanceSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FinanceOrderBy!]

    # filter the rows returned
    where: FinanceBoolExp
  ): FinanceAggregate!

  # An array relationship
  follows(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followsAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # An array relationship
  formSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  formSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  forms(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # An aggregate relationship
  formsAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # An array relationship
  grantUnlocks(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): [GrantUnlock!]!

  # An aggregate relationship
  grantUnlocksAggregate(
    # distinct select on columns
    distinctOn: [GrantUnlockSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantUnlockOrderBy!]

    # filter the rows returned
    where: GrantUnlockBoolExp
  ): GrantUnlockAggregate!

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  id: bigint!

  # An array relationship
  individuals(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): [Individual!]!

  # An aggregate relationship
  individualsAggregate(
    # distinct select on columns
    distinctOn: [IndividualSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IndividualOrderBy!]

    # filter the rows returned
    where: IndividualBoolExp
  ): IndividualAggregate!
  isOidcEnabled: Boolean!

  # An array relationship
  issues(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): [Issue!]!

  # An aggregate relationship
  issuesAggregate(
    # distinct select on columns
    distinctOn: [IssueSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [IssueOrderBy!]

    # filter the rows returned
    where: IssueBoolExp
  ): IssueAggregate!

  # An array relationship
  legalUnits(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # An aggregate relationship
  legalUnitsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!
  name: String!
  oidcCallbackUri: String!
  oidcClientId: String!
  oidcClientSecret: String!
  oidcDiscoveryUrl: String!
  oidcName: String!
  oidcScopes: String!
  pointName: String!

  # An array relationship
  poles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  polesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  reactions(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): [Reaction!]!

  # An aggregate relationship
  reactionsAggregate(
    # distinct select on columns
    distinctOn: [ReactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReactionOrderBy!]

    # filter the rows returned
    where: ReactionBoolExp
  ): ReactionAggregate!

  # An array relationship
  reports(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): [Report!]!

  # An aggregate relationship
  reportsAggregate(
    # distinct select on columns
    distinctOn: [ReportSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ReportOrderBy!]

    # filter the rows returned
    where: ReportBoolExp
  ): ReportAggregate!

  # An array relationship
  roles(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): [Role!]!

  # An aggregate relationship
  rolesAggregate(
    # distinct select on columns
    distinctOn: [RoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [RoleOrderBy!]

    # filter the rows returned
    where: RoleBoolExp
  ): RoleAggregate!

  # An array relationship
  sessions(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # An aggregate relationship
  sessionsAggregate(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): SessionAggregate!

  # An array relationship
  shortcuts(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # An aggregate relationship
  shortcutsAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!

  # An array relationship
  socials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  socialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # An array relationship
  subjects(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): [Subject!]!

  # An aggregate relationship
  subjectsAggregate(
    # distinct select on columns
    distinctOn: [SubjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SubjectOrderBy!]

    # filter the rows returned
    where: SubjectBoolExp
  ): SubjectAggregate!

  # An array relationship
  tags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  tagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An array relationship
  teamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  teamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  teamMetrics(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): [TeamMetric!]!

  # An aggregate relationship
  teamMetricsAggregate(
    # distinct select on columns
    distinctOn: [TeamMetricSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMetricOrderBy!]

    # filter the rows returned
    where: TeamMetricBoolExp
  ): TeamMetricAggregate!

  # An array relationship
  teams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  teamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An array relationship
  tenantManages(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): [TenantManage!]!

  # An aggregate relationship
  tenantManagesAggregate(
    # distinct select on columns
    distinctOn: [TenantManageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantManageOrderBy!]

    # filter the rows returned
    where: TenantManageBoolExp
  ): TenantManageAggregate!

  # An array relationship
  threads(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): [Thread!]!

  # An aggregate relationship
  threadsAggregate(
    # distinct select on columns
    distinctOn: [ThreadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadOrderBy!]

    # filter the rows returned
    where: ThreadBoolExp
  ): ThreadAggregate!

  # An array relationship
  users(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # An aggregate relationship
  usersAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # An array relationship
  validations(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): [Validation!]!

  # An aggregate relationship
  validationsAggregate(
    # distinct select on columns
    distinctOn: [ValidationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ValidationOrderBy!]

    # filter the rows returned
    where: ValidationBoolExp
  ): ValidationAggregate!

  # An array relationship
  votes(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): [Vote!]!

  # An aggregate relationship
  votesAggregate(
    # distinct select on columns
    distinctOn: [VoteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [VoteOrderBy!]

    # filter the rows returned
    where: VoteBoolExp
  ): VoteAggregate!
}

# aggregated selection of "tenant"
type TenantAggregate {
  aggregate: TenantAggregateFields
  nodes: [Tenant!]!
}

input TenantAggregateBoolExp {
  bool_and: tenantAggregateBoolExpBool_and
  bool_or: tenantAggregateBoolExpBool_or
  count: tenantAggregateBoolExpCount
}

input tenantAggregateBoolExpBool_and {
  arguments: TenantSelectColumnTenantAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TenantBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAggregateBoolExpBool_or {
  arguments: TenantSelectColumnTenantAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TenantBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAggregateBoolExpCount {
  arguments: [TenantSelectColumn!]
  distinct: Boolean
  filter: TenantBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant"
type TenantAggregateFields {
  avg: TenantAvgFields
  count(columns: [TenantSelectColumn!], distinct: Boolean): Int!
  max: TenantMaxFields
  min: TenantMinFields
  stddev: TenantStddevFields
  stddevPop: TenantStddevPopFields
  stddevSamp: TenantStddevSampFields
  sum: TenantSumFields
  varPop: TenantVarPopFields
  varSamp: TenantVarSampFields
  variance: TenantVarianceFields
}

# order by aggregate values of table "tenant"
input TenantAggregateOrderBy {
  avg: TenantAvgOrderBy
  count: OrderBy
  max: TenantMaxOrderBy
  min: TenantMinOrderBy
  stddev: TenantStddevOrderBy
  stddevPop: TenantStddevPopOrderBy
  stddevSamp: TenantStddevSampOrderBy
  sum: TenantSumOrderBy
  varPop: TenantVarPopOrderBy
  varSamp: TenantVarSampOrderBy
  variance: TenantVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant"
input TenantArrRelInsertInput {
  data: [TenantInsertInput!]!

  # upsert condition
  onConflict: TenantOnConflict
}

# aggregate avg on columns
type TenantAvgFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by avg() on columns of table "tenant"
input TenantAvgOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
input TenantBoolExp {
  _and: [TenantBoolExp!]
  _not: TenantBoolExp
  _or: [TenantBoolExp!]
  accountAllocates: AccountAllocateBoolExp
  accountAllocatesAggregate: AccountAllocateAggregateBoolExp
  accounts: AccountBoolExp
  accountsAggregate: AccountAggregateBoolExp
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  actorImages: ActorImageBoolExp
  actorImagesAggregate: ActorImageAggregateBoolExp
  actors: ActorBoolExp
  actorsAggregate: ActorAggregateBoolExp
  addresses: AddressBoolExp
  addressesAggregate: AddressAggregateBoolExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  bots: BotBoolExp
  botsAggregate: BotAggregateBoolExp
  campusClusters: CampusClusterBoolExp
  campusClustersAggregate: CampusClusterAggregateBoolExp
  campuses: CampusBoolExp
  campusesAggregate: CampusAggregateBoolExp
  canteenFoods: CanteenFoodBoolExp
  canteenFoodsAggregate: CanteenFoodAggregateBoolExp
  canteenMenus: CanteenMenuBoolExp
  canteenMenusAggregate: CanteenMenuAggregateBoolExp
  canteens: CanteenBoolExp
  canteensAggregate: CanteenAggregateBoolExp
  classGroupTeachers: ClassGroupTeacherBoolExp
  classGroupTeachersAggregate: ClassGroupTeacherAggregateBoolExp
  classGroups: ClassGroupBoolExp
  classGroupsAggregate: ClassGroupAggregateBoolExp
  cohorts: CohortBoolExp
  cohortsAggregate: CohortAggregateBoolExp
  contents: ContentBoolExp
  contentsAggregate: ContentAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  documents: DocumentBoolExp
  documentsAggregate: DocumentAggregateBoolExp
  domain: StringComparisonExp
  eventApprovalSteps: EventApprovalStepBoolExp
  eventApprovalStepsAggregate: EventApprovalStepAggregateBoolExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  eventManages: EventManageBoolExp
  eventManagesAggregate: EventManageAggregateBoolExp
  eventValidationForm: FormBoolExp
  eventValidationFormId: BigintComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  favorites: FavoriteBoolExp
  favoritesAggregate: FavoriteAggregateBoolExp
  fileUploads: FileUploadBoolExp
  fileUploadsAggregate: FileUploadAggregateBoolExp
  finances: FinanceBoolExp
  financesAggregate: FinanceAggregateBoolExp
  follows: FollowBoolExp
  followsAggregate: FollowAggregateBoolExp
  formSubmissions: FormSubmissionBoolExp
  formSubmissionsAggregate: FormSubmissionAggregateBoolExp
  forms: FormBoolExp
  formsAggregate: FormAggregateBoolExp
  grantUnlocks: GrantUnlockBoolExp
  grantUnlocksAggregate: GrantUnlockAggregateBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  id: BigintComparisonExp
  individuals: IndividualBoolExp
  individualsAggregate: IndividualAggregateBoolExp
  isOidcEnabled: BooleanComparisonExp
  issues: IssueBoolExp
  issuesAggregate: IssueAggregateBoolExp
  legalUnits: LegalUnitBoolExp
  legalUnitsAggregate: LegalUnitAggregateBoolExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  name: StringComparisonExp
  oidcCallbackUri: StringComparisonExp
  oidcClientId: StringComparisonExp
  oidcClientSecret: StringComparisonExp
  oidcDiscoveryUrl: StringComparisonExp
  oidcName: StringComparisonExp
  oidcScopes: StringComparisonExp
  pointName: StringComparisonExp
  poles: PoleBoolExp
  polesAggregate: PoleAggregateBoolExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  reactions: ReactionBoolExp
  reactionsAggregate: ReactionAggregateBoolExp
  reports: ReportBoolExp
  reportsAggregate: ReportAggregateBoolExp
  roles: RoleBoolExp
  rolesAggregate: RoleAggregateBoolExp
  sessions: SessionBoolExp
  sessionsAggregate: SessionAggregateBoolExp
  shortcuts: ShortcutBoolExp
  shortcutsAggregate: ShortcutAggregateBoolExp
  socials: SocialBoolExp
  socialsAggregate: SocialAggregateBoolExp
  subjects: SubjectBoolExp
  subjectsAggregate: SubjectAggregateBoolExp
  tags: TagBoolExp
  tagsAggregate: TagAggregateBoolExp
  teamHistories: TeamHistoryBoolExp
  teamHistoriesAggregate: TeamHistoryAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMembers: TeamMemberBoolExp
  teamMembersAggregate: TeamMemberAggregateBoolExp
  teamMetrics: TeamMetricBoolExp
  teamMetricsAggregate: TeamMetricAggregateBoolExp
  teams: TeamBoolExp
  teamsAggregate: TeamAggregateBoolExp
  tenantManages: TenantManageBoolExp
  tenantManagesAggregate: TenantManageAggregateBoolExp
  threads: ThreadBoolExp
  threadsAggregate: ThreadAggregateBoolExp
  users: UserBoolExp
  usersAggregate: UserAggregateBoolExp
  validations: ValidationBoolExp
  validationsAggregate: ValidationAggregateBoolExp
  votes: VoteBoolExp
  votesAggregate: VoteAggregateBoolExp
}

# unique or primary key constraints on table "tenant"
enum TenantConstraint {
  # unique or primary key constraint on columns "domain"
  tenant_domain_unique

  # unique or primary key constraint on columns "event_validation_form_id"
  tenant_event_validation_form_id_unique

  # unique or primary key constraint on columns "id"
  tenant_pkey
}

# input type for incrementing numeric columns in table "tenant"
input TenantIncInput {
  createdById: bigint
  eventValidationFormId: bigint
  id: bigint
}

# input type for inserting data into table "tenant"
input TenantInsertInput {
  accountAllocates: AccountAllocateArrRelInsertInput
  accounts: AccountArrRelInsertInput
  actions: ActionArrRelInsertInput
  actorImages: ActorImageArrRelInsertInput
  actors: ActorArrRelInsertInput
  addresses: AddressArrRelInsertInput
  bankInfos: BankInfoArrRelInsertInput
  bots: BotArrRelInsertInput
  campusClusters: CampusClusterArrRelInsertInput
  campuses: CampusArrRelInsertInput
  canteenFoods: CanteenFoodArrRelInsertInput
  canteenMenus: CanteenMenuArrRelInsertInput
  canteens: CanteenArrRelInsertInput
  classGroupTeachers: ClassGroupTeacherArrRelInsertInput
  classGroups: ClassGroupArrRelInsertInput
  cohorts: CohortArrRelInsertInput
  contents: ContentArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  documents: DocumentArrRelInsertInput
  domain: String
  eventApprovalSteps: EventApprovalStepArrRelInsertInput
  eventApprovals: EventApprovalArrRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  eventManages: EventManageArrRelInsertInput
  eventValidationForm: FormObjRelInsertInput
  eventValidationFormId: bigint
  events: EventArrRelInsertInput
  expenseItems: ExpenseItemArrRelInsertInput
  expenses: ExpenseArrRelInsertInput
  favorites: FavoriteArrRelInsertInput
  fileUploads: FileUploadArrRelInsertInput
  finances: FinanceArrRelInsertInput
  follows: FollowArrRelInsertInput
  formSubmissions: FormSubmissionArrRelInsertInput
  forms: FormArrRelInsertInput
  grantUnlocks: GrantUnlockArrRelInsertInput
  grants: GrantArrRelInsertInput
  id: bigint
  individuals: IndividualArrRelInsertInput
  isOidcEnabled: Boolean
  issues: IssueArrRelInsertInput
  legalUnits: LegalUnitArrRelInsertInput
  missionJoins: MissionJoinArrRelInsertInput
  missions: MissionArrRelInsertInput
  name: String
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
  poles: PoleArrRelInsertInput
  projects: ProjectArrRelInsertInput
  reactions: ReactionArrRelInsertInput
  reports: ReportArrRelInsertInput
  roles: RoleArrRelInsertInput
  sessions: SessionArrRelInsertInput
  shortcuts: ShortcutArrRelInsertInput
  socials: SocialArrRelInsertInput
  subjects: SubjectArrRelInsertInput
  tags: TagArrRelInsertInput
  teamHistories: TeamHistoryArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMembers: TeamMemberArrRelInsertInput
  teamMetrics: TeamMetricArrRelInsertInput
  teams: TeamArrRelInsertInput
  tenantManages: TenantManageArrRelInsertInput
  threads: ThreadArrRelInsertInput
  users: UserArrRelInsertInput
  validations: ValidationArrRelInsertInput
  votes: VoteArrRelInsertInput
}

# columns and relationships of "tenant_manage"
type TenantManage {
  # An object relationship
  campusCluster: CampusCluster
  campusClusterId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "tenant_manage"
type TenantManageAggregate {
  aggregate: TenantManageAggregateFields
  nodes: [TenantManage!]!
}

input TenantManageAggregateBoolExp {
  count: tenantManageAggregateBoolExpCount
}

input tenantManageAggregateBoolExpCount {
  arguments: [TenantManageSelectColumn!]
  distinct: Boolean
  filter: TenantManageBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant_manage"
type TenantManageAggregateFields {
  avg: TenantManageAvgFields
  count(columns: [TenantManageSelectColumn!], distinct: Boolean): Int!
  max: TenantManageMaxFields
  min: TenantManageMinFields
  stddev: TenantManageStddevFields
  stddevPop: TenantManageStddevPopFields
  stddevSamp: TenantManageStddevSampFields
  sum: TenantManageSumFields
  varPop: TenantManageVarPopFields
  varSamp: TenantManageVarSampFields
  variance: TenantManageVarianceFields
}

# order by aggregate values of table "tenant_manage"
input TenantManageAggregateOrderBy {
  avg: TenantManageAvgOrderBy
  count: OrderBy
  max: TenantManageMaxOrderBy
  min: TenantManageMinOrderBy
  stddev: TenantManageStddevOrderBy
  stddevPop: TenantManageStddevPopOrderBy
  stddevSamp: TenantManageStddevSampOrderBy
  sum: TenantManageSumOrderBy
  varPop: TenantManageVarPopOrderBy
  varSamp: TenantManageVarSampOrderBy
  variance: TenantManageVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant_manage"
input TenantManageArrRelInsertInput {
  data: [TenantManageInsertInput!]!

  # upsert condition
  onConflict: TenantManageOnConflict
}

# aggregate avg on columns
type TenantManageAvgFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by avg() on columns of table "tenant_manage"
input TenantManageAvgOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "tenant_manage". All fields are combined with a logical 'AND'.
input TenantManageBoolExp {
  _and: [TenantManageBoolExp!]
  _not: TenantManageBoolExp
  _or: [TenantManageBoolExp!]
  campusCluster: CampusClusterBoolExp
  campusClusterId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "tenant_manage"
enum TenantManageConstraint {
  # unique or primary key constraint on columns "id"
  tenant_manage_pkey
}

# input type for incrementing numeric columns in table "tenant_manage"
input TenantManageIncInput {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# input type for inserting data into table "tenant_manage"
input TenantManageInsertInput {
  campusCluster: CampusClusterObjRelInsertInput
  campusClusterId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type TenantManageMaxFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by max() on columns of table "tenant_manage"
input TenantManageMaxOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type TenantManageMinFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by min() on columns of table "tenant_manage"
input TenantManageMinOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "tenant_manage"
type TenantManageMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TenantManage!]!
}

# on_conflict condition type for table "tenant_manage"
input TenantManageOnConflict {
  constraint: TenantManageConstraint!
  updateColumns: [TenantManageUpdateColumn!]! = []
  where: TenantManageBoolExp
}

# Ordering options when selecting data from "tenant_manage".
input TenantManageOrderBy {
  campusCluster: CampusClusterOrderBy
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: tenant_manage
input TenantManagePkColumnsInput {
  id: bigint!
}

# select columns of table "tenant_manage"
enum TenantManageSelectColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

# input type for updating data in table "tenant_manage"
input TenantManageSetInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate stddev on columns
type TenantManageStddevFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddev() on columns of table "tenant_manage"
input TenantManageStddevOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type TenantManageStddevPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "tenant_manage"
input TenantManageStddevPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type TenantManageStddevSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "tenant_manage"
input TenantManageStddevSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "tenant_manage"
input TenantManageStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantManageStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantManageStreamCursorValueInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# aggregate sum on columns
type TenantManageSumFields {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantId: bigint
}

# order by sum() on columns of table "tenant_manage"
input TenantManageSumOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# update columns of table "tenant_manage"
enum TenantManageUpdateColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantId
}

input TenantManageUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantManageIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantManageSetInput

  # filter the rows which have to be updated
  where: TenantManageBoolExp!
}

# aggregate variance on columns
type TenantManageVarianceFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by variance() on columns of table "tenant_manage"
input TenantManageVarianceOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type TenantManageVarPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varPop() on columns of table "tenant_manage"
input TenantManageVarPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type TenantManageVarSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantId: Float
}

# order by varSamp() on columns of table "tenant_manage"
input TenantManageVarSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantId: OrderBy
}

# aggregate max on columns
type TenantMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  name: String
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# order by max() on columns of table "tenant"
input TenantMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  domain: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
  name: OrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
}

# aggregate min on columns
type TenantMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  name: String
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# order by min() on columns of table "tenant"
input TenantMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  domain: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
  name: OrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
}

# response of any mutation on the table "tenant"
type TenantMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Tenant!]!
}

# input type for inserting object relation for remote table "tenant"
input TenantObjRelInsertInput {
  data: TenantInsertInput!

  # upsert condition
  onConflict: TenantOnConflict
}

# on_conflict condition type for table "tenant"
input TenantOnConflict {
  constraint: TenantConstraint!
  updateColumns: [TenantUpdateColumn!]! = []
  where: TenantBoolExp
}

# Ordering options when selecting data from "tenant".
input TenantOrderBy {
  accountAllocatesAggregate: AccountAllocateAggregateOrderBy
  accountsAggregate: AccountAggregateOrderBy
  actionsAggregate: ActionAggregateOrderBy
  actorImagesAggregate: ActorImageAggregateOrderBy
  actorsAggregate: ActorAggregateOrderBy
  addressesAggregate: AddressAggregateOrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  botsAggregate: BotAggregateOrderBy
  campusClustersAggregate: CampusClusterAggregateOrderBy
  campusesAggregate: CampusAggregateOrderBy
  canteenFoodsAggregate: CanteenFoodAggregateOrderBy
  canteenMenusAggregate: CanteenMenuAggregateOrderBy
  canteensAggregate: CanteenAggregateOrderBy
  classGroupTeachersAggregate: ClassGroupTeacherAggregateOrderBy
  classGroupsAggregate: ClassGroupAggregateOrderBy
  cohortsAggregate: CohortAggregateOrderBy
  contentsAggregate: ContentAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  documentsAggregate: DocumentAggregateOrderBy
  domain: OrderBy
  eventApprovalStepsAggregate: EventApprovalStepAggregateOrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventManagesAggregate: EventManageAggregateOrderBy
  eventValidationForm: FormOrderBy
  eventValidationFormId: OrderBy
  eventsAggregate: EventAggregateOrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  favoritesAggregate: FavoriteAggregateOrderBy
  fileUploadsAggregate: FileUploadAggregateOrderBy
  financesAggregate: FinanceAggregateOrderBy
  followsAggregate: FollowAggregateOrderBy
  formSubmissionsAggregate: FormSubmissionAggregateOrderBy
  formsAggregate: FormAggregateOrderBy
  grantUnlocksAggregate: GrantUnlockAggregateOrderBy
  grantsAggregate: GrantAggregateOrderBy
  id: OrderBy
  individualsAggregate: IndividualAggregateOrderBy
  isOidcEnabled: OrderBy
  issuesAggregate: IssueAggregateOrderBy
  legalUnitsAggregate: LegalUnitAggregateOrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  missionsAggregate: MissionAggregateOrderBy
  name: OrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
  polesAggregate: PoleAggregateOrderBy
  projectsAggregate: ProjectAggregateOrderBy
  reactionsAggregate: ReactionAggregateOrderBy
  reportsAggregate: ReportAggregateOrderBy
  rolesAggregate: RoleAggregateOrderBy
  sessionsAggregate: SessionAggregateOrderBy
  shortcutsAggregate: ShortcutAggregateOrderBy
  socialsAggregate: SocialAggregateOrderBy
  subjectsAggregate: SubjectAggregateOrderBy
  tagsAggregate: TagAggregateOrderBy
  teamHistoriesAggregate: TeamHistoryAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMembersAggregate: TeamMemberAggregateOrderBy
  teamMetricsAggregate: TeamMetricAggregateOrderBy
  teamsAggregate: TeamAggregateOrderBy
  tenantManagesAggregate: TenantManageAggregateOrderBy
  threadsAggregate: ThreadAggregateOrderBy
  usersAggregate: UserAggregateOrderBy
  validationsAggregate: ValidationAggregateOrderBy
  votesAggregate: VoteAggregateOrderBy
}

# primary key columns input for table: tenant
input TenantPkColumnsInput {
  id: bigint!
}

# select columns of table "tenant"
enum TenantSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  domain

  # column name
  eventValidationFormId

  # column name
  id

  # column name
  isOidcEnabled

  # column name
  name

  # column name
  oidcCallbackUri

  # column name
  oidcClientId

  # column name
  oidcClientSecret

  # column name
  oidcDiscoveryUrl

  # column name
  oidcName

  # column name
  oidcScopes

  # column name
  pointName
}

# select "tenantAggregateBoolExpBool_andArgumentsColumns" columns of table "tenant"
enum TenantSelectColumnTenantAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isOidcEnabled
}

# select "tenantAggregateBoolExpBool_orArgumentsColumns" columns of table "tenant"
enum TenantSelectColumnTenantAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isOidcEnabled
}

# input type for updating data in table "tenant"
input TenantSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  isOidcEnabled: Boolean
  name: String
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# aggregate stddev on columns
type TenantStddevFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddev() on columns of table "tenant"
input TenantStddevOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate stddevPop on columns
type TenantStddevPopFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddevPop() on columns of table "tenant"
input TenantStddevPopOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate stddevSamp on columns
type TenantStddevSampFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddevSamp() on columns of table "tenant"
input TenantStddevSampOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# Streaming cursor of the table "tenant"
input TenantStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  isOidcEnabled: Boolean
  name: String
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# aggregate sum on columns
type TenantSumFields {
  createdById: bigint
  eventValidationFormId: bigint
  id: bigint
}

# order by sum() on columns of table "tenant"
input TenantSumOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# update columns of table "tenant"
enum TenantUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  domain

  # column name
  eventValidationFormId

  # column name
  id

  # column name
  isOidcEnabled

  # column name
  name

  # column name
  oidcCallbackUri

  # column name
  oidcClientId

  # column name
  oidcClientSecret

  # column name
  oidcDiscoveryUrl

  # column name
  oidcName

  # column name
  oidcScopes

  # column name
  pointName
}

input TenantUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantSetInput

  # filter the rows which have to be updated
  where: TenantBoolExp!
}

# aggregate variance on columns
type TenantVarianceFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by variance() on columns of table "tenant"
input TenantVarianceOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate varPop on columns
type TenantVarPopFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by varPop() on columns of table "tenant"
input TenantVarPopOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate varSamp on columns
type TenantVarSampFields {
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by varSamp() on columns of table "tenant"
input TenantVarSampOrderBy {
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# columns and relationships of "thread"
type Thread {
  # An object relationship
  content: Content!
  contentId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  slug: String!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!

  # An array relationship
  threadContributors(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): [ThreadContributors!]!

  # An aggregate relationship
  threadContributorsAggregate(
    # distinct select on columns
    distinctOn: [ThreadContributorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadContributorsOrderBy!]

    # filter the rows returned
    where: ThreadContributorsBoolExp
  ): ThreadContributorsAggregate!

  # An array relationship
  threadTags(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): [ThreadTags!]!

  # An aggregate relationship
  threadTagsAggregate(
    # distinct select on columns
    distinctOn: [ThreadTagsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ThreadTagsOrderBy!]

    # filter the rows returned
    where: ThreadTagsBoolExp
  ): ThreadTagsAggregate!
}

# aggregated selection of "thread"
type ThreadAggregate {
  aggregate: ThreadAggregateFields
  nodes: [Thread!]!
}

input ThreadAggregateBoolExp {
  count: threadAggregateBoolExpCount
}

input threadAggregateBoolExpCount {
  arguments: [ThreadSelectColumn!]
  distinct: Boolean
  filter: ThreadBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "thread"
type ThreadAggregateFields {
  avg: ThreadAvgFields
  count(columns: [ThreadSelectColumn!], distinct: Boolean): Int!
  max: ThreadMaxFields
  min: ThreadMinFields
  stddev: ThreadStddevFields
  stddevPop: ThreadStddevPopFields
  stddevSamp: ThreadStddevSampFields
  sum: ThreadSumFields
  varPop: ThreadVarPopFields
  varSamp: ThreadVarSampFields
  variance: ThreadVarianceFields
}

# order by aggregate values of table "thread"
input ThreadAggregateOrderBy {
  avg: ThreadAvgOrderBy
  count: OrderBy
  max: ThreadMaxOrderBy
  min: ThreadMinOrderBy
  stddev: ThreadStddevOrderBy
  stddevPop: ThreadStddevPopOrderBy
  stddevSamp: ThreadStddevSampOrderBy
  sum: ThreadSumOrderBy
  varPop: ThreadVarPopOrderBy
  varSamp: ThreadVarSampOrderBy
  variance: ThreadVarianceOrderBy
}

# input type for inserting array relation for remote table "thread"
input ThreadArrRelInsertInput {
  data: [ThreadInsertInput!]!

  # upsert condition
  onConflict: ThreadOnConflict
}

# aggregate avg on columns
type ThreadAvgFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "thread"
input ThreadAvgOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "thread". All fields are combined with a logical 'AND'.
input ThreadBoolExp {
  _and: [ThreadBoolExp!]
  _not: ThreadBoolExp
  _or: [ThreadBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  slug: StringComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  threadContributors: ThreadContributorsBoolExp
  threadContributorsAggregate: ThreadContributorsAggregateBoolExp
  threadTags: ThreadTagsBoolExp
  threadTagsAggregate: ThreadTagsAggregateBoolExp
}

# unique or primary key constraints on table "thread"
enum ThreadConstraint {
  # unique or primary key constraint on columns "content_id"
  thread_content_id_unique

  # unique or primary key constraint on columns "id"
  thread_pkey
}

# columns and relationships of "thread_contributors"
type ThreadContributors {
  # An object relationship
  individual: Individual!
  individualId: bigint!

  # An object relationship
  thread: Thread!
  threadId: bigint!
}

# aggregated selection of "thread_contributors"
type ThreadContributorsAggregate {
  aggregate: ThreadContributorsAggregateFields
  nodes: [ThreadContributors!]!
}

input ThreadContributorsAggregateBoolExp {
  count: threadContributorsAggregateBoolExpCount
}

input threadContributorsAggregateBoolExpCount {
  arguments: [ThreadContributorsSelectColumn!]
  distinct: Boolean
  filter: ThreadContributorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "thread_contributors"
type ThreadContributorsAggregateFields {
  avg: ThreadContributorsAvgFields
  count(columns: [ThreadContributorsSelectColumn!], distinct: Boolean): Int!
  max: ThreadContributorsMaxFields
  min: ThreadContributorsMinFields
  stddev: ThreadContributorsStddevFields
  stddevPop: ThreadContributorsStddevPopFields
  stddevSamp: ThreadContributorsStddevSampFields
  sum: ThreadContributorsSumFields
  varPop: ThreadContributorsVarPopFields
  varSamp: ThreadContributorsVarSampFields
  variance: ThreadContributorsVarianceFields
}

# order by aggregate values of table "thread_contributors"
input ThreadContributorsAggregateOrderBy {
  avg: ThreadContributorsAvgOrderBy
  count: OrderBy
  max: ThreadContributorsMaxOrderBy
  min: ThreadContributorsMinOrderBy
  stddev: ThreadContributorsStddevOrderBy
  stddevPop: ThreadContributorsStddevPopOrderBy
  stddevSamp: ThreadContributorsStddevSampOrderBy
  sum: ThreadContributorsSumOrderBy
  varPop: ThreadContributorsVarPopOrderBy
  varSamp: ThreadContributorsVarSampOrderBy
  variance: ThreadContributorsVarianceOrderBy
}

# input type for inserting array relation for remote table "thread_contributors"
input ThreadContributorsArrRelInsertInput {
  data: [ThreadContributorsInsertInput!]!

  # upsert condition
  onConflict: ThreadContributorsOnConflict
}

# aggregate avg on columns
type ThreadContributorsAvgFields {
  individualId: Float
  threadId: Float
}

# order by avg() on columns of table "thread_contributors"
input ThreadContributorsAvgOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# Boolean expression to filter rows from the table "thread_contributors". All fields are combined with a logical 'AND'.
input ThreadContributorsBoolExp {
  _and: [ThreadContributorsBoolExp!]
  _not: ThreadContributorsBoolExp
  _or: [ThreadContributorsBoolExp!]
  individual: IndividualBoolExp
  individualId: BigintComparisonExp
  thread: ThreadBoolExp
  threadId: BigintComparisonExp
}

# unique or primary key constraints on table "thread_contributors"
enum ThreadContributorsConstraint {
  # unique or primary key constraint on columns "individual_id", "thread_id"
  thread_contributors_pkey
}

# input type for incrementing numeric columns in table "thread_contributors"
input ThreadContributorsIncInput {
  individualId: bigint
  threadId: bigint
}

# input type for inserting data into table "thread_contributors"
input ThreadContributorsInsertInput {
  individual: IndividualObjRelInsertInput
  individualId: bigint
  thread: ThreadObjRelInsertInput
  threadId: bigint
}

# aggregate max on columns
type ThreadContributorsMaxFields {
  individualId: bigint
  threadId: bigint
}

# order by max() on columns of table "thread_contributors"
input ThreadContributorsMaxOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# aggregate min on columns
type ThreadContributorsMinFields {
  individualId: bigint
  threadId: bigint
}

# order by min() on columns of table "thread_contributors"
input ThreadContributorsMinOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# response of any mutation on the table "thread_contributors"
type ThreadContributorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ThreadContributors!]!
}

# on_conflict condition type for table "thread_contributors"
input ThreadContributorsOnConflict {
  constraint: ThreadContributorsConstraint!
  updateColumns: [ThreadContributorsUpdateColumn!]! = []
  where: ThreadContributorsBoolExp
}

# Ordering options when selecting data from "thread_contributors".
input ThreadContributorsOrderBy {
  individual: IndividualOrderBy
  individualId: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
}

# primary key columns input for table: thread_contributors
input ThreadContributorsPkColumnsInput {
  individualId: bigint!
  threadId: bigint!
}

# select columns of table "thread_contributors"
enum ThreadContributorsSelectColumn {
  # column name
  individualId

  # column name
  threadId
}

# input type for updating data in table "thread_contributors"
input ThreadContributorsSetInput {
  individualId: bigint
  threadId: bigint
}

# aggregate stddev on columns
type ThreadContributorsStddevFields {
  individualId: Float
  threadId: Float
}

# order by stddev() on columns of table "thread_contributors"
input ThreadContributorsStddevOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# aggregate stddevPop on columns
type ThreadContributorsStddevPopFields {
  individualId: Float
  threadId: Float
}

# order by stddevPop() on columns of table "thread_contributors"
input ThreadContributorsStddevPopOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# aggregate stddevSamp on columns
type ThreadContributorsStddevSampFields {
  individualId: Float
  threadId: Float
}

# order by stddevSamp() on columns of table "thread_contributors"
input ThreadContributorsStddevSampOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# Streaming cursor of the table "thread_contributors"
input ThreadContributorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ThreadContributorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ThreadContributorsStreamCursorValueInput {
  individualId: bigint
  threadId: bigint
}

# aggregate sum on columns
type ThreadContributorsSumFields {
  individualId: bigint
  threadId: bigint
}

# order by sum() on columns of table "thread_contributors"
input ThreadContributorsSumOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# update columns of table "thread_contributors"
enum ThreadContributorsUpdateColumn {
  # column name
  individualId

  # column name
  threadId
}

input ThreadContributorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ThreadContributorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ThreadContributorsSetInput

  # filter the rows which have to be updated
  where: ThreadContributorsBoolExp!
}

# aggregate variance on columns
type ThreadContributorsVarianceFields {
  individualId: Float
  threadId: Float
}

# order by variance() on columns of table "thread_contributors"
input ThreadContributorsVarianceOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# aggregate varPop on columns
type ThreadContributorsVarPopFields {
  individualId: Float
  threadId: Float
}

# order by varPop() on columns of table "thread_contributors"
input ThreadContributorsVarPopOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# aggregate varSamp on columns
type ThreadContributorsVarSampFields {
  individualId: Float
  threadId: Float
}

# order by varSamp() on columns of table "thread_contributors"
input ThreadContributorsVarSampOrderBy {
  individualId: OrderBy
  threadId: OrderBy
}

# input type for incrementing numeric columns in table "thread"
input ThreadIncInput {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "thread"
input ThreadInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  threadContributors: ThreadContributorsArrRelInsertInput
  threadTags: ThreadTagsArrRelInsertInput
}

# aggregate max on columns
type ThreadMaxFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# order by max() on columns of table "thread"
input ThreadMaxOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type ThreadMinFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# order by min() on columns of table "thread"
input ThreadMinOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "thread"
type ThreadMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Thread!]!
}

# input type for inserting object relation for remote table "thread"
input ThreadObjRelInsertInput {
  data: ThreadInsertInput!

  # upsert condition
  onConflict: ThreadOnConflict
}

# on_conflict condition type for table "thread"
input ThreadOnConflict {
  constraint: ThreadConstraint!
  updateColumns: [ThreadUpdateColumn!]! = []
  where: ThreadBoolExp
}

# Ordering options when selecting data from "thread".
input ThreadOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  slug: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  threadContributorsAggregate: ThreadContributorsAggregateOrderBy
  threadTagsAggregate: ThreadTagsAggregateOrderBy
}

# primary key columns input for table: thread
input ThreadPkColumnsInput {
  id: bigint!
}

# select columns of table "thread"
enum ThreadSelectColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  slug

  # column name
  tenantId
}

# input type for updating data in table "thread"
input ThreadSetInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# aggregate stddev on columns
type ThreadStddevFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "thread"
input ThreadStddevOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ThreadStddevPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "thread"
input ThreadStddevPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ThreadStddevSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "thread"
input ThreadStddevSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "thread"
input ThreadStreamCursorInput {
  # Stream column input with initial value
  initialValue: ThreadStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ThreadStreamCursorValueInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  slug: String
  tenantId: bigint
}

# aggregate sum on columns
type ThreadSumFields {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "thread"
input ThreadSumOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "thread_tags"
type ThreadTags {
  # An object relationship
  tag: Tag!
  tagId: bigint!

  # An object relationship
  thread: Thread!
  threadId: bigint!
}

# aggregated selection of "thread_tags"
type ThreadTagsAggregate {
  aggregate: ThreadTagsAggregateFields
  nodes: [ThreadTags!]!
}

input ThreadTagsAggregateBoolExp {
  count: threadTagsAggregateBoolExpCount
}

input threadTagsAggregateBoolExpCount {
  arguments: [ThreadTagsSelectColumn!]
  distinct: Boolean
  filter: ThreadTagsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "thread_tags"
type ThreadTagsAggregateFields {
  avg: ThreadTagsAvgFields
  count(columns: [ThreadTagsSelectColumn!], distinct: Boolean): Int!
  max: ThreadTagsMaxFields
  min: ThreadTagsMinFields
  stddev: ThreadTagsStddevFields
  stddevPop: ThreadTagsStddevPopFields
  stddevSamp: ThreadTagsStddevSampFields
  sum: ThreadTagsSumFields
  varPop: ThreadTagsVarPopFields
  varSamp: ThreadTagsVarSampFields
  variance: ThreadTagsVarianceFields
}

# order by aggregate values of table "thread_tags"
input ThreadTagsAggregateOrderBy {
  avg: ThreadTagsAvgOrderBy
  count: OrderBy
  max: ThreadTagsMaxOrderBy
  min: ThreadTagsMinOrderBy
  stddev: ThreadTagsStddevOrderBy
  stddevPop: ThreadTagsStddevPopOrderBy
  stddevSamp: ThreadTagsStddevSampOrderBy
  sum: ThreadTagsSumOrderBy
  varPop: ThreadTagsVarPopOrderBy
  varSamp: ThreadTagsVarSampOrderBy
  variance: ThreadTagsVarianceOrderBy
}

# input type for inserting array relation for remote table "thread_tags"
input ThreadTagsArrRelInsertInput {
  data: [ThreadTagsInsertInput!]!

  # upsert condition
  onConflict: ThreadTagsOnConflict
}

# aggregate avg on columns
type ThreadTagsAvgFields {
  tagId: Float
  threadId: Float
}

# order by avg() on columns of table "thread_tags"
input ThreadTagsAvgOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# Boolean expression to filter rows from the table "thread_tags". All fields are combined with a logical 'AND'.
input ThreadTagsBoolExp {
  _and: [ThreadTagsBoolExp!]
  _not: ThreadTagsBoolExp
  _or: [ThreadTagsBoolExp!]
  tag: TagBoolExp
  tagId: BigintComparisonExp
  thread: ThreadBoolExp
  threadId: BigintComparisonExp
}

# unique or primary key constraints on table "thread_tags"
enum ThreadTagsConstraint {
  # unique or primary key constraint on columns "tag_id", "thread_id"
  thread_tags_pkey
}

# input type for incrementing numeric columns in table "thread_tags"
input ThreadTagsIncInput {
  tagId: bigint
  threadId: bigint
}

# input type for inserting data into table "thread_tags"
input ThreadTagsInsertInput {
  tag: TagObjRelInsertInput
  tagId: bigint
  thread: ThreadObjRelInsertInput
  threadId: bigint
}

# aggregate max on columns
type ThreadTagsMaxFields {
  tagId: bigint
  threadId: bigint
}

# order by max() on columns of table "thread_tags"
input ThreadTagsMaxOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# aggregate min on columns
type ThreadTagsMinFields {
  tagId: bigint
  threadId: bigint
}

# order by min() on columns of table "thread_tags"
input ThreadTagsMinOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# response of any mutation on the table "thread_tags"
type ThreadTagsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ThreadTags!]!
}

# on_conflict condition type for table "thread_tags"
input ThreadTagsOnConflict {
  constraint: ThreadTagsConstraint!
  updateColumns: [ThreadTagsUpdateColumn!]! = []
  where: ThreadTagsBoolExp
}

# Ordering options when selecting data from "thread_tags".
input ThreadTagsOrderBy {
  tag: TagOrderBy
  tagId: OrderBy
  thread: ThreadOrderBy
  threadId: OrderBy
}

# primary key columns input for table: thread_tags
input ThreadTagsPkColumnsInput {
  tagId: bigint!
  threadId: bigint!
}

# select columns of table "thread_tags"
enum ThreadTagsSelectColumn {
  # column name
  tagId

  # column name
  threadId
}

# input type for updating data in table "thread_tags"
input ThreadTagsSetInput {
  tagId: bigint
  threadId: bigint
}

# aggregate stddev on columns
type ThreadTagsStddevFields {
  tagId: Float
  threadId: Float
}

# order by stddev() on columns of table "thread_tags"
input ThreadTagsStddevOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# aggregate stddevPop on columns
type ThreadTagsStddevPopFields {
  tagId: Float
  threadId: Float
}

# order by stddevPop() on columns of table "thread_tags"
input ThreadTagsStddevPopOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# aggregate stddevSamp on columns
type ThreadTagsStddevSampFields {
  tagId: Float
  threadId: Float
}

# order by stddevSamp() on columns of table "thread_tags"
input ThreadTagsStddevSampOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# Streaming cursor of the table "thread_tags"
input ThreadTagsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ThreadTagsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ThreadTagsStreamCursorValueInput {
  tagId: bigint
  threadId: bigint
}

# aggregate sum on columns
type ThreadTagsSumFields {
  tagId: bigint
  threadId: bigint
}

# order by sum() on columns of table "thread_tags"
input ThreadTagsSumOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# update columns of table "thread_tags"
enum ThreadTagsUpdateColumn {
  # column name
  tagId

  # column name
  threadId
}

input ThreadTagsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ThreadTagsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ThreadTagsSetInput

  # filter the rows which have to be updated
  where: ThreadTagsBoolExp!
}

# aggregate variance on columns
type ThreadTagsVarianceFields {
  tagId: Float
  threadId: Float
}

# order by variance() on columns of table "thread_tags"
input ThreadTagsVarianceOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# aggregate varPop on columns
type ThreadTagsVarPopFields {
  tagId: Float
  threadId: Float
}

# order by varPop() on columns of table "thread_tags"
input ThreadTagsVarPopOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# aggregate varSamp on columns
type ThreadTagsVarSampFields {
  tagId: Float
  threadId: Float
}

# order by varSamp() on columns of table "thread_tags"
input ThreadTagsVarSampOrderBy {
  tagId: OrderBy
  threadId: OrderBy
}

# update columns of table "thread"
enum ThreadUpdateColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  slug

  # column name
  tenantId
}

input ThreadUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ThreadIncInput

  # sets the columns of the filtered rows to the given values
  _set: ThreadSetInput

  # filter the rows which have to be updated
  where: ThreadBoolExp!
}

# aggregate variance on columns
type ThreadVarianceFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "thread"
input ThreadVarianceOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ThreadVarPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "thread"
input ThreadVarPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ThreadVarSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "thread"
input ThreadVarSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

scalar timestamptz

# Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "user"
type User {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  classGroupTeachers(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): [ClassGroupTeacher!]!

  # An aggregate relationship
  classGroupTeachersAggregate(
    # distinct select on columns
    distinctOn: [ClassGroupTeacherSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ClassGroupTeacherOrderBy!]

    # filter the rows returned
    where: ClassGroupTeacherBoolExp
  ): ClassGroupTeacherAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): [EventSupervisors!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorsOrderBy!]

    # filter the rows returned
    where: EventSupervisorsBoolExp
  ): EventSupervisorsAggregate!
  firstName: String!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  individual: Individual
  isDarkModePreferred: Boolean!
  isDataAnonymizedOnDeactivation: Boolean!
  isDataExportedOnDeactivation: Boolean!
  isIntroductionFinished: Boolean!
  isOnboardingFinished: Boolean!
  lastName: String!
  middleNames: _text!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!
  points: Float!

  # An array relationship
  sessions(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): [Session!]!

  # An aggregate relationship
  sessionsAggregate(
    # distinct select on columns
    distinctOn: [SessionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SessionOrderBy!]

    # filter the rows returned
    where: SessionBoolExp
  ): SessionAggregate!

  # An array relationship
  shortcuts(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): [Shortcut!]!

  # An aggregate relationship
  shortcutsAggregate(
    # distinct select on columns
    distinctOn: [ShortcutSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ShortcutOrderBy!]

    # filter the rows returned
    where: ShortcutBoolExp
  ): ShortcutAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
}

# aggregated selection of "user"
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

input UserAggregateBoolExp {
  bool_and: userAggregateBoolExpBool_and
  bool_or: userAggregateBoolExpBool_or
  count: userAggregateBoolExpCount
}

input userAggregateBoolExpBool_and {
  arguments: UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpBool_or {
  arguments: UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpCount {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "user"
type UserAggregateFields {
  avg: UserAvgFields
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
  stddev: UserStddevFields
  stddevPop: UserStddevPopFields
  stddevSamp: UserStddevSampFields
  sum: UserSumFields
  varPop: UserVarPopFields
  varSamp: UserVarSampFields
  variance: UserVarianceFields
}

# order by aggregate values of table "user"
input UserAggregateOrderBy {
  avg: UserAvgOrderBy
  count: OrderBy
  max: UserMaxOrderBy
  min: UserMinOrderBy
  stddev: UserStddevOrderBy
  stddevPop: UserStddevPopOrderBy
  stddevSamp: UserStddevSampOrderBy
  sum: UserSumOrderBy
  varPop: UserVarPopOrderBy
  varSamp: UserVarSampOrderBy
  variance: UserVarianceOrderBy
}

# input type for inserting array relation for remote table "user"
input UserArrRelInsertInput {
  data: [UserInsertInput!]!

  # upsert condition
  onConflict: UserOnConflict
}

# aggregate avg on columns
type UserAvgFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by avg() on columns of table "user"
input UserAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  classGroupTeachers: ClassGroupTeacherBoolExp
  classGroupTeachersAggregate: ClassGroupTeacherAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  eventSupervisors: EventSupervisorsBoolExp
  eventSupervisorsAggregate: EventSupervisorsAggregateBoolExp
  firstName: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  individual: IndividualBoolExp
  isDarkModePreferred: BooleanComparisonExp
  isDataAnonymizedOnDeactivation: BooleanComparisonExp
  isDataExportedOnDeactivation: BooleanComparisonExp
  isIntroductionFinished: BooleanComparisonExp
  isOnboardingFinished: BooleanComparisonExp
  lastName: StringComparisonExp
  middleNames: _textComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  points: FloatComparisonExp
  sessions: SessionBoolExp
  sessionsAggregate: SessionAggregateBoolExp
  shortcuts: ShortcutBoolExp
  shortcutsAggregate: ShortcutAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMembers: TeamMemberBoolExp
  teamMembersAggregate: TeamMemberAggregateBoolExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
}

# unique or primary key constraints on table "user"
enum UserConstraint {
  # unique or primary key constraint on columns "id"
  user_pkey
}

# input type for incrementing numeric columns in table "user"
input UserIncInput {
  createdById: bigint
  id: bigint
  points: Float
  tenantId: bigint
}

# input type for inserting data into table "user"
input UserInsertInput {
  actions: ActionArrRelInsertInput
  classGroupTeachers: ClassGroupTeacherArrRelInsertInput
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventJoins: EventJoinArrRelInsertInput
  eventSupervisors: EventSupervisorsArrRelInsertInput
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  individual: IndividualObjRelInsertInput
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: _text
  missionJoins: MissionJoinArrRelInsertInput
  points: Float
  sessions: SessionArrRelInsertInput
  shortcuts: ShortcutArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMembers: TeamMemberArrRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantId: bigint
}

# aggregate max on columns
type UserMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  lastName: String
  points: Float
  tenantId: bigint
}

# order by max() on columns of table "user"
input UserMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  firstName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastName: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# aggregate min on columns
type UserMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  lastName: String
  points: Float
  tenantId: bigint
}

# order by min() on columns of table "user"
input UserMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  firstName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastName: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# response of any mutation on the table "user"
type UserMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [User!]!
}

# input type for inserting object relation for remote table "user"
input UserObjRelInsertInput {
  data: UserInsertInput!

  # upsert condition
  onConflict: UserOnConflict
}

# on_conflict condition type for table "user"
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

# Ordering options when selecting data from "user".
input UserOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  classGroupTeachersAggregate: ClassGroupTeacherAggregateOrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventSupervisorsAggregate: EventSupervisorsAggregateOrderBy
  firstName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  individual: IndividualOrderBy
  isDarkModePreferred: OrderBy
  isDataAnonymizedOnDeactivation: OrderBy
  isDataExportedOnDeactivation: OrderBy
  isIntroductionFinished: OrderBy
  isOnboardingFinished: OrderBy
  lastName: OrderBy
  middleNames: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  points: OrderBy
  sessionsAggregate: SessionAggregateOrderBy
  shortcutsAggregate: ShortcutAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMembersAggregate: TeamMemberAggregateOrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
}

# primary key columns input for table: user
input UserPkColumnsInput {
  id: bigint!
}

# select columns of table "user"
enum UserSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  firstName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished

  # column name
  lastName

  # column name
  middleNames

  # column name
  points

  # column name
  tenantId
}

# select "userAggregateBoolExpBool_andArgumentsColumns" columns of table "user"
enum UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished
}

# select "userAggregateBoolExpBool_orArgumentsColumns" columns of table "user"
enum UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished
}

# input type for updating data in table "user"
input UserSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: _text
  points: Float
  tenantId: bigint
}

# aggregate stddev on columns
type UserStddevFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by stddev() on columns of table "user"
input UserStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type UserStddevPopFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "user"
input UserStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type UserStddevSampFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "user"
input UserStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "user"
input UserStreamCursorInput {
  # Stream column input with initial value
  initialValue: UserStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input UserStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: _text
  points: Float
  tenantId: bigint
}

# aggregate sum on columns
type UserSumFields {
  createdById: bigint
  id: bigint
  points: Float
  tenantId: bigint
}

# order by sum() on columns of table "user"
input UserSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# update columns of table "user"
enum UserUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  firstName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished

  # column name
  lastName

  # column name
  middleNames

  # column name
  points

  # column name
  tenantId
}

input UserUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: UserIncInput

  # sets the columns of the filtered rows to the given values
  _set: UserSetInput

  # filter the rows which have to be updated
  where: UserBoolExp!
}

# aggregate variance on columns
type UserVarianceFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by variance() on columns of table "user"
input UserVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type UserVarPopFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by varPop() on columns of table "user"
input UserVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type UserVarSampFields {
  createdById: Float
  id: Float
  points: Float
  tenantId: Float
}

# order by varSamp() on columns of table "user"
input UserVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "validation"
type Validation {
  # An object relationship
  content: Content
  contentId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  type: String!
}

# aggregated selection of "validation"
type ValidationAggregate {
  aggregate: ValidationAggregateFields
  nodes: [Validation!]!
}

input ValidationAggregateBoolExp {
  count: validationAggregateBoolExpCount
}

input validationAggregateBoolExpCount {
  arguments: [ValidationSelectColumn!]
  distinct: Boolean
  filter: ValidationBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "validation"
type ValidationAggregateFields {
  avg: ValidationAvgFields
  count(columns: [ValidationSelectColumn!], distinct: Boolean): Int!
  max: ValidationMaxFields
  min: ValidationMinFields
  stddev: ValidationStddevFields
  stddevPop: ValidationStddevPopFields
  stddevSamp: ValidationStddevSampFields
  sum: ValidationSumFields
  varPop: ValidationVarPopFields
  varSamp: ValidationVarSampFields
  variance: ValidationVarianceFields
}

# order by aggregate values of table "validation"
input ValidationAggregateOrderBy {
  avg: ValidationAvgOrderBy
  count: OrderBy
  max: ValidationMaxOrderBy
  min: ValidationMinOrderBy
  stddev: ValidationStddevOrderBy
  stddevPop: ValidationStddevPopOrderBy
  stddevSamp: ValidationStddevSampOrderBy
  sum: ValidationSumOrderBy
  varPop: ValidationVarPopOrderBy
  varSamp: ValidationVarSampOrderBy
  variance: ValidationVarianceOrderBy
}

# input type for inserting array relation for remote table "validation"
input ValidationArrRelInsertInput {
  data: [ValidationInsertInput!]!

  # upsert condition
  onConflict: ValidationOnConflict
}

# aggregate avg on columns
type ValidationAvgFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by avg() on columns of table "validation"
input ValidationAvgOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Boolean expression to filter rows from the table "validation". All fields are combined with a logical 'AND'.
input ValidationBoolExp {
  _and: [ValidationBoolExp!]
  _not: ValidationBoolExp
  _or: [ValidationBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "validation"
enum ValidationConstraint {
  # unique or primary key constraint on columns "id"
  validation_pkey
}

# input type for incrementing numeric columns in table "validation"
input ValidationIncInput {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# input type for inserting data into table "validation"
input ValidationInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  type: String
}

# aggregate max on columns
type ValidationMaxFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# order by max() on columns of table "validation"
input ValidationMaxOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ValidationMinFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# order by min() on columns of table "validation"
input ValidationMinOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "validation"
type ValidationMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Validation!]!
}

# on_conflict condition type for table "validation"
input ValidationOnConflict {
  constraint: ValidationConstraint!
  updateColumns: [ValidationUpdateColumn!]! = []
  where: ValidationBoolExp
}

# Ordering options when selecting data from "validation".
input ValidationOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  type: OrderBy
}

# primary key columns input for table: validation
input ValidationPkColumnsInput {
  id: bigint!
}

# select columns of table "validation"
enum ValidationSelectColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  type
}

# input type for updating data in table "validation"
input ValidationSetInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# aggregate stddev on columns
type ValidationStddevFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddev() on columns of table "validation"
input ValidationStddevOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevPop on columns
type ValidationStddevPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevPop() on columns of table "validation"
input ValidationStddevPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate stddevSamp on columns
type ValidationStddevSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by stddevSamp() on columns of table "validation"
input ValidationStddevSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# Streaming cursor of the table "validation"
input ValidationStreamCursorInput {
  # Stream column input with initial value
  initialValue: ValidationStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ValidationStreamCursorValueInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  type: String
}

# aggregate sum on columns
type ValidationSumFields {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
}

# order by sum() on columns of table "validation"
input ValidationSumOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# update columns of table "validation"
enum ValidationUpdateColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  type
}

input ValidationUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ValidationIncInput

  # sets the columns of the filtered rows to the given values
  _set: ValidationSetInput

  # filter the rows which have to be updated
  where: ValidationBoolExp!
}

# aggregate variance on columns
type ValidationVarianceFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by variance() on columns of table "validation"
input ValidationVarianceOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varPop on columns
type ValidationVarPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varPop() on columns of table "validation"
input ValidationVarPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# aggregate varSamp on columns
type ValidationVarSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
}

# order by varSamp() on columns of table "validation"
input ValidationVarSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
}

# columns and relationships of "vote"
type Vote {
  # An object relationship
  content: Content
  contentId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: Individual
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  lastActiveDate: timestamptz

  # An object relationship
  tenant: Tenant!
  tenantId: bigint!
  value: smallint!
}

# aggregated selection of "vote"
type VoteAggregate {
  aggregate: VoteAggregateFields
  nodes: [Vote!]!
}

input VoteAggregateBoolExp {
  count: voteAggregateBoolExpCount
}

input voteAggregateBoolExpCount {
  arguments: [VoteSelectColumn!]
  distinct: Boolean
  filter: VoteBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "vote"
type VoteAggregateFields {
  avg: VoteAvgFields
  count(columns: [VoteSelectColumn!], distinct: Boolean): Int!
  max: VoteMaxFields
  min: VoteMinFields
  stddev: VoteStddevFields
  stddevPop: VoteStddevPopFields
  stddevSamp: VoteStddevSampFields
  sum: VoteSumFields
  varPop: VoteVarPopFields
  varSamp: VoteVarSampFields
  variance: VoteVarianceFields
}

# order by aggregate values of table "vote"
input VoteAggregateOrderBy {
  avg: VoteAvgOrderBy
  count: OrderBy
  max: VoteMaxOrderBy
  min: VoteMinOrderBy
  stddev: VoteStddevOrderBy
  stddevPop: VoteStddevPopOrderBy
  stddevSamp: VoteStddevSampOrderBy
  sum: VoteSumOrderBy
  varPop: VoteVarPopOrderBy
  varSamp: VoteVarSampOrderBy
  variance: VoteVarianceOrderBy
}

# input type for inserting array relation for remote table "vote"
input VoteArrRelInsertInput {
  data: [VoteInsertInput!]!

  # upsert condition
  onConflict: VoteOnConflict
}

# aggregate avg on columns
type VoteAvgFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by avg() on columns of table "vote"
input VoteAvgOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# Boolean expression to filter rows from the table "vote". All fields are combined with a logical 'AND'.
input VoteBoolExp {
  _and: [VoteBoolExp!]
  _not: VoteBoolExp
  _or: [VoteBoolExp!]
  content: ContentBoolExp
  contentId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: IndividualBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastActiveDate: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: BigintComparisonExp
  value: SmallintComparisonExp
}

# unique or primary key constraints on table "vote"
enum VoteConstraint {
  # unique or primary key constraint on columns "id"
  vote_pkey
}

# input type for incrementing numeric columns in table "vote"
input VoteIncInput {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  value: smallint
}

# input type for inserting data into table "vote"
input VoteInsertInput {
  content: ContentObjRelInsertInput
  contentId: bigint
  createdAt: timestamptz
  createdBy: IndividualObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenant: TenantObjRelInsertInput
  tenantId: bigint
  value: smallint
}

# aggregate max on columns
type VoteMaxFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  value: smallint
}

# order by max() on columns of table "vote"
input VoteMaxOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# aggregate min on columns
type VoteMinFields {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  value: smallint
}

# order by min() on columns of table "vote"
input VoteMinOrderBy {
  contentId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# response of any mutation on the table "vote"
type VoteMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Vote!]!
}

# on_conflict condition type for table "vote"
input VoteOnConflict {
  constraint: VoteConstraint!
  updateColumns: [VoteUpdateColumn!]! = []
  where: VoteBoolExp
}

# Ordering options when selecting data from "vote".
input VoteOrderBy {
  content: ContentOrderBy
  contentId: OrderBy
  createdAt: OrderBy
  createdBy: IndividualOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastActiveDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  value: OrderBy
}

# primary key columns input for table: vote
input VotePkColumnsInput {
  id: bigint!
}

# select columns of table "vote"
enum VoteSelectColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  value
}

# input type for updating data in table "vote"
input VoteSetInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  value: smallint
}

# aggregate stddev on columns
type VoteStddevFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by stddev() on columns of table "vote"
input VoteStddevOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# aggregate stddevPop on columns
type VoteStddevPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by stddevPop() on columns of table "vote"
input VoteStddevPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# aggregate stddevSamp on columns
type VoteStddevSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by stddevSamp() on columns of table "vote"
input VoteStddevSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# Streaming cursor of the table "vote"
input VoteStreamCursorInput {
  # Stream column input with initial value
  initialValue: VoteStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input VoteStreamCursorValueInput {
  contentId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  lastActiveDate: timestamptz
  tenantId: bigint
  value: smallint
}

# aggregate sum on columns
type VoteSumFields {
  contentId: bigint
  createdById: bigint
  id: bigint
  tenantId: bigint
  value: smallint
}

# order by sum() on columns of table "vote"
input VoteSumOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# update columns of table "vote"
enum VoteUpdateColumn {
  # column name
  contentId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastActiveDate

  # column name
  tenantId

  # column name
  value
}

input VoteUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: VoteIncInput

  # sets the columns of the filtered rows to the given values
  _set: VoteSetInput

  # filter the rows which have to be updated
  where: VoteBoolExp!
}

# aggregate variance on columns
type VoteVarianceFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by variance() on columns of table "vote"
input VoteVarianceOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# aggregate varPop on columns
type VoteVarPopFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by varPop() on columns of table "vote"
input VoteVarPopOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

# aggregate varSamp on columns
type VoteVarSampFields {
  contentId: Float
  createdById: Float
  id: Float
  tenantId: Float
  value: Float
}

# order by varSamp() on columns of table "vote"
input VoteVarSampOrderBy {
  contentId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantId: OrderBy
  value: OrderBy
}

