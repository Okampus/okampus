# whether this query should be cached (Hasura Cloud only)
directive @cached(
  # measured in seconds
  ttl: Int! = 60

  # refresh the cache entry
  refresh: Boolean! = false
) on QUERY

# columns and relationships of "action"
type Action {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  eventJoin: EventJoin
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  points: smallint
  pointsProcessedAt: timestamptz

  # An object relationship
  pointsProcessedBy: User
  pointsProcessedById: bigint

  # An object relationship
  project: Project
  projectId: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "action"
type ActionAggregate {
  aggregate: ActionAggregateFields
  nodes: [Action!]!
}

input ActionAggregateBoolExp {
  count: actionAggregateBoolExpCount
}

input actionAggregateBoolExpCount {
  arguments: [ActionSelectColumn!]
  distinct: Boolean
  filter: ActionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "action"
type ActionAggregateFields {
  avg: ActionAvgFields
  count(columns: [ActionSelectColumn!], distinct: Boolean): Int!
  max: ActionMaxFields
  min: ActionMinFields
  stddev: ActionStddevFields
  stddevPop: ActionStddevPopFields
  stddevSamp: ActionStddevSampFields
  sum: ActionSumFields
  varPop: ActionVarPopFields
  varSamp: ActionVarSampFields
  variance: ActionVarianceFields
}

# order by aggregate values of table "action"
input ActionAggregateOrderBy {
  avg: ActionAvgOrderBy
  count: OrderBy
  max: ActionMaxOrderBy
  min: ActionMinOrderBy
  stddev: ActionStddevOrderBy
  stddevPop: ActionStddevPopOrderBy
  stddevSamp: ActionStddevSampOrderBy
  sum: ActionSumOrderBy
  varPop: ActionVarPopOrderBy
  varSamp: ActionVarSampOrderBy
  variance: ActionVarianceOrderBy
}

# input type for inserting array relation for remote table "action"
input ActionArrRelInsertInput {
  data: [ActionInsertInput!]!

  # upsert condition
  onConflict: ActionOnConflict
}

# aggregate avg on columns
type ActionAvgFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by avg() on columns of table "action"
input ActionAvgOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
input ActionBoolExp {
  _and: [ActionBoolExp!]
  _not: ActionBoolExp
  _or: [ActionBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventJoin: EventJoinBoolExp
  eventJoinId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  points: SmallintComparisonExp
  pointsProcessedAt: TimestamptzComparisonExp
  pointsProcessedBy: UserBoolExp
  pointsProcessedById: BigintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "action"
enum ActionConstraint {
  # unique or primary key constraint on columns "id"
  action_pkey
}

# input type for incrementing numeric columns in table "action"
input ActionIncInput {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  points: smallint
  pointsProcessedById: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# input type for inserting data into table "action"
input ActionInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoin: EventJoinObjRelInsertInput
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedBy: UserObjRelInsertInput
  pointsProcessedById: bigint
  project: ProjectObjRelInsertInput
  projectId: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type ActionMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by max() on columns of table "action"
input ActionMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type ActionMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by min() on columns of table "action"
input ActionMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "action"
type ActionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Action!]!
}

# on_conflict condition type for table "action"
input ActionOnConflict {
  constraint: ActionConstraint!
  updateColumns: [ActionUpdateColumn!]! = []
  where: ActionBoolExp
}

# Ordering options when selecting data from "action".
input ActionOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventJoin: EventJoinOrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedBy: UserOrderBy
  pointsProcessedById: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: action
input ActionPkColumnsInput {
  id: bigint!
}

# select columns of table "action"
enum ActionSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  points

  # column name
  pointsProcessedAt

  # column name
  pointsProcessedById

  # column name
  projectId

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  userId
}

# input type for updating data in table "action"
input ActionSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# aggregate stddev on columns
type ActionStddevFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddev() on columns of table "action"
input ActionStddevOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type ActionStddevPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevPop() on columns of table "action"
input ActionStddevPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type ActionStddevSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "action"
input ActionStddevSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "action"
input ActionStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActionStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  projectId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# aggregate sum on columns
type ActionSumFields {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  points: smallint
  pointsProcessedById: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by sum() on columns of table "action"
input ActionSumOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# update columns of table "action"
enum ActionUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  points

  # column name
  pointsProcessedAt

  # column name
  pointsProcessedById

  # column name
  projectId

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  userId
}

input ActionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActionIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActionSetInput

  # filter the rows which have to be updated
  where: ActionBoolExp!
}

# aggregate variance on columns
type ActionVarianceFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by variance() on columns of table "action"
input ActionVarianceOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type ActionVarPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by varPop() on columns of table "action"
input ActionVarPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type ActionVarSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  points: Float
  pointsProcessedById: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by varSamp() on columns of table "action"
input ActionVarSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# columns and relationships of "actor"
type Actor {
  # An array relationship
  actorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  actorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): ActorTagAggregate!
  avatar: String

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!
  banner: String
  bio: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  email: String

  # An array relationship
  followers(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followersAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!
  ical: String!
  id: bigint!

  # An object relationship
  legalUnit: LegalUnit

  # An object relationship
  legalUnitLocation: LegalUnitLocation

  # An array relationship
  locations(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # An aggregate relationship
  locationsAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!
  name: String!

  # An array relationship
  payedTransactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  payedTransactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  receivedTransactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  receivedTransactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  socials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  socialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!
  status: String!

  # An object relationship
  team: Team

  # An object relationship
  tenant: Tenant

  # An object relationship
  tenantScope: Tenant
  tenantScopeId: bigint

  # An object relationship
  user: User
  website: String
}

# aggregated selection of "actor"
type ActorAggregate {
  aggregate: ActorAggregateFields
  nodes: [Actor!]!
}

input ActorAggregateBoolExp {
  count: actorAggregateBoolExpCount
}

input actorAggregateBoolExpCount {
  arguments: [ActorSelectColumn!]
  distinct: Boolean
  filter: ActorBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor"
type ActorAggregateFields {
  avg: ActorAvgFields
  count(columns: [ActorSelectColumn!], distinct: Boolean): Int!
  max: ActorMaxFields
  min: ActorMinFields
  stddev: ActorStddevFields
  stddevPop: ActorStddevPopFields
  stddevSamp: ActorStddevSampFields
  sum: ActorSumFields
  varPop: ActorVarPopFields
  varSamp: ActorVarSampFields
  variance: ActorVarianceFields
}

# order by aggregate values of table "actor"
input ActorAggregateOrderBy {
  avg: ActorAvgOrderBy
  count: OrderBy
  max: ActorMaxOrderBy
  min: ActorMinOrderBy
  stddev: ActorStddevOrderBy
  stddevPop: ActorStddevPopOrderBy
  stddevSamp: ActorStddevSampOrderBy
  sum: ActorSumOrderBy
  varPop: ActorVarPopOrderBy
  varSamp: ActorVarSampOrderBy
  variance: ActorVarianceOrderBy
}

# input type for inserting array relation for remote table "actor"
input ActorArrRelInsertInput {
  data: [ActorInsertInput!]!

  # upsert condition
  onConflict: ActorOnConflict
}

# aggregate avg on columns
type ActorAvgFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "actor"
input ActorAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "actor". All fields are combined with a logical 'AND'.
input ActorBoolExp {
  _and: [ActorBoolExp!]
  _not: ActorBoolExp
  _or: [ActorBoolExp!]
  actorImages: ActorImageBoolExp
  actorImagesAggregate: ActorImageAggregateBoolExp
  actorTags: ActorTagBoolExp
  actorTagsAggregate: ActorTagAggregateBoolExp
  avatar: StringComparisonExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  banner: StringComparisonExp
  bio: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  email: StringComparisonExp
  followers: FollowBoolExp
  followersAggregate: FollowAggregateBoolExp
  ical: StringComparisonExp
  id: BigintComparisonExp
  legalUnit: LegalUnitBoolExp
  legalUnitLocation: LegalUnitLocationBoolExp
  locations: LocationBoolExp
  locationsAggregate: LocationAggregateBoolExp
  name: StringComparisonExp
  payedTransactions: TransactionBoolExp
  payedTransactionsAggregate: TransactionAggregateBoolExp
  receivedTransactions: TransactionBoolExp
  receivedTransactionsAggregate: TransactionAggregateBoolExp
  socials: SocialBoolExp
  socialsAggregate: SocialAggregateBoolExp
  status: StringComparisonExp
  team: TeamBoolExp
  tenant: TenantBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
  website: StringComparisonExp
}

# unique or primary key constraints on table "actor"
enum ActorConstraint {
  # unique or primary key constraint on columns "ical"
  actor_ical_unique

  # unique or primary key constraint on columns "id"
  actor_pkey
}

# columns and relationships of "actor_image"
type ActorImage {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  image: FileUpload!
  imageId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!
}

# aggregated selection of "actor_image"
type ActorImageAggregate {
  aggregate: ActorImageAggregateFields
  nodes: [ActorImage!]!
}

input ActorImageAggregateBoolExp {
  count: actorImageAggregateBoolExpCount
}

input actorImageAggregateBoolExpCount {
  arguments: [ActorImageSelectColumn!]
  distinct: Boolean
  filter: ActorImageBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor_image"
type ActorImageAggregateFields {
  avg: ActorImageAvgFields
  count(columns: [ActorImageSelectColumn!], distinct: Boolean): Int!
  max: ActorImageMaxFields
  min: ActorImageMinFields
  stddev: ActorImageStddevFields
  stddevPop: ActorImageStddevPopFields
  stddevSamp: ActorImageStddevSampFields
  sum: ActorImageSumFields
  varPop: ActorImageVarPopFields
  varSamp: ActorImageVarSampFields
  variance: ActorImageVarianceFields
}

# order by aggregate values of table "actor_image"
input ActorImageAggregateOrderBy {
  avg: ActorImageAvgOrderBy
  count: OrderBy
  max: ActorImageMaxOrderBy
  min: ActorImageMinOrderBy
  stddev: ActorImageStddevOrderBy
  stddevPop: ActorImageStddevPopOrderBy
  stddevSamp: ActorImageStddevSampOrderBy
  sum: ActorImageSumOrderBy
  varPop: ActorImageVarPopOrderBy
  varSamp: ActorImageVarSampOrderBy
  variance: ActorImageVarianceOrderBy
}

# input type for inserting array relation for remote table "actor_image"
input ActorImageArrRelInsertInput {
  data: [ActorImageInsertInput!]!

  # upsert condition
  onConflict: ActorImageOnConflict
}

# aggregate avg on columns
type ActorImageAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "actor_image"
input ActorImageAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "actor_image". All fields are combined with a logical 'AND'.
input ActorImageBoolExp {
  _and: [ActorImageBoolExp!]
  _not: ActorImageBoolExp
  _or: [ActorImageBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  image: FileUploadBoolExp
  imageId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "actor_image"
enum ActorImageConstraint {
  # unique or primary key constraint on columns "image_id"
  actor_image_image_id_unique

  # unique or primary key constraint on columns "id"
  actor_image_pkey
}

# input type for incrementing numeric columns in table "actor_image"
input ActorImageIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "actor_image"
input ActorImageInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  image: FileUploadObjRelInsertInput
  imageId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
}

# aggregate max on columns
type ActorImageMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "actor_image"
input ActorImageMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ActorImageMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "actor_image"
input ActorImageMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "actor_image"
type ActorImageMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ActorImage!]!
}

# input type for inserting object relation for remote table "actor_image"
input ActorImageObjRelInsertInput {
  data: ActorImageInsertInput!

  # upsert condition
  onConflict: ActorImageOnConflict
}

# on_conflict condition type for table "actor_image"
input ActorImageOnConflict {
  constraint: ActorImageConstraint!
  updateColumns: [ActorImageUpdateColumn!]! = []
  where: ActorImageBoolExp
}

# Ordering options when selecting data from "actor_image".
input ActorImageOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  image: FileUploadOrderBy
  imageId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# primary key columns input for table: actor_image
input ActorImagePkColumnsInput {
  id: bigint!
}

# select columns of table "actor_image"
enum ActorImageSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "actor_image"
input ActorImageSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type ActorImageStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "actor_image"
input ActorImageStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type ActorImageStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "actor_image"
input ActorImageStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type ActorImageStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "actor_image"
input ActorImageStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "actor_image"
input ActorImageStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorImageStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorImageStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type ActorImageSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "actor_image"
input ActorImageSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "actor_image"
enum ActorImageUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  tenantScopeId

  # column name
  type
}

input ActorImageUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorImageIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorImageSetInput

  # filter the rows which have to be updated
  where: ActorImageBoolExp!
}

# aggregate variance on columns
type ActorImageVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "actor_image"
input ActorImageVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type ActorImageVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "actor_image"
input ActorImageVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type ActorImageVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "actor_image"
input ActorImageVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# input type for incrementing numeric columns in table "actor"
input ActorIncInput {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "actor"
input ActorInsertInput {
  actorImages: ActorImageArrRelInsertInput
  actorTags: ActorTagArrRelInsertInput
  avatar: String
  bankInfos: BankInfoArrRelInsertInput
  banner: String
  bio: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  email: String
  followers: FollowArrRelInsertInput
  ical: String
  id: bigint
  legalUnit: LegalUnitObjRelInsertInput
  legalUnitLocation: LegalUnitLocationObjRelInsertInput
  locations: LocationArrRelInsertInput
  name: String
  payedTransactions: TransactionArrRelInsertInput
  receivedTransactions: TransactionArrRelInsertInput
  socials: SocialArrRelInsertInput
  status: String
  team: TeamObjRelInsertInput
  tenant: TenantObjRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
  website: String
}

# aggregate max on columns
type ActorMaxFields {
  avatar: String
  banner: String
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  ical: String
  id: bigint
  name: String
  status: String
  tenantScopeId: bigint
  website: String
}

# order by max() on columns of table "actor"
input ActorMaxOrderBy {
  avatar: OrderBy
  banner: OrderBy
  bio: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  ical: OrderBy
  id: OrderBy
  name: OrderBy
  status: OrderBy
  tenantScopeId: OrderBy
  website: OrderBy
}

# aggregate min on columns
type ActorMinFields {
  avatar: String
  banner: String
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  ical: String
  id: bigint
  name: String
  status: String
  tenantScopeId: bigint
  website: String
}

# order by min() on columns of table "actor"
input ActorMinOrderBy {
  avatar: OrderBy
  banner: OrderBy
  bio: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  ical: OrderBy
  id: OrderBy
  name: OrderBy
  status: OrderBy
  tenantScopeId: OrderBy
  website: OrderBy
}

# response of any mutation on the table "actor"
type ActorMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Actor!]!
}

# input type for inserting object relation for remote table "actor"
input ActorObjRelInsertInput {
  data: ActorInsertInput!

  # upsert condition
  onConflict: ActorOnConflict
}

# on_conflict condition type for table "actor"
input ActorOnConflict {
  constraint: ActorConstraint!
  updateColumns: [ActorUpdateColumn!]! = []
  where: ActorBoolExp
}

# Ordering options when selecting data from "actor".
input ActorOrderBy {
  actorImagesAggregate: ActorImageAggregateOrderBy
  actorTagsAggregate: ActorTagAggregateOrderBy
  avatar: OrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  banner: OrderBy
  bio: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  email: OrderBy
  followersAggregate: FollowAggregateOrderBy
  ical: OrderBy
  id: OrderBy
  legalUnit: LegalUnitOrderBy
  legalUnitLocation: LegalUnitLocationOrderBy
  locationsAggregate: LocationAggregateOrderBy
  name: OrderBy
  payedTransactionsAggregate: TransactionAggregateOrderBy
  receivedTransactionsAggregate: TransactionAggregateOrderBy
  socialsAggregate: SocialAggregateOrderBy
  status: OrderBy
  team: TeamOrderBy
  tenant: TenantOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
  website: OrderBy
}

# primary key columns input for table: actor
input ActorPkColumnsInput {
  id: bigint!
}

# select columns of table "actor"
enum ActorSelectColumn {
  # column name
  avatar

  # column name
  banner

  # column name
  bio

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  email

  # column name
  ical

  # column name
  id

  # column name
  name

  # column name
  status

  # column name
  tenantScopeId

  # column name
  website
}

# input type for updating data in table "actor"
input ActorSetInput {
  avatar: String
  banner: String
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  ical: String
  id: bigint
  name: String
  status: String
  tenantScopeId: bigint
  website: String
}

# aggregate stddev on columns
type ActorStddevFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "actor"
input ActorStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type ActorStddevPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "actor"
input ActorStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type ActorStddevSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "actor"
input ActorStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "actor"
input ActorStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorStreamCursorValueInput {
  avatar: String
  banner: String
  bio: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  email: String
  ical: String
  id: bigint
  name: String
  status: String
  tenantScopeId: bigint
  website: String
}

# aggregate sum on columns
type ActorSumFields {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "actor"
input ActorSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "actor_tag"
type ActorTag {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tag: Tag!
  tagId: bigint!

  # An object relationship
  tenant: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "actor_tag"
type ActorTagAggregate {
  aggregate: ActorTagAggregateFields
  nodes: [ActorTag!]!
}

input ActorTagAggregateBoolExp {
  count: actorTagAggregateBoolExpCount
}

input actorTagAggregateBoolExpCount {
  arguments: [ActorTagSelectColumn!]
  distinct: Boolean
  filter: ActorTagBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "actor_tag"
type ActorTagAggregateFields {
  avg: ActorTagAvgFields
  count(columns: [ActorTagSelectColumn!], distinct: Boolean): Int!
  max: ActorTagMaxFields
  min: ActorTagMinFields
  stddev: ActorTagStddevFields
  stddevPop: ActorTagStddevPopFields
  stddevSamp: ActorTagStddevSampFields
  sum: ActorTagSumFields
  varPop: ActorTagVarPopFields
  varSamp: ActorTagVarSampFields
  variance: ActorTagVarianceFields
}

# order by aggregate values of table "actor_tag"
input ActorTagAggregateOrderBy {
  avg: ActorTagAvgOrderBy
  count: OrderBy
  max: ActorTagMaxOrderBy
  min: ActorTagMinOrderBy
  stddev: ActorTagStddevOrderBy
  stddevPop: ActorTagStddevPopOrderBy
  stddevSamp: ActorTagStddevSampOrderBy
  sum: ActorTagSumOrderBy
  varPop: ActorTagVarPopOrderBy
  varSamp: ActorTagVarSampOrderBy
  variance: ActorTagVarianceOrderBy
}

# input type for inserting array relation for remote table "actor_tag"
input ActorTagArrRelInsertInput {
  data: [ActorTagInsertInput!]!

  # upsert condition
  onConflict: ActorTagOnConflict
}

# aggregate avg on columns
type ActorTagAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "actor_tag"
input ActorTagAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "actor_tag". All fields are combined with a logical 'AND'.
input ActorTagBoolExp {
  _and: [ActorTagBoolExp!]
  _not: ActorTagBoolExp
  _or: [ActorTagBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tag: TagBoolExp
  tagId: BigintComparisonExp
  tenant: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "actor_tag"
enum ActorTagConstraint {
  # unique or primary key constraint on columns "id"
  actor_tag_pkey

  # unique or primary key constraint on columns "tag_id"
  actor_tag_tag_id_unique
}

# input type for incrementing numeric columns in table "actor_tag"
input ActorTagIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "actor_tag"
input ActorTagInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tag: TagObjRelInsertInput
  tagId: bigint
  tenant: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type ActorTagMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "actor_tag"
input ActorTagMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type ActorTagMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "actor_tag"
input ActorTagMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "actor_tag"
type ActorTagMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ActorTag!]!
}

# input type for inserting object relation for remote table "actor_tag"
input ActorTagObjRelInsertInput {
  data: ActorTagInsertInput!

  # upsert condition
  onConflict: ActorTagOnConflict
}

# on_conflict condition type for table "actor_tag"
input ActorTagOnConflict {
  constraint: ActorTagConstraint!
  updateColumns: [ActorTagUpdateColumn!]! = []
  where: ActorTagBoolExp
}

# Ordering options when selecting data from "actor_tag".
input ActorTagOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tag: TagOrderBy
  tagId: OrderBy
  tenant: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: actor_tag
input ActorTagPkColumnsInput {
  id: bigint!
}

# select columns of table "actor_tag"
enum ActorTagSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tagId

  # column name
  tenantScopeId
}

# input type for updating data in table "actor_tag"
input ActorTagSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type ActorTagStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "actor_tag"
input ActorTagStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type ActorTagStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "actor_tag"
input ActorTagStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type ActorTagStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "actor_tag"
input ActorTagStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "actor_tag"
input ActorTagStreamCursorInput {
  # Stream column input with initial value
  initialValue: ActorTagStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ActorTagStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type ActorTagSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  tagId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "actor_tag"
input ActorTagSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "actor_tag"
enum ActorTagUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tagId

  # column name
  tenantScopeId
}

input ActorTagUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorTagIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorTagSetInput

  # filter the rows which have to be updated
  where: ActorTagBoolExp!
}

# aggregate variance on columns
type ActorTagVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "actor_tag"
input ActorTagVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type ActorTagVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "actor_tag"
input ActorTagVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type ActorTagVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  tagId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "actor_tag"
input ActorTagVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tagId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "actor"
enum ActorUpdateColumn {
  # column name
  avatar

  # column name
  banner

  # column name
  bio

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  email

  # column name
  ical

  # column name
  id

  # column name
  name

  # column name
  status

  # column name
  tenantScopeId

  # column name
  website
}

input ActorUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ActorIncInput

  # sets the columns of the filtered rows to the given values
  _set: ActorSetInput

  # filter the rows which have to be updated
  where: ActorBoolExp!
}

# aggregate variance on columns
type ActorVarianceFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "actor"
input ActorVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type ActorVarPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "actor"
input ActorVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type ActorVarSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "actor"
input ActorVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "address"
type Address {
  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!
  category: String!
  city: String!
  country: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint!
  latitude: Float

  # An array relationship
  locations(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # An aggregate relationship
  locationsAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!
  longitude: Float
  name: String!
  state: String!
  street: String!
  streetNumber: String!
  zip: String!
}

# aggregated selection of "address"
type AddressAggregate {
  aggregate: AddressAggregateFields
  nodes: [Address!]!
}

input AddressAggregateBoolExp {
  count: addressAggregateBoolExpCount
}

input addressAggregateBoolExpCount {
  arguments: [AddressSelectColumn!]
  distinct: Boolean
  filter: AddressBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "address"
type AddressAggregateFields {
  avg: AddressAvgFields
  count(columns: [AddressSelectColumn!], distinct: Boolean): Int!
  max: AddressMaxFields
  min: AddressMinFields
  stddev: AddressStddevFields
  stddevPop: AddressStddevPopFields
  stddevSamp: AddressStddevSampFields
  sum: AddressSumFields
  varPop: AddressVarPopFields
  varSamp: AddressVarSampFields
  variance: AddressVarianceFields
}

# order by aggregate values of table "address"
input AddressAggregateOrderBy {
  avg: AddressAvgOrderBy
  count: OrderBy
  max: AddressMaxOrderBy
  min: AddressMinOrderBy
  stddev: AddressStddevOrderBy
  stddevPop: AddressStddevPopOrderBy
  stddevSamp: AddressStddevSampOrderBy
  sum: AddressSumOrderBy
  varPop: AddressVarPopOrderBy
  varSamp: AddressVarSampOrderBy
  variance: AddressVarianceOrderBy
}

# input type for inserting array relation for remote table "address"
input AddressArrRelInsertInput {
  data: [AddressInsertInput!]!

  # upsert condition
  onConflict: AddressOnConflict
}

# aggregate avg on columns
type AddressAvgFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by avg() on columns of table "address"
input AddressAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# Boolean expression to filter rows from the table "address". All fields are combined with a logical 'AND'.
input AddressBoolExp {
  _and: [AddressBoolExp!]
  _not: AddressBoolExp
  _or: [AddressBoolExp!]
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  category: StringComparisonExp
  city: StringComparisonExp
  country: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  geoapifyId: StringComparisonExp
  id: BigintComparisonExp
  latitude: FloatComparisonExp
  locations: LocationBoolExp
  locationsAggregate: LocationAggregateBoolExp
  longitude: FloatComparisonExp
  name: StringComparisonExp
  state: StringComparisonExp
  street: StringComparisonExp
  streetNumber: StringComparisonExp
  zip: StringComparisonExp
}

# unique or primary key constraints on table "address"
enum AddressConstraint {
  # unique or primary key constraint on columns "id"
  address_pkey
}

# input type for incrementing numeric columns in table "address"
input AddressIncInput {
  createdById: bigint
  id: bigint
  latitude: Float
  longitude: Float
}

# input type for inserting data into table "address"
input AddressInsertInput {
  bankInfos: BankInfoArrRelInsertInput
  category: String
  city: String
  country: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint
  latitude: Float
  locations: LocationArrRelInsertInput
  longitude: Float
  name: String
  state: String
  street: String
  streetNumber: String
  zip: String
}

# aggregate max on columns
type AddressMaxFields {
  category: String
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  streetNumber: String
  zip: String
}

# order by max() on columns of table "address"
input AddressMaxOrderBy {
  category: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  geoapifyId: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  streetNumber: OrderBy
  zip: OrderBy
}

# aggregate min on columns
type AddressMinFields {
  category: String
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  streetNumber: String
  zip: String
}

# order by min() on columns of table "address"
input AddressMinOrderBy {
  category: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  geoapifyId: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  streetNumber: OrderBy
  zip: OrderBy
}

# response of any mutation on the table "address"
type AddressMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Address!]!
}

# input type for inserting object relation for remote table "address"
input AddressObjRelInsertInput {
  data: AddressInsertInput!

  # upsert condition
  onConflict: AddressOnConflict
}

# on_conflict condition type for table "address"
input AddressOnConflict {
  constraint: AddressConstraint!
  updateColumns: [AddressUpdateColumn!]! = []
  where: AddressBoolExp
}

# Ordering options when selecting data from "address".
input AddressOrderBy {
  bankInfosAggregate: BankInfoAggregateOrderBy
  category: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  geoapifyId: OrderBy
  id: OrderBy
  latitude: OrderBy
  locationsAggregate: LocationAggregateOrderBy
  longitude: OrderBy
  name: OrderBy
  state: OrderBy
  street: OrderBy
  streetNumber: OrderBy
  zip: OrderBy
}

# primary key columns input for table: address
input AddressPkColumnsInput {
  id: bigint!
}

# select columns of table "address"
enum AddressSelectColumn {
  # column name
  category

  # column name
  city

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  geoapifyId

  # column name
  id

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  state

  # column name
  street

  # column name
  streetNumber

  # column name
  zip
}

# input type for updating data in table "address"
input AddressSetInput {
  category: String
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  streetNumber: String
  zip: String
}

# aggregate stddev on columns
type AddressStddevFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by stddev() on columns of table "address"
input AddressStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# aggregate stddevPop on columns
type AddressStddevPopFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by stddevPop() on columns of table "address"
input AddressStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# aggregate stddevSamp on columns
type AddressStddevSampFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by stddevSamp() on columns of table "address"
input AddressStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# Streaming cursor of the table "address"
input AddressStreamCursorInput {
  # Stream column input with initial value
  initialValue: AddressStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input AddressStreamCursorValueInput {
  category: String
  city: String
  country: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  geoapifyId: String
  id: bigint
  latitude: Float
  longitude: Float
  name: String
  state: String
  street: String
  streetNumber: String
  zip: String
}

# aggregate sum on columns
type AddressSumFields {
  createdById: bigint
  id: bigint
  latitude: Float
  longitude: Float
}

# order by sum() on columns of table "address"
input AddressSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# update columns of table "address"
enum AddressUpdateColumn {
  # column name
  category

  # column name
  city

  # column name
  country

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  geoapifyId

  # column name
  id

  # column name
  latitude

  # column name
  longitude

  # column name
  name

  # column name
  state

  # column name
  street

  # column name
  streetNumber

  # column name
  zip
}

input AddressUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: AddressIncInput

  # sets the columns of the filtered rows to the given values
  _set: AddressSetInput

  # filter the rows which have to be updated
  where: AddressBoolExp!
}

# aggregate variance on columns
type AddressVarianceFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by variance() on columns of table "address"
input AddressVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# aggregate varPop on columns
type AddressVarPopFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by varPop() on columns of table "address"
input AddressVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# aggregate varSamp on columns
type AddressVarSampFields {
  createdById: Float
  id: Float
  latitude: Float
  longitude: Float
}

# order by varSamp() on columns of table "address"
input AddressVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
}

# columns and relationships of "bank_account"
type BankAccount {
  # An object relationship
  bankInfo: BankInfo
  bankInfoId: bigint

  # An array relationship
  childrenAccounts(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # An aggregate relationship
  childrenAccountsAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String

  # An object relationship
  parent: BankAccount
  parentId: bigint

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  transactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!
  type: String!

  # An object relationship
  user: User
}

# aggregated selection of "bank_account"
type BankAccountAggregate {
  aggregate: BankAccountAggregateFields
  nodes: [BankAccount!]!
}

input BankAccountAggregateBoolExp {
  count: bankAccountAggregateBoolExpCount
}

input bankAccountAggregateBoolExpCount {
  arguments: [BankAccountSelectColumn!]
  distinct: Boolean
  filter: BankAccountBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "bank_account"
type BankAccountAggregateFields {
  avg: BankAccountAvgFields
  count(columns: [BankAccountSelectColumn!], distinct: Boolean): Int!
  max: BankAccountMaxFields
  min: BankAccountMinFields
  stddev: BankAccountStddevFields
  stddevPop: BankAccountStddevPopFields
  stddevSamp: BankAccountStddevSampFields
  sum: BankAccountSumFields
  varPop: BankAccountVarPopFields
  varSamp: BankAccountVarSampFields
  variance: BankAccountVarianceFields
}

# order by aggregate values of table "bank_account"
input BankAccountAggregateOrderBy {
  avg: BankAccountAvgOrderBy
  count: OrderBy
  max: BankAccountMaxOrderBy
  min: BankAccountMinOrderBy
  stddev: BankAccountStddevOrderBy
  stddevPop: BankAccountStddevPopOrderBy
  stddevSamp: BankAccountStddevSampOrderBy
  sum: BankAccountSumOrderBy
  varPop: BankAccountVarPopOrderBy
  varSamp: BankAccountVarSampOrderBy
  variance: BankAccountVarianceOrderBy
}

# input type for inserting array relation for remote table "bank_account"
input BankAccountArrRelInsertInput {
  data: [BankAccountInsertInput!]!

  # upsert condition
  onConflict: BankAccountOnConflict
}

# aggregate avg on columns
type BankAccountAvgFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "bank_account"
input BankAccountAvgOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "bank_account". All fields are combined with a logical 'AND'.
input BankAccountBoolExp {
  _and: [BankAccountBoolExp!]
  _not: BankAccountBoolExp
  _or: [BankAccountBoolExp!]
  bankInfo: BankInfoBoolExp
  bankInfoId: BigintComparisonExp
  childrenAccounts: BankAccountBoolExp
  childrenAccountsAggregate: BankAccountAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  parent: BankAccountBoolExp
  parentId: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactions: TransactionBoolExp
  transactionsAggregate: TransactionAggregateBoolExp
  type: StringComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "bank_account"
enum BankAccountConstraint {
  # unique or primary key constraint on columns "id"
  bank_account_pkey
}

# input type for incrementing numeric columns in table "bank_account"
input BankAccountIncInput {
  bankInfoId: bigint
  createdById: bigint
  id: bigint
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "bank_account"
input BankAccountInsertInput {
  bankInfo: BankInfoObjRelInsertInput
  bankInfoId: bigint
  childrenAccounts: BankAccountArrRelInsertInput
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  parent: BankAccountObjRelInsertInput
  parentId: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactions: TransactionArrRelInsertInput
  type: String
  user: UserObjRelInsertInput
}

# aggregate max on columns
type BankAccountMaxFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "bank_account"
input BankAccountMaxOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type BankAccountMinFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "bank_account"
input BankAccountMinOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "bank_account"
type BankAccountMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [BankAccount!]!
}

# input type for inserting object relation for remote table "bank_account"
input BankAccountObjRelInsertInput {
  data: BankAccountInsertInput!

  # upsert condition
  onConflict: BankAccountOnConflict
}

# on_conflict condition type for table "bank_account"
input BankAccountOnConflict {
  constraint: BankAccountConstraint!
  updateColumns: [BankAccountUpdateColumn!]! = []
  where: BankAccountBoolExp
}

# Ordering options when selecting data from "bank_account".
input BankAccountOrderBy {
  bankInfo: BankInfoOrderBy
  bankInfoId: OrderBy
  childrenAccountsAggregate: BankAccountAggregateOrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  parent: BankAccountOrderBy
  parentId: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionsAggregate: TransactionAggregateOrderBy
  type: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: bank_account
input BankAccountPkColumnsInput {
  id: bigint!
}

# select columns of table "bank_account"
enum BankAccountSelectColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  parentId

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "bank_account"
input BankAccountSetInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type BankAccountStddevFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "bank_account"
input BankAccountStddevOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type BankAccountStddevPopFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "bank_account"
input BankAccountStddevPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type BankAccountStddevSampFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "bank_account"
input BankAccountStddevSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "bank_account"
input BankAccountStreamCursorInput {
  # Stream column input with initial value
  initialValue: BankAccountStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input BankAccountStreamCursorValueInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type BankAccountSumFields {
  bankInfoId: bigint
  createdById: bigint
  id: bigint
  parentId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "bank_account"
input BankAccountSumOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "bank_account"
enum BankAccountUpdateColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  parentId

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

input BankAccountUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: BankAccountIncInput

  # sets the columns of the filtered rows to the given values
  _set: BankAccountSetInput

  # filter the rows which have to be updated
  where: BankAccountBoolExp!
}

# aggregate variance on columns
type BankAccountVarianceFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "bank_account"
input BankAccountVarianceOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type BankAccountVarPopFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "bank_account"
input BankAccountVarPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type BankAccountVarSampFields {
  bankInfoId: Float
  createdById: Float
  id: Float
  parentId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "bank_account"
input BankAccountVarSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "bank_info"
type BankInfo {
  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An object relationship
  bank: LegalUnit!

  # An array relationship
  bankAccounts(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # An aggregate relationship
  bankAccountsAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!
  bankId: bigint!
  bicSwift: String!

  # An object relationship
  branchAddress: Address!
  branchAddressId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!
  hiddenAt: timestamptz
  holderName: String!
  iban: String!
  id: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "bank_info"
type BankInfoAggregate {
  aggregate: BankInfoAggregateFields
  nodes: [BankInfo!]!
}

input BankInfoAggregateBoolExp {
  count: bankInfoAggregateBoolExpCount
}

input bankInfoAggregateBoolExpCount {
  arguments: [BankInfoSelectColumn!]
  distinct: Boolean
  filter: BankInfoBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "bank_info"
type BankInfoAggregateFields {
  avg: BankInfoAvgFields
  count(columns: [BankInfoSelectColumn!], distinct: Boolean): Int!
  max: BankInfoMaxFields
  min: BankInfoMinFields
  stddev: BankInfoStddevFields
  stddevPop: BankInfoStddevPopFields
  stddevSamp: BankInfoStddevSampFields
  sum: BankInfoSumFields
  varPop: BankInfoVarPopFields
  varSamp: BankInfoVarSampFields
  variance: BankInfoVarianceFields
}

# order by aggregate values of table "bank_info"
input BankInfoAggregateOrderBy {
  avg: BankInfoAvgOrderBy
  count: OrderBy
  max: BankInfoMaxOrderBy
  min: BankInfoMinOrderBy
  stddev: BankInfoStddevOrderBy
  stddevPop: BankInfoStddevPopOrderBy
  stddevSamp: BankInfoStddevSampOrderBy
  sum: BankInfoSumOrderBy
  varPop: BankInfoVarPopOrderBy
  varSamp: BankInfoVarSampOrderBy
  variance: BankInfoVarianceOrderBy
}

# input type for inserting array relation for remote table "bank_info"
input BankInfoArrRelInsertInput {
  data: [BankInfoInsertInput!]!

  # upsert condition
  onConflict: BankInfoOnConflict
}

# aggregate avg on columns
type BankInfoAvgFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "bank_info"
input BankInfoAvgOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "bank_info". All fields are combined with a logical 'AND'.
input BankInfoBoolExp {
  _and: [BankInfoBoolExp!]
  _not: BankInfoBoolExp
  _or: [BankInfoBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  bank: LegalUnitBoolExp
  bankAccounts: BankAccountBoolExp
  bankAccountsAggregate: BankAccountAggregateBoolExp
  bankId: BigintComparisonExp
  bicSwift: StringComparisonExp
  branchAddress: AddressBoolExp
  branchAddressId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  holderName: StringComparisonExp
  iban: StringComparisonExp
  id: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "bank_info"
enum BankInfoConstraint {
  # unique or primary key constraint on columns "id"
  bank_info_pkey
}

# input type for incrementing numeric columns in table "bank_info"
input BankInfoIncInput {
  actorId: bigint
  bankId: bigint
  branchAddressId: bigint
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "bank_info"
input BankInfoInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  bank: LegalUnitObjRelInsertInput
  bankAccounts: BankAccountArrRelInsertInput
  bankId: bigint
  bicSwift: String
  branchAddress: AddressObjRelInsertInput
  branchAddressId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  expenses: ExpenseArrRelInsertInput
  hiddenAt: timestamptz
  holderName: String
  iban: String
  id: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type BankInfoMaxFields {
  actorId: bigint
  bankId: bigint
  bicSwift: String
  branchAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  holderName: String
  iban: String
  id: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "bank_info"
input BankInfoMaxOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  bicSwift: OrderBy
  branchAddressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  iban: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type BankInfoMinFields {
  actorId: bigint
  bankId: bigint
  bicSwift: String
  branchAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  holderName: String
  iban: String
  id: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "bank_info"
input BankInfoMinOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  bicSwift: OrderBy
  branchAddressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  iban: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "bank_info"
type BankInfoMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [BankInfo!]!
}

# input type for inserting object relation for remote table "bank_info"
input BankInfoObjRelInsertInput {
  data: BankInfoInsertInput!

  # upsert condition
  onConflict: BankInfoOnConflict
}

# on_conflict condition type for table "bank_info"
input BankInfoOnConflict {
  constraint: BankInfoConstraint!
  updateColumns: [BankInfoUpdateColumn!]! = []
  where: BankInfoBoolExp
}

# Ordering options when selecting data from "bank_info".
input BankInfoOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  bank: LegalUnitOrderBy
  bankAccountsAggregate: BankAccountAggregateOrderBy
  bankId: OrderBy
  bicSwift: OrderBy
  branchAddress: AddressOrderBy
  branchAddressId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  hiddenAt: OrderBy
  holderName: OrderBy
  iban: OrderBy
  id: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: bank_info
input BankInfoPkColumnsInput {
  id: bigint!
}

# select columns of table "bank_info"
enum BankInfoSelectColumn {
  # column name
  actorId

  # column name
  bankId

  # column name
  bicSwift

  # column name
  branchAddressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  holderName

  # column name
  iban

  # column name
  id

  # column name
  tenantScopeId
}

# input type for updating data in table "bank_info"
input BankInfoSetInput {
  actorId: bigint
  bankId: bigint
  bicSwift: String
  branchAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  holderName: String
  iban: String
  id: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type BankInfoStddevFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "bank_info"
input BankInfoStddevOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type BankInfoStddevPopFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "bank_info"
input BankInfoStddevPopOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type BankInfoStddevSampFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "bank_info"
input BankInfoStddevSampOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "bank_info"
input BankInfoStreamCursorInput {
  # Stream column input with initial value
  initialValue: BankInfoStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input BankInfoStreamCursorValueInput {
  actorId: bigint
  bankId: bigint
  bicSwift: String
  branchAddressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  holderName: String
  iban: String
  id: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type BankInfoSumFields {
  actorId: bigint
  bankId: bigint
  branchAddressId: bigint
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "bank_info"
input BankInfoSumOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "bank_info"
enum BankInfoUpdateColumn {
  # column name
  actorId

  # column name
  bankId

  # column name
  bicSwift

  # column name
  branchAddressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  holderName

  # column name
  iban

  # column name
  id

  # column name
  tenantScopeId
}

input BankInfoUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: BankInfoIncInput

  # sets the columns of the filtered rows to the given values
  _set: BankInfoSetInput

  # filter the rows which have to be updated
  where: BankInfoBoolExp!
}

# aggregate variance on columns
type BankInfoVarianceFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "bank_info"
input BankInfoVarianceOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type BankInfoVarPopFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "bank_info"
input BankInfoVarPopOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type BankInfoVarSampFields {
  actorId: Float
  bankId: Float
  branchAddressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "bank_info"
input BankInfoVarSampOrderBy {
  actorId: OrderBy
  bankId: OrderBy
  branchAddressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

scalar bigint

# Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

# Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "campus"
type Campus {
  # An object relationship
  campusCluster: CampusCluster!
  campusClusterId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  location: Location!
  locationId: bigint!
  name: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "campus"
type CampusAggregate {
  aggregate: CampusAggregateFields
  nodes: [Campus!]!
}

input CampusAggregateBoolExp {
  count: campusAggregateBoolExpCount
}

input campusAggregateBoolExpCount {
  arguments: [CampusSelectColumn!]
  distinct: Boolean
  filter: CampusBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "campus"
type CampusAggregateFields {
  avg: CampusAvgFields
  count(columns: [CampusSelectColumn!], distinct: Boolean): Int!
  max: CampusMaxFields
  min: CampusMinFields
  stddev: CampusStddevFields
  stddevPop: CampusStddevPopFields
  stddevSamp: CampusStddevSampFields
  sum: CampusSumFields
  varPop: CampusVarPopFields
  varSamp: CampusVarSampFields
  variance: CampusVarianceFields
}

# order by aggregate values of table "campus"
input CampusAggregateOrderBy {
  avg: CampusAvgOrderBy
  count: OrderBy
  max: CampusMaxOrderBy
  min: CampusMinOrderBy
  stddev: CampusStddevOrderBy
  stddevPop: CampusStddevPopOrderBy
  stddevSamp: CampusStddevSampOrderBy
  sum: CampusSumOrderBy
  varPop: CampusVarPopOrderBy
  varSamp: CampusVarSampOrderBy
  variance: CampusVarianceOrderBy
}

# input type for inserting array relation for remote table "campus"
input CampusArrRelInsertInput {
  data: [CampusInsertInput!]!

  # upsert condition
  onConflict: CampusOnConflict
}

# aggregate avg on columns
type CampusAvgFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "campus"
input CampusAvgOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "campus". All fields are combined with a logical 'AND'.
input CampusBoolExp {
  _and: [CampusBoolExp!]
  _not: CampusBoolExp
  _or: [CampusBoolExp!]
  campusCluster: CampusClusterBoolExp
  campusClusterId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  location: LocationBoolExp
  locationId: BigintComparisonExp
  name: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# columns and relationships of "campus_cluster"
type CampusCluster {
  # An array relationship
  campuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  campusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An array relationship
  tenantOrganizes(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # An aggregate relationship
  tenantOrganizesAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "campus_cluster"
type CampusClusterAggregate {
  aggregate: CampusClusterAggregateFields
  nodes: [CampusCluster!]!
}

input CampusClusterAggregateBoolExp {
  count: campusClusterAggregateBoolExpCount
}

input campusClusterAggregateBoolExpCount {
  arguments: [CampusClusterSelectColumn!]
  distinct: Boolean
  filter: CampusClusterBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "campus_cluster"
type CampusClusterAggregateFields {
  avg: CampusClusterAvgFields
  count(columns: [CampusClusterSelectColumn!], distinct: Boolean): Int!
  max: CampusClusterMaxFields
  min: CampusClusterMinFields
  stddev: CampusClusterStddevFields
  stddevPop: CampusClusterStddevPopFields
  stddevSamp: CampusClusterStddevSampFields
  sum: CampusClusterSumFields
  varPop: CampusClusterVarPopFields
  varSamp: CampusClusterVarSampFields
  variance: CampusClusterVarianceFields
}

# order by aggregate values of table "campus_cluster"
input CampusClusterAggregateOrderBy {
  avg: CampusClusterAvgOrderBy
  count: OrderBy
  max: CampusClusterMaxOrderBy
  min: CampusClusterMinOrderBy
  stddev: CampusClusterStddevOrderBy
  stddevPop: CampusClusterStddevPopOrderBy
  stddevSamp: CampusClusterStddevSampOrderBy
  sum: CampusClusterSumOrderBy
  varPop: CampusClusterVarPopOrderBy
  varSamp: CampusClusterVarSampOrderBy
  variance: CampusClusterVarianceOrderBy
}

# input type for inserting array relation for remote table "campus_cluster"
input CampusClusterArrRelInsertInput {
  data: [CampusClusterInsertInput!]!

  # upsert condition
  onConflict: CampusClusterOnConflict
}

# aggregate avg on columns
type CampusClusterAvgFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "campus_cluster"
input CampusClusterAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "campus_cluster". All fields are combined with a logical 'AND'.
input CampusClusterBoolExp {
  _and: [CampusClusterBoolExp!]
  _not: CampusClusterBoolExp
  _or: [CampusClusterBoolExp!]
  campuses: CampusBoolExp
  campusesAggregate: CampusAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  tenantOrganizes: TenantOrganizeBoolExp
  tenantOrganizesAggregate: TenantOrganizeAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "campus_cluster"
enum CampusClusterConstraint {
  # unique or primary key constraint on columns "id"
  campus_cluster_pkey
}

# input type for incrementing numeric columns in table "campus_cluster"
input CampusClusterIncInput {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "campus_cluster"
input CampusClusterInsertInput {
  campuses: CampusArrRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantOrganizes: TenantOrganizeArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type CampusClusterMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
}

# order by max() on columns of table "campus_cluster"
input CampusClusterMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type CampusClusterMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
}

# order by min() on columns of table "campus_cluster"
input CampusClusterMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "campus_cluster"
type CampusClusterMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [CampusCluster!]!
}

# input type for inserting object relation for remote table "campus_cluster"
input CampusClusterObjRelInsertInput {
  data: CampusClusterInsertInput!

  # upsert condition
  onConflict: CampusClusterOnConflict
}

# on_conflict condition type for table "campus_cluster"
input CampusClusterOnConflict {
  constraint: CampusClusterConstraint!
  updateColumns: [CampusClusterUpdateColumn!]! = []
  where: CampusClusterBoolExp
}

# Ordering options when selecting data from "campus_cluster".
input CampusClusterOrderBy {
  campusesAggregate: CampusAggregateOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantOrganizesAggregate: TenantOrganizeAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: campus_cluster
input CampusClusterPkColumnsInput {
  id: bigint!
}

# select columns of table "campus_cluster"
enum CampusClusterSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantScopeId
}

# input type for updating data in table "campus_cluster"
input CampusClusterSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type CampusClusterStddevFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "campus_cluster"
input CampusClusterStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type CampusClusterStddevPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "campus_cluster"
input CampusClusterStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type CampusClusterStddevSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "campus_cluster"
input CampusClusterStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "campus_cluster"
input CampusClusterStreamCursorInput {
  # Stream column input with initial value
  initialValue: CampusClusterStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CampusClusterStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type CampusClusterSumFields {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "campus_cluster"
input CampusClusterSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "campus_cluster"
enum CampusClusterUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  tenantScopeId
}

input CampusClusterUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CampusClusterIncInput

  # sets the columns of the filtered rows to the given values
  _set: CampusClusterSetInput

  # filter the rows which have to be updated
  where: CampusClusterBoolExp!
}

# aggregate variance on columns
type CampusClusterVarianceFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "campus_cluster"
input CampusClusterVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type CampusClusterVarPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "campus_cluster"
input CampusClusterVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type CampusClusterVarSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "campus_cluster"
input CampusClusterVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# unique or primary key constraints on table "campus"
enum CampusConstraint {
  # unique or primary key constraint on columns "id"
  campus_pkey
}

# input type for incrementing numeric columns in table "campus"
input CampusIncInput {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  locationId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "campus"
input CampusInsertInput {
  campusCluster: CampusClusterObjRelInsertInput
  campusClusterId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  location: LocationObjRelInsertInput
  locationId: bigint
  name: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type CampusMaxFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  locationId: bigint
  name: String
  tenantScopeId: bigint
}

# order by max() on columns of table "campus"
input CampusMaxOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  locationId: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type CampusMinFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  locationId: bigint
  name: String
  tenantScopeId: bigint
}

# order by min() on columns of table "campus"
input CampusMinOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  locationId: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "campus"
type CampusMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Campus!]!
}

# on_conflict condition type for table "campus"
input CampusOnConflict {
  constraint: CampusConstraint!
  updateColumns: [CampusUpdateColumn!]! = []
  where: CampusBoolExp
}

# Ordering options when selecting data from "campus".
input CampusOrderBy {
  campusCluster: CampusClusterOrderBy
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  location: LocationOrderBy
  locationId: OrderBy
  name: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: campus
input CampusPkColumnsInput {
  id: bigint!
}

# select columns of table "campus"
enum CampusSelectColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  locationId

  # column name
  name

  # column name
  tenantScopeId
}

# input type for updating data in table "campus"
input CampusSetInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  locationId: bigint
  name: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type CampusStddevFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "campus"
input CampusStddevOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type CampusStddevPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "campus"
input CampusStddevPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type CampusStddevSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "campus"
input CampusStddevSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "campus"
input CampusStreamCursorInput {
  # Stream column input with initial value
  initialValue: CampusStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input CampusStreamCursorValueInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  locationId: bigint
  name: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type CampusSumFields {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  locationId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "campus"
input CampusSumOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "campus"
enum CampusUpdateColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  locationId

  # column name
  name

  # column name
  tenantScopeId
}

input CampusUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: CampusIncInput

  # sets the columns of the filtered rows to the given values
  _set: CampusSetInput

  # filter the rows which have to be updated
  where: CampusBoolExp!
}

# aggregate variance on columns
type CampusVarianceFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "campus"
input CampusVarianceOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type CampusVarPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "campus"
input CampusVarPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type CampusVarSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  locationId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "campus"
input CampusVarSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  locationId: OrderBy
  tenantScopeId: OrderBy
}

# ordering argument of a cursor
enum CursorOrdering {
  # ascending ordering of the cursor
  ASC

  # descending ordering of the cursor
  DESC
}

# columns and relationships of "event"
type Event {
  # An object relationship
  banner: FileUpload
  bannerId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  end: timestamptz!

  # An object relationship
  eventApprovalSubmission: FormSubmission
  eventApprovalSubmissionId: bigint

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  eventFavorites(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # An aggregate relationship
  eventFavoritesAggregate(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): EventFavoriteAggregate!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  eventOrganizes(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # An aggregate relationship
  eventOrganizesAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isAutoAcceptingJoins: Boolean!
  isPrivate: Boolean!
  isTemplate: Boolean!

  # An object relationship
  joinForm: Form
  joinFormId: bigint

  # An object relationship
  location: Location!
  locationId: bigint!
  maxParticipants: smallint
  meta(
    # JSON select path
    path: String
  ): jsonb!
  name: String!

  # An object relationship
  nextEventApprovalStep: EventApprovalStep
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float!
  price: Float!
  slug: String!
  start: timestamptz!
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  transactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!
}

# aggregated selection of "event"
type EventAggregate {
  aggregate: EventAggregateFields
  nodes: [Event!]!
}

input EventAggregateBoolExp {
  bool_and: eventAggregateBoolExpBool_and
  bool_or: eventAggregateBoolExpBool_or
  count: eventAggregateBoolExpCount
}

input eventAggregateBoolExpBool_and {
  arguments: EventSelectColumnEventAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}

input eventAggregateBoolExpBool_or {
  arguments: EventSelectColumnEventAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventBoolExp
  predicate: BooleanComparisonExp!
}

input eventAggregateBoolExpCount {
  arguments: [EventSelectColumn!]
  distinct: Boolean
  filter: EventBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event"
type EventAggregateFields {
  avg: EventAvgFields
  count(columns: [EventSelectColumn!], distinct: Boolean): Int!
  max: EventMaxFields
  min: EventMinFields
  stddev: EventStddevFields
  stddevPop: EventStddevPopFields
  stddevSamp: EventStddevSampFields
  sum: EventSumFields
  varPop: EventVarPopFields
  varSamp: EventVarSampFields
  variance: EventVarianceFields
}

# order by aggregate values of table "event"
input EventAggregateOrderBy {
  avg: EventAvgOrderBy
  count: OrderBy
  max: EventMaxOrderBy
  min: EventMinOrderBy
  stddev: EventStddevOrderBy
  stddevPop: EventStddevPopOrderBy
  stddevSamp: EventStddevSampOrderBy
  sum: EventSumOrderBy
  varPop: EventVarPopOrderBy
  varSamp: EventVarSampOrderBy
  variance: EventVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input EventAppendInput {
  meta: jsonb
}

# columns and relationships of "event_approval"
type EventApproval {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event

  # An object relationship
  eventApprovalStep: EventApprovalStep
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isApproved: Boolean!
  message: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "event_approval"
type EventApprovalAggregate {
  aggregate: EventApprovalAggregateFields
  nodes: [EventApproval!]!
}

input EventApprovalAggregateBoolExp {
  bool_and: eventApprovalAggregateBoolExpBool_and
  bool_or: eventApprovalAggregateBoolExpBool_or
  count: eventApprovalAggregateBoolExpCount
}

input eventApprovalAggregateBoolExpBool_and {
  arguments: EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: BooleanComparisonExp!
}

input eventApprovalAggregateBoolExpBool_or {
  arguments: EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: BooleanComparisonExp!
}

input eventApprovalAggregateBoolExpCount {
  arguments: [EventApprovalSelectColumn!]
  distinct: Boolean
  filter: EventApprovalBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval"
type EventApprovalAggregateFields {
  avg: EventApprovalAvgFields
  count(columns: [EventApprovalSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalMaxFields
  min: EventApprovalMinFields
  stddev: EventApprovalStddevFields
  stddevPop: EventApprovalStddevPopFields
  stddevSamp: EventApprovalStddevSampFields
  sum: EventApprovalSumFields
  varPop: EventApprovalVarPopFields
  varSamp: EventApprovalVarSampFields
  variance: EventApprovalVarianceFields
}

# order by aggregate values of table "event_approval"
input EventApprovalAggregateOrderBy {
  avg: EventApprovalAvgOrderBy
  count: OrderBy
  max: EventApprovalMaxOrderBy
  min: EventApprovalMinOrderBy
  stddev: EventApprovalStddevOrderBy
  stddevPop: EventApprovalStddevPopOrderBy
  stddevSamp: EventApprovalStddevSampOrderBy
  sum: EventApprovalSumOrderBy
  varPop: EventApprovalVarPopOrderBy
  varSamp: EventApprovalVarSampOrderBy
  variance: EventApprovalVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval"
input EventApprovalArrRelInsertInput {
  data: [EventApprovalInsertInput!]!

  # upsert condition
  onConflict: EventApprovalOnConflict
}

# aggregate avg on columns
type EventApprovalAvgFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event_approval"
input EventApprovalAvgOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event_approval". All fields are combined with a logical 'AND'.
input EventApprovalBoolExp {
  _and: [EventApprovalBoolExp!]
  _not: EventApprovalBoolExp
  _or: [EventApprovalBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  eventId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isApproved: BooleanComparisonExp
  message: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval"
enum EventApprovalConstraint {
  # unique or primary key constraint on columns "id"
  event_approval_pkey
}

# input type for incrementing numeric columns in table "event_approval"
input EventApprovalIncInput {
  createdById: bigint
  eventApprovalStepId: bigint
  eventId: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "event_approval"
input EventApprovalInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type EventApprovalMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  message: String
  tenantScopeId: bigint
}

# order by max() on columns of table "event_approval"
input EventApprovalMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  message: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventApprovalMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  message: String
  tenantScopeId: bigint
}

# order by min() on columns of table "event_approval"
input EventApprovalMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  message: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event_approval"
type EventApprovalMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApproval!]!
}

# on_conflict condition type for table "event_approval"
input EventApprovalOnConflict {
  constraint: EventApprovalConstraint!
  updateColumns: [EventApprovalUpdateColumn!]! = []
  where: EventApprovalBoolExp
}

# Ordering options when selecting data from "event_approval".
input EventApprovalOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isApproved: OrderBy
  message: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: event_approval
input EventApprovalPkColumnsInput {
  id: bigint!
}

# select columns of table "event_approval"
enum EventApprovalSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventApprovalStepId

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isApproved

  # column name
  message

  # column name
  tenantScopeId
}

# select "eventApprovalAggregateBoolExpBool_andArgumentsColumns" columns of table "event_approval"
enum EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isApproved
}

# select "eventApprovalAggregateBoolExpBool_orArgumentsColumns" columns of table "event_approval"
enum EventApprovalSelectColumnEventApprovalAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isApproved
}

# input type for updating data in table "event_approval"
input EventApprovalSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventApprovalStddevFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event_approval"
input EventApprovalStddevOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStddevPopFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event_approval"
input EventApprovalStddevPopOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStddevSampFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event_approval"
input EventApprovalStddevSampOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "event_approval_step"
type EventApprovalStep {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An array relationship
  nextStepEvents(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  nextStepEventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  nextSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  nextStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!
  order: Int!

  # An object relationship
  previousStep: EventApprovalStep
  previousStepId: bigint

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "event_approval_step"
type EventApprovalStepAggregate {
  aggregate: EventApprovalStepAggregateFields
  nodes: [EventApprovalStep!]!
}

input EventApprovalStepAggregateBoolExp {
  count: eventApprovalStepAggregateBoolExpCount
}

input eventApprovalStepAggregateBoolExpCount {
  arguments: [EventApprovalStepSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step"
type EventApprovalStepAggregateFields {
  avg: EventApprovalStepAvgFields
  count(columns: [EventApprovalStepSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepMaxFields
  min: EventApprovalStepMinFields
  stddev: EventApprovalStepStddevFields
  stddevPop: EventApprovalStepStddevPopFields
  stddevSamp: EventApprovalStepStddevSampFields
  sum: EventApprovalStepSumFields
  varPop: EventApprovalStepVarPopFields
  varSamp: EventApprovalStepVarSampFields
  variance: EventApprovalStepVarianceFields
}

# order by aggregate values of table "event_approval_step"
input EventApprovalStepAggregateOrderBy {
  avg: EventApprovalStepAvgOrderBy
  count: OrderBy
  max: EventApprovalStepMaxOrderBy
  min: EventApprovalStepMinOrderBy
  stddev: EventApprovalStepStddevOrderBy
  stddevPop: EventApprovalStepStddevPopOrderBy
  stddevSamp: EventApprovalStepStddevSampOrderBy
  sum: EventApprovalStepSumOrderBy
  varPop: EventApprovalStepVarPopOrderBy
  varSamp: EventApprovalStepVarSampOrderBy
  variance: EventApprovalStepVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step"
input EventApprovalStepArrRelInsertInput {
  data: [EventApprovalStepInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepOnConflict
}

# aggregate avg on columns
type EventApprovalStepAvgFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event_approval_step"
input EventApprovalStepAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event_approval_step". All fields are combined with a logical 'AND'.
input EventApprovalStepBoolExp {
  _and: [EventApprovalStepBoolExp!]
  _not: EventApprovalStepBoolExp
  _or: [EventApprovalStepBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventApprovalStepNotifiees: EventApprovalStepNotifieesBoolExp
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateBoolExp
  eventApprovalStepValidators: EventApprovalStepValidatorsBoolExp
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateBoolExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  nextStepEvents: EventBoolExp
  nextStepEventsAggregate: EventAggregateBoolExp
  nextSteps: EventApprovalStepBoolExp
  nextStepsAggregate: EventApprovalStepAggregateBoolExp
  order: IntComparisonExp
  previousStep: EventApprovalStepBoolExp
  previousStepId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step"
enum EventApprovalStepConstraint {
  # unique or primary key constraint on columns "id"
  event_approval_step_pkey
}

# input type for incrementing numeric columns in table "event_approval_step"
input EventApprovalStepIncInput {
  createdById: bigint
  id: bigint
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "event_approval_step"
input EventApprovalStepInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventApprovalStepNotifiees: EventApprovalStepNotifieesArrRelInsertInput
  eventApprovalStepValidators: EventApprovalStepValidatorsArrRelInsertInput
  eventApprovals: EventApprovalArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  name: String
  nextStepEvents: EventArrRelInsertInput
  nextSteps: EventApprovalStepArrRelInsertInput
  order: Int
  previousStep: EventApprovalStepObjRelInsertInput
  previousStepId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type EventApprovalStepMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "event_approval_step"
input EventApprovalStepMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventApprovalStepMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "event_approval_step"
input EventApprovalStepMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event_approval_step"
type EventApprovalStepMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStep!]!
}

# columns and relationships of "event_approval_step_notifiees"
type EventApprovalStepNotifiees {
  # An object relationship
  eventApprovalStep: EventApprovalStep!
  eventApprovalStepId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "event_approval_step_notifiees"
type EventApprovalStepNotifieesAggregate {
  aggregate: EventApprovalStepNotifieesAggregateFields
  nodes: [EventApprovalStepNotifiees!]!
}

input EventApprovalStepNotifieesAggregateBoolExp {
  count: eventApprovalStepNotifieesAggregateBoolExpCount
}

input eventApprovalStepNotifieesAggregateBoolExpCount {
  arguments: [EventApprovalStepNotifieesSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepNotifieesBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step_notifiees"
type EventApprovalStepNotifieesAggregateFields {
  avg: EventApprovalStepNotifieesAvgFields
  count(columns: [EventApprovalStepNotifieesSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepNotifieesMaxFields
  min: EventApprovalStepNotifieesMinFields
  stddev: EventApprovalStepNotifieesStddevFields
  stddevPop: EventApprovalStepNotifieesStddevPopFields
  stddevSamp: EventApprovalStepNotifieesStddevSampFields
  sum: EventApprovalStepNotifieesSumFields
  varPop: EventApprovalStepNotifieesVarPopFields
  varSamp: EventApprovalStepNotifieesVarSampFields
  variance: EventApprovalStepNotifieesVarianceFields
}

# order by aggregate values of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesAggregateOrderBy {
  avg: EventApprovalStepNotifieesAvgOrderBy
  count: OrderBy
  max: EventApprovalStepNotifieesMaxOrderBy
  min: EventApprovalStepNotifieesMinOrderBy
  stddev: EventApprovalStepNotifieesStddevOrderBy
  stddevPop: EventApprovalStepNotifieesStddevPopOrderBy
  stddevSamp: EventApprovalStepNotifieesStddevSampOrderBy
  sum: EventApprovalStepNotifieesSumOrderBy
  varPop: EventApprovalStepNotifieesVarPopOrderBy
  varSamp: EventApprovalStepNotifieesVarSampOrderBy
  variance: EventApprovalStepNotifieesVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step_notifiees"
input EventApprovalStepNotifieesArrRelInsertInput {
  data: [EventApprovalStepNotifieesInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepNotifieesOnConflict
}

# aggregate avg on columns
type EventApprovalStepNotifieesAvgFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by avg() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesAvgOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table
# "event_approval_step_notifiees". All fields are combined with a logical 'AND'.
input EventApprovalStepNotifieesBoolExp {
  _and: [EventApprovalStepNotifieesBoolExp!]
  _not: EventApprovalStepNotifieesBoolExp
  _or: [EventApprovalStepNotifieesBoolExp!]
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesConstraint {
  # unique or primary key constraint on columns "user_id", "event_approval_step_id"
  event_approval_step_notifiees_pkey
}

# input type for incrementing numeric columns in table "event_approval_step_notifiees"
input EventApprovalStepNotifieesIncInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# input type for inserting data into table "event_approval_step_notifiees"
input EventApprovalStepNotifieesInsertInput {
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type EventApprovalStepNotifieesMaxFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by max() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesMaxOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type EventApprovalStepNotifieesMinFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by min() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesMinOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "event_approval_step_notifiees"
type EventApprovalStepNotifieesMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStepNotifiees!]!
}

# on_conflict condition type for table "event_approval_step_notifiees"
input EventApprovalStepNotifieesOnConflict {
  constraint: EventApprovalStepNotifieesConstraint!
  updateColumns: [EventApprovalStepNotifieesUpdateColumn!]! = []
  where: EventApprovalStepNotifieesBoolExp
}

# Ordering options when selecting data from "event_approval_step_notifiees".
input EventApprovalStepNotifieesOrderBy {
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: event_approval_step_notifiees
input EventApprovalStepNotifieesPkColumnsInput {
  eventApprovalStepId: bigint!
  userId: bigint!
}

# select columns of table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesSelectColumn {
  # column name
  eventApprovalStepId

  # column name
  userId
}

# input type for updating data in table "event_approval_step_notifiees"
input EventApprovalStepNotifieesSetInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# aggregate stddev on columns
type EventApprovalStepNotifieesStddevFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddev() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepNotifieesStddevPopFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddevPop() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevPopOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepNotifieesStddevSampFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStddevSampOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "event_approval_step_notifiees"
input EventApprovalStepNotifieesStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepNotifieesStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepNotifieesStreamCursorValueInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# aggregate sum on columns
type EventApprovalStepNotifieesSumFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by sum() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesSumOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# update columns of table "event_approval_step_notifiees"
enum EventApprovalStepNotifieesUpdateColumn {
  # column name
  eventApprovalStepId

  # column name
  userId
}

input EventApprovalStepNotifieesUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepNotifieesIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepNotifieesSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepNotifieesBoolExp!
}

# aggregate variance on columns
type EventApprovalStepNotifieesVarianceFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by variance() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarianceOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepNotifieesVarPopFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by varPop() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarPopOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepNotifieesVarSampFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by varSamp() on columns of table "event_approval_step_notifiees"
input EventApprovalStepNotifieesVarSampOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# input type for inserting object relation for remote table "event_approval_step"
input EventApprovalStepObjRelInsertInput {
  data: EventApprovalStepInsertInput!

  # upsert condition
  onConflict: EventApprovalStepOnConflict
}

# on_conflict condition type for table "event_approval_step"
input EventApprovalStepOnConflict {
  constraint: EventApprovalStepConstraint!
  updateColumns: [EventApprovalStepUpdateColumn!]! = []
  where: EventApprovalStepBoolExp
}

# Ordering options when selecting data from "event_approval_step".
input EventApprovalStepOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateOrderBy
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateOrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  nextStepEventsAggregate: EventAggregateOrderBy
  nextStepsAggregate: EventApprovalStepAggregateOrderBy
  order: OrderBy
  previousStep: EventApprovalStepOrderBy
  previousStepId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: event_approval_step
input EventApprovalStepPkColumnsInput {
  id: bigint!
}

# select columns of table "event_approval_step"
enum EventApprovalStepSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  order

  # column name
  previousStepId

  # column name
  tenantScopeId
}

# input type for updating data in table "event_approval_step"
input EventApprovalStepSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventApprovalStepStddevFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event_approval_step"
input EventApprovalStepStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepStddevPopFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event_approval_step"
input EventApprovalStepStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepStddevSampFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event_approval_step"
input EventApprovalStepStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event_approval_step"
input EventApprovalStepStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventApprovalStepSumFields {
  createdById: bigint
  id: bigint
  order: Int
  previousStepId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "event_approval_step"
input EventApprovalStepSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "event_approval_step"
enum EventApprovalStepUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  order

  # column name
  previousStepId

  # column name
  tenantScopeId
}

input EventApprovalStepUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepBoolExp!
}

# columns and relationships of "event_approval_step_validators"
type EventApprovalStepValidators {
  # An object relationship
  eventApprovalStep: EventApprovalStep!
  eventApprovalStepId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "event_approval_step_validators"
type EventApprovalStepValidatorsAggregate {
  aggregate: EventApprovalStepValidatorsAggregateFields
  nodes: [EventApprovalStepValidators!]!
}

input EventApprovalStepValidatorsAggregateBoolExp {
  count: eventApprovalStepValidatorsAggregateBoolExpCount
}

input eventApprovalStepValidatorsAggregateBoolExpCount {
  arguments: [EventApprovalStepValidatorsSelectColumn!]
  distinct: Boolean
  filter: EventApprovalStepValidatorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_approval_step_validators"
type EventApprovalStepValidatorsAggregateFields {
  avg: EventApprovalStepValidatorsAvgFields
  count(columns: [EventApprovalStepValidatorsSelectColumn!], distinct: Boolean): Int!
  max: EventApprovalStepValidatorsMaxFields
  min: EventApprovalStepValidatorsMinFields
  stddev: EventApprovalStepValidatorsStddevFields
  stddevPop: EventApprovalStepValidatorsStddevPopFields
  stddevSamp: EventApprovalStepValidatorsStddevSampFields
  sum: EventApprovalStepValidatorsSumFields
  varPop: EventApprovalStepValidatorsVarPopFields
  varSamp: EventApprovalStepValidatorsVarSampFields
  variance: EventApprovalStepValidatorsVarianceFields
}

# order by aggregate values of table "event_approval_step_validators"
input EventApprovalStepValidatorsAggregateOrderBy {
  avg: EventApprovalStepValidatorsAvgOrderBy
  count: OrderBy
  max: EventApprovalStepValidatorsMaxOrderBy
  min: EventApprovalStepValidatorsMinOrderBy
  stddev: EventApprovalStepValidatorsStddevOrderBy
  stddevPop: EventApprovalStepValidatorsStddevPopOrderBy
  stddevSamp: EventApprovalStepValidatorsStddevSampOrderBy
  sum: EventApprovalStepValidatorsSumOrderBy
  varPop: EventApprovalStepValidatorsVarPopOrderBy
  varSamp: EventApprovalStepValidatorsVarSampOrderBy
  variance: EventApprovalStepValidatorsVarianceOrderBy
}

# input type for inserting array relation for remote table "event_approval_step_validators"
input EventApprovalStepValidatorsArrRelInsertInput {
  data: [EventApprovalStepValidatorsInsertInput!]!

  # upsert condition
  onConflict: EventApprovalStepValidatorsOnConflict
}

# aggregate avg on columns
type EventApprovalStepValidatorsAvgFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by avg() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsAvgOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table
# "event_approval_step_validators". All fields are combined with a logical 'AND'.
input EventApprovalStepValidatorsBoolExp {
  _and: [EventApprovalStepValidatorsBoolExp!]
  _not: EventApprovalStepValidatorsBoolExp
  _or: [EventApprovalStepValidatorsBoolExp!]
  eventApprovalStep: EventApprovalStepBoolExp
  eventApprovalStepId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "event_approval_step_validators"
enum EventApprovalStepValidatorsConstraint {
  # unique or primary key constraint on columns "user_id", "event_approval_step_id"
  event_approval_step_validators_pkey
}

# input type for incrementing numeric columns in table "event_approval_step_validators"
input EventApprovalStepValidatorsIncInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# input type for inserting data into table "event_approval_step_validators"
input EventApprovalStepValidatorsInsertInput {
  eventApprovalStep: EventApprovalStepObjRelInsertInput
  eventApprovalStepId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type EventApprovalStepValidatorsMaxFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by max() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsMaxOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type EventApprovalStepValidatorsMinFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by min() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsMinOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "event_approval_step_validators"
type EventApprovalStepValidatorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventApprovalStepValidators!]!
}

# on_conflict condition type for table "event_approval_step_validators"
input EventApprovalStepValidatorsOnConflict {
  constraint: EventApprovalStepValidatorsConstraint!
  updateColumns: [EventApprovalStepValidatorsUpdateColumn!]! = []
  where: EventApprovalStepValidatorsBoolExp
}

# Ordering options when selecting data from "event_approval_step_validators".
input EventApprovalStepValidatorsOrderBy {
  eventApprovalStep: EventApprovalStepOrderBy
  eventApprovalStepId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: event_approval_step_validators
input EventApprovalStepValidatorsPkColumnsInput {
  eventApprovalStepId: bigint!
  userId: bigint!
}

# select columns of table "event_approval_step_validators"
enum EventApprovalStepValidatorsSelectColumn {
  # column name
  eventApprovalStepId

  # column name
  userId
}

# input type for updating data in table "event_approval_step_validators"
input EventApprovalStepValidatorsSetInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# aggregate stddev on columns
type EventApprovalStepValidatorsStddevFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddev() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type EventApprovalStepValidatorsStddevPopFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddevPop() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevPopOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type EventApprovalStepValidatorsStddevSampFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsStddevSampOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "event_approval_step_validators"
input EventApprovalStepValidatorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStepValidatorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStepValidatorsStreamCursorValueInput {
  eventApprovalStepId: bigint
  userId: bigint
}

# aggregate sum on columns
type EventApprovalStepValidatorsSumFields {
  eventApprovalStepId: bigint
  userId: bigint
}

# order by sum() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsSumOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# update columns of table "event_approval_step_validators"
enum EventApprovalStepValidatorsUpdateColumn {
  # column name
  eventApprovalStepId

  # column name
  userId
}

input EventApprovalStepValidatorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalStepValidatorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalStepValidatorsSetInput

  # filter the rows which have to be updated
  where: EventApprovalStepValidatorsBoolExp!
}

# aggregate variance on columns
type EventApprovalStepValidatorsVarianceFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by variance() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarianceOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepValidatorsVarPopFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by varPop() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarPopOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepValidatorsVarSampFields {
  eventApprovalStepId: Float
  userId: Float
}

# order by varSamp() on columns of table "event_approval_step_validators"
input EventApprovalStepValidatorsVarSampOrderBy {
  eventApprovalStepId: OrderBy
  userId: OrderBy
}

# aggregate variance on columns
type EventApprovalStepVarianceFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event_approval_step"
input EventApprovalStepVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventApprovalStepVarPopFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event_approval_step"
input EventApprovalStepVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalStepVarSampFields {
  createdById: Float
  id: Float
  order: Float
  previousStepId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event_approval_step"
input EventApprovalStepVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  previousStepId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event_approval"
input EventApprovalStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventApprovalStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventApprovalStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventApprovalStepId: bigint
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  isApproved: Boolean
  message: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventApprovalSumFields {
  createdById: bigint
  eventApprovalStepId: bigint
  eventId: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "event_approval"
input EventApprovalSumOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "event_approval"
enum EventApprovalUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventApprovalStepId

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isApproved

  # column name
  message

  # column name
  tenantScopeId
}

input EventApprovalUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventApprovalIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventApprovalSetInput

  # filter the rows which have to be updated
  where: EventApprovalBoolExp!
}

# aggregate variance on columns
type EventApprovalVarianceFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event_approval"
input EventApprovalVarianceOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventApprovalVarPopFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event_approval"
input EventApprovalVarPopOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventApprovalVarSampFields {
  createdById: Float
  eventApprovalStepId: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event_approval"
input EventApprovalVarSampOrderBy {
  createdById: OrderBy
  eventApprovalStepId: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# input type for inserting array relation for remote table "event"
input EventArrRelInsertInput {
  data: [EventInsertInput!]!

  # upsert condition
  onConflict: EventOnConflict
}

# aggregate avg on columns
type EventAvgFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event"
input EventAvgOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input EventBoolExp {
  _and: [EventBoolExp!]
  _not: EventBoolExp
  _or: [EventBoolExp!]
  banner: FileUploadBoolExp
  bannerId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  end: TimestamptzComparisonExp
  eventApprovalSubmission: FormSubmissionBoolExp
  eventApprovalSubmissionId: BigintComparisonExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  eventFavorites: EventFavoriteBoolExp
  eventFavoritesAggregate: EventFavoriteAggregateBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  eventOrganizes: EventOrganizeBoolExp
  eventOrganizesAggregate: EventOrganizeAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAutoAcceptingJoins: BooleanComparisonExp
  isPrivate: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  joinForm: FormBoolExp
  joinFormId: BigintComparisonExp
  location: LocationBoolExp
  locationId: BigintComparisonExp
  maxParticipants: SmallintComparisonExp
  meta: JsonbComparisonExp
  name: StringComparisonExp
  nextEventApprovalStep: EventApprovalStepBoolExp
  nextEventApprovalStepId: BigintComparisonExp
  pointsAwardedForAttendance: FloatComparisonExp
  price: FloatComparisonExp
  slug: StringComparisonExp
  start: TimestamptzComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactions: TransactionBoolExp
  transactionsAggregate: TransactionAggregateBoolExp
}

# unique or primary key constraints on table "event"
enum EventConstraint {
  # unique or primary key constraint on columns "event_approval_submission_id"
  event_event_approval_submission_id_unique

  # unique or primary key constraint on columns "id"
  event_pkey

  # unique or primary key constraint on columns "slug"
  event_slug_unique
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input EventDeleteAtPathInput {
  meta: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input EventDeleteElemInput {
  meta: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input EventDeleteKeyInput {
  meta: String
}

# columns and relationships of "event_favorite"
type EventFavorite {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event!
  eventId: bigint!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "event_favorite"
type EventFavoriteAggregate {
  aggregate: EventFavoriteAggregateFields
  nodes: [EventFavorite!]!
}

input EventFavoriteAggregateBoolExp {
  count: eventFavoriteAggregateBoolExpCount
}

input eventFavoriteAggregateBoolExpCount {
  arguments: [EventFavoriteSelectColumn!]
  distinct: Boolean
  filter: EventFavoriteBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_favorite"
type EventFavoriteAggregateFields {
  avg: EventFavoriteAvgFields
  count(columns: [EventFavoriteSelectColumn!], distinct: Boolean): Int!
  max: EventFavoriteMaxFields
  min: EventFavoriteMinFields
  stddev: EventFavoriteStddevFields
  stddevPop: EventFavoriteStddevPopFields
  stddevSamp: EventFavoriteStddevSampFields
  sum: EventFavoriteSumFields
  varPop: EventFavoriteVarPopFields
  varSamp: EventFavoriteVarSampFields
  variance: EventFavoriteVarianceFields
}

# order by aggregate values of table "event_favorite"
input EventFavoriteAggregateOrderBy {
  avg: EventFavoriteAvgOrderBy
  count: OrderBy
  max: EventFavoriteMaxOrderBy
  min: EventFavoriteMinOrderBy
  stddev: EventFavoriteStddevOrderBy
  stddevPop: EventFavoriteStddevPopOrderBy
  stddevSamp: EventFavoriteStddevSampOrderBy
  sum: EventFavoriteSumOrderBy
  varPop: EventFavoriteVarPopOrderBy
  varSamp: EventFavoriteVarSampOrderBy
  variance: EventFavoriteVarianceOrderBy
}

# input type for inserting array relation for remote table "event_favorite"
input EventFavoriteArrRelInsertInput {
  data: [EventFavoriteInsertInput!]!

  # upsert condition
  onConflict: EventFavoriteOnConflict
}

# aggregate avg on columns
type EventFavoriteAvgFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event_favorite"
input EventFavoriteAvgOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event_favorite". All fields are combined with a logical 'AND'.
input EventFavoriteBoolExp {
  _and: [EventFavoriteBoolExp!]
  _not: EventFavoriteBoolExp
  _or: [EventFavoriteBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "event_favorite"
enum EventFavoriteConstraint {
  # unique or primary key constraint on columns "id"
  event_favorite_pkey
}

# input type for incrementing numeric columns in table "event_favorite"
input EventFavoriteIncInput {
  createdById: bigint
  eventId: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "event_favorite"
input EventFavoriteInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type EventFavoriteMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "event_favorite"
input EventFavoriteMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventFavoriteMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "event_favorite"
input EventFavoriteMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event_favorite"
type EventFavoriteMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventFavorite!]!
}

# on_conflict condition type for table "event_favorite"
input EventFavoriteOnConflict {
  constraint: EventFavoriteConstraint!
  updateColumns: [EventFavoriteUpdateColumn!]! = []
  where: EventFavoriteBoolExp
}

# Ordering options when selecting data from "event_favorite".
input EventFavoriteOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: event_favorite
input EventFavoritePkColumnsInput {
  id: bigint!
}

# select columns of table "event_favorite"
enum EventFavoriteSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId
}

# input type for updating data in table "event_favorite"
input EventFavoriteSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventFavoriteStddevFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event_favorite"
input EventFavoriteStddevOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventFavoriteStddevPopFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event_favorite"
input EventFavoriteStddevPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventFavoriteStddevSampFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event_favorite"
input EventFavoriteStddevSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event_favorite"
input EventFavoriteStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventFavoriteStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventFavoriteStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventFavoriteSumFields {
  createdById: bigint
  eventId: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "event_favorite"
input EventFavoriteSumOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "event_favorite"
enum EventFavoriteUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId
}

input EventFavoriteUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventFavoriteIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventFavoriteSetInput

  # filter the rows which have to be updated
  where: EventFavoriteBoolExp!
}

# aggregate variance on columns
type EventFavoriteVarianceFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event_favorite"
input EventFavoriteVarianceOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventFavoriteVarPopFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event_favorite"
input EventFavoriteVarPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventFavoriteVarSampFields {
  createdById: Float
  eventId: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event_favorite"
input EventFavoriteVarSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# input type for incrementing numeric columns in table "event"
input EventIncInput {
  bannerId: bigint
  createdById: bigint
  eventApprovalSubmissionId: bigint
  id: bigint
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: bigint
}

# input type for inserting data into table "event"
input EventInsertInput {
  banner: FileUploadObjRelInsertInput
  bannerId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventApprovalSubmission: FormSubmissionObjRelInsertInput
  eventApprovalSubmissionId: bigint
  eventApprovals: EventApprovalArrRelInsertInput
  eventFavorites: EventFavoriteArrRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  eventOrganizes: EventOrganizeArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinForm: FormObjRelInsertInput
  joinFormId: bigint
  location: LocationObjRelInsertInput
  locationId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  nextEventApprovalStep: EventApprovalStepObjRelInsertInput
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  slug: String
  start: timestamptz
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactions: TransactionArrRelInsertInput
}

# columns and relationships of "event_join"
type EventJoin {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event!
  eventId: bigint!

  # An object relationship
  formSubmission: FormSubmission
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isPresent: Boolean

  # An object relationship
  joinedBy: User!
  joinedById: bigint!

  # An object relationship
  linkedMissionJoin: MissionJoin

  # An object relationship
  missionJoin: MissionJoin
  missionJoinId: bigint
  participationProcessedAt: timestamptz

  # An object relationship
  participationProcessedBy: User
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz

  # An object relationship
  processedBy: User
  processedById: bigint

  # An object relationship
  qrCode: FileUpload
  qrCodeId: bigint
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "event_join"
type EventJoinAggregate {
  aggregate: EventJoinAggregateFields
  nodes: [EventJoin!]!
}

input EventJoinAggregateBoolExp {
  bool_and: eventJoinAggregateBoolExpBool_and
  bool_or: eventJoinAggregateBoolExpBool_or
  count: eventJoinAggregateBoolExpCount
}

input eventJoinAggregateBoolExpBool_and {
  arguments: EventJoinSelectColumnEventJoinAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: BooleanComparisonExp!
}

input eventJoinAggregateBoolExpBool_or {
  arguments: EventJoinSelectColumnEventJoinAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: BooleanComparisonExp!
}

input eventJoinAggregateBoolExpCount {
  arguments: [EventJoinSelectColumn!]
  distinct: Boolean
  filter: EventJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_join"
type EventJoinAggregateFields {
  avg: EventJoinAvgFields
  count(columns: [EventJoinSelectColumn!], distinct: Boolean): Int!
  max: EventJoinMaxFields
  min: EventJoinMinFields
  stddev: EventJoinStddevFields
  stddevPop: EventJoinStddevPopFields
  stddevSamp: EventJoinStddevSampFields
  sum: EventJoinSumFields
  varPop: EventJoinVarPopFields
  varSamp: EventJoinVarSampFields
  variance: EventJoinVarianceFields
}

# order by aggregate values of table "event_join"
input EventJoinAggregateOrderBy {
  avg: EventJoinAvgOrderBy
  count: OrderBy
  max: EventJoinMaxOrderBy
  min: EventJoinMinOrderBy
  stddev: EventJoinStddevOrderBy
  stddevPop: EventJoinStddevPopOrderBy
  stddevSamp: EventJoinStddevSampOrderBy
  sum: EventJoinSumOrderBy
  varPop: EventJoinVarPopOrderBy
  varSamp: EventJoinVarSampOrderBy
  variance: EventJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "event_join"
input EventJoinArrRelInsertInput {
  data: [EventJoinInsertInput!]!

  # upsert condition
  onConflict: EventJoinOnConflict
}

# aggregate avg on columns
type EventJoinAvgFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event_join"
input EventJoinAvgOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event_join". All fields are combined with a logical 'AND'.
input EventJoinBoolExp {
  _and: [EventJoinBoolExp!]
  _not: EventJoinBoolExp
  _or: [EventJoinBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  formSubmission: FormSubmissionBoolExp
  formSubmissionId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isPresent: BooleanComparisonExp
  joinedBy: UserBoolExp
  joinedById: BigintComparisonExp
  linkedMissionJoin: MissionJoinBoolExp
  missionJoin: MissionJoinBoolExp
  missionJoinId: BigintComparisonExp
  participationProcessedAt: TimestamptzComparisonExp
  participationProcessedBy: UserBoolExp
  participationProcessedById: BigintComparisonExp
  participationProcessedVia: StringComparisonExp
  processedAt: TimestamptzComparisonExp
  processedBy: UserBoolExp
  processedById: BigintComparisonExp
  qrCode: FileUploadBoolExp
  qrCodeId: BigintComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "event_join"
enum EventJoinConstraint {
  # unique or primary key constraint on columns "id"
  event_join_pkey
}

# input type for incrementing numeric columns in table "event_join"
input EventJoinIncInput {
  createdById: bigint
  eventId: bigint
  formSubmissionId: bigint
  id: bigint
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedById: bigint
  processedById: bigint
  qrCodeId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "event_join"
input EventJoinInsertInput {
  actions: ActionArrRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventId: bigint
  formSubmission: FormSubmissionObjRelInsertInput
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPresent: Boolean
  joinedBy: UserObjRelInsertInput
  joinedById: bigint
  linkedMissionJoin: MissionJoinObjRelInsertInput
  missionJoin: MissionJoinObjRelInsertInput
  missionJoinId: bigint
  participationProcessedAt: timestamptz
  participationProcessedBy: UserObjRelInsertInput
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz
  processedBy: UserObjRelInsertInput
  processedById: bigint
  qrCode: FileUploadObjRelInsertInput
  qrCodeId: bigint
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type EventJoinMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedAt: timestamptz
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz
  processedById: bigint
  qrCodeId: bigint
  state: String
  tenantScopeId: bigint
}

# order by max() on columns of table "event_join"
input EventJoinMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedAt: OrderBy
  participationProcessedById: OrderBy
  participationProcessedVia: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventJoinMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedAt: timestamptz
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz
  processedById: bigint
  qrCodeId: bigint
  state: String
  tenantScopeId: bigint
}

# order by min() on columns of table "event_join"
input EventJoinMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedAt: OrderBy
  participationProcessedById: OrderBy
  participationProcessedVia: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event_join"
type EventJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventJoin!]!
}

# input type for inserting object relation for remote table "event_join"
input EventJoinObjRelInsertInput {
  data: EventJoinInsertInput!

  # upsert condition
  onConflict: EventJoinOnConflict
}

# on_conflict condition type for table "event_join"
input EventJoinOnConflict {
  constraint: EventJoinConstraint!
  updateColumns: [EventJoinUpdateColumn!]! = []
  where: EventJoinBoolExp
}

# Ordering options when selecting data from "event_join".
input EventJoinOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  formSubmission: FormSubmissionOrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isPresent: OrderBy
  joinedBy: UserOrderBy
  joinedById: OrderBy
  linkedMissionJoin: MissionJoinOrderBy
  missionJoin: MissionJoinOrderBy
  missionJoinId: OrderBy
  participationProcessedAt: OrderBy
  participationProcessedBy: UserOrderBy
  participationProcessedById: OrderBy
  participationProcessedVia: OrderBy
  processedAt: OrderBy
  processedBy: UserOrderBy
  processedById: OrderBy
  qrCode: FileUploadOrderBy
  qrCodeId: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: event_join
input EventJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "event_join"
enum EventJoinSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPresent

  # column name
  joinedById

  # column name
  missionJoinId

  # column name
  participationProcessedAt

  # column name
  participationProcessedById

  # column name
  participationProcessedVia

  # column name
  processedAt

  # column name
  processedById

  # column name
  qrCodeId

  # column name
  state

  # column name
  tenantScopeId
}

# select "eventJoinAggregateBoolExpBool_andArgumentsColumns" columns of table "event_join"
enum EventJoinSelectColumnEventJoinAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isPresent
}

# select "eventJoinAggregateBoolExpBool_orArgumentsColumns" columns of table "event_join"
enum EventJoinSelectColumnEventJoinAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isPresent
}

# input type for updating data in table "event_join"
input EventJoinSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPresent: Boolean
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedAt: timestamptz
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz
  processedById: bigint
  qrCodeId: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventJoinStddevFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event_join"
input EventJoinStddevOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventJoinStddevPopFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event_join"
input EventJoinStddevPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventJoinStddevSampFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event_join"
input EventJoinStddevSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event_join"
input EventJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventJoinStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventId: bigint
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPresent: Boolean
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedAt: timestamptz
  participationProcessedById: bigint
  participationProcessedVia: String
  processedAt: timestamptz
  processedById: bigint
  qrCodeId: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventJoinSumFields {
  createdById: bigint
  eventId: bigint
  formSubmissionId: bigint
  id: bigint
  joinedById: bigint
  missionJoinId: bigint
  participationProcessedById: bigint
  processedById: bigint
  qrCodeId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "event_join"
input EventJoinSumOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "event_join"
enum EventJoinUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventId

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPresent

  # column name
  joinedById

  # column name
  missionJoinId

  # column name
  participationProcessedAt

  # column name
  participationProcessedById

  # column name
  participationProcessedVia

  # column name
  processedAt

  # column name
  processedById

  # column name
  qrCodeId

  # column name
  state

  # column name
  tenantScopeId
}

input EventJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventJoinSetInput

  # filter the rows which have to be updated
  where: EventJoinBoolExp!
}

# aggregate variance on columns
type EventJoinVarianceFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event_join"
input EventJoinVarianceOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventJoinVarPopFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event_join"
input EventJoinVarPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventJoinVarSampFields {
  createdById: Float
  eventId: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  missionJoinId: Float
  participationProcessedById: Float
  processedById: Float
  qrCodeId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event_join"
input EventJoinVarSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionJoinId: OrderBy
  participationProcessedById: OrderBy
  processedById: OrderBy
  qrCodeId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate max on columns
type EventMaxFields {
  bannerId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventApprovalSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  name: String
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  slug: String
  start: timestamptz
  state: String
  tenantScopeId: bigint
}

# order by max() on columns of table "event"
input EventMaxOrderBy {
  bannerId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  eventApprovalSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  name: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventMinFields {
  bannerId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventApprovalSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  name: String
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  slug: String
  start: timestamptz
  state: String
  tenantScopeId: bigint
}

# order by min() on columns of table "event"
input EventMinOrderBy {
  bannerId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  eventApprovalSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  name: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event"
type EventMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Event!]!
}

# input type for inserting object relation for remote table "event"
input EventObjRelInsertInput {
  data: EventInsertInput!

  # upsert condition
  onConflict: EventOnConflict
}

# on_conflict condition type for table "event"
input EventOnConflict {
  constraint: EventConstraint!
  updateColumns: [EventUpdateColumn!]! = []
  where: EventBoolExp
}

# Ordering options when selecting data from "event".
input EventOrderBy {
  banner: FileUploadOrderBy
  bannerId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  eventApprovalSubmission: FormSubmissionOrderBy
  eventApprovalSubmissionId: OrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  eventFavoritesAggregate: EventFavoriteAggregateOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventOrganizesAggregate: EventOrganizeAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAutoAcceptingJoins: OrderBy
  isPrivate: OrderBy
  isTemplate: OrderBy
  joinForm: FormOrderBy
  joinFormId: OrderBy
  location: LocationOrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  meta: OrderBy
  name: OrderBy
  nextEventApprovalStep: EventApprovalStepOrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  slug: OrderBy
  start: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionsAggregate: TransactionAggregateOrderBy
}

# columns and relationships of "event_organize"
type EventOrganize {
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  event: Event!
  eventId: bigint!

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # An object relationship
  project: Project
  projectId: bigint

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  user: User
}

# aggregated selection of "event_organize"
type EventOrganizeAggregate {
  aggregate: EventOrganizeAggregateFields
  nodes: [EventOrganize!]!
}

input EventOrganizeAggregateBoolExp {
  count: eventOrganizeAggregateBoolExpCount
}

input eventOrganizeAggregateBoolExpCount {
  arguments: [EventOrganizeSelectColumn!]
  distinct: Boolean
  filter: EventOrganizeBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_organize"
type EventOrganizeAggregateFields {
  avg: EventOrganizeAvgFields
  count(columns: [EventOrganizeSelectColumn!], distinct: Boolean): Int!
  max: EventOrganizeMaxFields
  min: EventOrganizeMinFields
  stddev: EventOrganizeStddevFields
  stddevPop: EventOrganizeStddevPopFields
  stddevSamp: EventOrganizeStddevSampFields
  sum: EventOrganizeSumFields
  varPop: EventOrganizeVarPopFields
  varSamp: EventOrganizeVarSampFields
  variance: EventOrganizeVarianceFields
}

# order by aggregate values of table "event_organize"
input EventOrganizeAggregateOrderBy {
  avg: EventOrganizeAvgOrderBy
  count: OrderBy
  max: EventOrganizeMaxOrderBy
  min: EventOrganizeMinOrderBy
  stddev: EventOrganizeStddevOrderBy
  stddevPop: EventOrganizeStddevPopOrderBy
  stddevSamp: EventOrganizeStddevSampOrderBy
  sum: EventOrganizeSumOrderBy
  varPop: EventOrganizeVarPopOrderBy
  varSamp: EventOrganizeVarSampOrderBy
  variance: EventOrganizeVarianceOrderBy
}

# input type for inserting array relation for remote table "event_organize"
input EventOrganizeArrRelInsertInput {
  data: [EventOrganizeInsertInput!]!

  # upsert condition
  onConflict: EventOrganizeOnConflict
}

# aggregate avg on columns
type EventOrganizeAvgFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "event_organize"
input EventOrganizeAvgOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "event_organize". All fields are combined with a logical 'AND'.
input EventOrganizeBoolExp {
  _and: [EventOrganizeBoolExp!]
  _not: EventOrganizeBoolExp
  _or: [EventOrganizeBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  eventSupervisors: EventSupervisorBoolExp
  eventSupervisorsAggregate: EventSupervisorAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "event_organize"
enum EventOrganizeConstraint {
  # unique or primary key constraint on columns "id"
  event_organize_pkey
}

# input type for incrementing numeric columns in table "event_organize"
input EventOrganizeIncInput {
  createdById: bigint
  eventId: bigint
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "event_organize"
input EventOrganizeInsertInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  event: EventObjRelInsertInput
  eventId: bigint
  eventSupervisors: EventSupervisorArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  missions: MissionArrRelInsertInput
  project: ProjectObjRelInsertInput
  projectId: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
}

# aggregate max on columns
type EventOrganizeMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "event_organize"
input EventOrganizeMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type EventOrganizeMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "event_organize"
input EventOrganizeMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "event_organize"
type EventOrganizeMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventOrganize!]!
}

# input type for inserting object relation for remote table "event_organize"
input EventOrganizeObjRelInsertInput {
  data: EventOrganizeInsertInput!

  # upsert condition
  onConflict: EventOrganizeOnConflict
}

# on_conflict condition type for table "event_organize"
input EventOrganizeOnConflict {
  constraint: EventOrganizeConstraint!
  updateColumns: [EventOrganizeUpdateColumn!]! = []
  where: EventOrganizeBoolExp
}

# Ordering options when selecting data from "event_organize".
input EventOrganizeOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  eventSupervisorsAggregate: EventSupervisorAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  missionsAggregate: MissionAggregateOrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: event_organize
input EventOrganizePkColumnsInput {
  id: bigint!
}

# select columns of table "event_organize"
enum EventOrganizeSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  projectId

  # column name
  teamId

  # column name
  tenantScopeId
}

# input type for updating data in table "event_organize"
input EventOrganizeSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventOrganizeStddevFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event_organize"
input EventOrganizeStddevOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventOrganizeStddevPopFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event_organize"
input EventOrganizeStddevPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventOrganizeStddevSampFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event_organize"
input EventOrganizeStddevSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event_organize"
input EventOrganizeStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventOrganizeStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventOrganizeStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  hiddenAt: timestamptz
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventOrganizeSumFields {
  createdById: bigint
  eventId: bigint
  id: bigint
  projectId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "event_organize"
input EventOrganizeSumOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "event_organize"
enum EventOrganizeUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  hiddenAt

  # column name
  id

  # column name
  projectId

  # column name
  teamId

  # column name
  tenantScopeId
}

input EventOrganizeUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventOrganizeIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventOrganizeSetInput

  # filter the rows which have to be updated
  where: EventOrganizeBoolExp!
}

# aggregate variance on columns
type EventOrganizeVarianceFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event_organize"
input EventOrganizeVarianceOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventOrganizeVarPopFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event_organize"
input EventOrganizeVarPopOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventOrganizeVarSampFields {
  createdById: Float
  eventId: Float
  id: Float
  projectId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event_organize"
input EventOrganizeVarSampOrderBy {
  createdById: OrderBy
  eventId: OrderBy
  id: OrderBy
  projectId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: event
input EventPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input EventPrependInput {
  meta: jsonb
}

# select columns of table "event"
enum EventSelectColumn {
  # column name
  bannerId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  end

  # column name
  eventApprovalSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  joinFormId

  # column name
  locationId

  # column name
  maxParticipants

  # column name
  meta

  # column name
  name

  # column name
  nextEventApprovalStepId

  # column name
  pointsAwardedForAttendance

  # column name
  price

  # column name
  slug

  # column name
  start

  # column name
  state

  # column name
  tenantScopeId
}

# select "eventAggregateBoolExpBool_andArgumentsColumns" columns of table "event"
enum EventSelectColumnEventAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate
}

# select "eventAggregateBoolExpBool_orArgumentsColumns" columns of table "event"
enum EventSelectColumnEventAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate
}

# input type for updating data in table "event"
input EventSetInput {
  bannerId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventApprovalSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  slug: String
  start: timestamptz
  state: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type EventStddevFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "event"
input EventStddevOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type EventStddevPopFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "event"
input EventStddevPopOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type EventStddevSampFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "event"
input EventStddevSampOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "event"
input EventStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventStreamCursorValueInput {
  bannerId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventApprovalSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingJoins: Boolean
  isPrivate: Boolean
  isTemplate: Boolean
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  meta: jsonb
  name: String
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  slug: String
  start: timestamptz
  state: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type EventSumFields {
  bannerId: bigint
  createdById: bigint
  eventApprovalSubmissionId: bigint
  id: bigint
  joinFormId: bigint
  locationId: bigint
  maxParticipants: smallint
  nextEventApprovalStepId: bigint
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: bigint
}

# order by sum() on columns of table "event"
input EventSumOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "event_supervisor"
type EventSupervisor {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  eventOrganize: EventOrganize!
  eventOrganizeId: bigint!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  title: String

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "event_supervisor"
type EventSupervisorAggregate {
  aggregate: EventSupervisorAggregateFields
  nodes: [EventSupervisor!]!
}

input EventSupervisorAggregateBoolExp {
  count: eventSupervisorAggregateBoolExpCount
}

input eventSupervisorAggregateBoolExpCount {
  arguments: [EventSupervisorSelectColumn!]
  distinct: Boolean
  filter: EventSupervisorBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "event_supervisor"
type EventSupervisorAggregateFields {
  avg: EventSupervisorAvgFields
  count(columns: [EventSupervisorSelectColumn!], distinct: Boolean): Int!
  max: EventSupervisorMaxFields
  min: EventSupervisorMinFields
  stddev: EventSupervisorStddevFields
  stddevPop: EventSupervisorStddevPopFields
  stddevSamp: EventSupervisorStddevSampFields
  sum: EventSupervisorSumFields
  varPop: EventSupervisorVarPopFields
  varSamp: EventSupervisorVarSampFields
  variance: EventSupervisorVarianceFields
}

# order by aggregate values of table "event_supervisor"
input EventSupervisorAggregateOrderBy {
  avg: EventSupervisorAvgOrderBy
  count: OrderBy
  max: EventSupervisorMaxOrderBy
  min: EventSupervisorMinOrderBy
  stddev: EventSupervisorStddevOrderBy
  stddevPop: EventSupervisorStddevPopOrderBy
  stddevSamp: EventSupervisorStddevSampOrderBy
  sum: EventSupervisorSumOrderBy
  varPop: EventSupervisorVarPopOrderBy
  varSamp: EventSupervisorVarSampOrderBy
  variance: EventSupervisorVarianceOrderBy
}

# input type for inserting array relation for remote table "event_supervisor"
input EventSupervisorArrRelInsertInput {
  data: [EventSupervisorInsertInput!]!

  # upsert condition
  onConflict: EventSupervisorOnConflict
}

# aggregate avg on columns
type EventSupervisorAvgFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by avg() on columns of table "event_supervisor"
input EventSupervisorAvgOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "event_supervisor". All fields are combined with a logical 'AND'.
input EventSupervisorBoolExp {
  _and: [EventSupervisorBoolExp!]
  _not: EventSupervisorBoolExp
  _or: [EventSupervisorBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventOrganize: EventOrganizeBoolExp
  eventOrganizeId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  title: StringComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "event_supervisor"
enum EventSupervisorConstraint {
  # unique or primary key constraint on columns "id"
  event_supervisor_pkey
}

# input type for incrementing numeric columns in table "event_supervisor"
input EventSupervisorIncInput {
  createdById: bigint
  eventOrganizeId: bigint
  id: bigint
  tenantScopeId: bigint
  userId: bigint
}

# input type for inserting data into table "event_supervisor"
input EventSupervisorInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventOrganize: EventOrganizeObjRelInsertInput
  eventOrganizeId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  title: String
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type EventSupervisorMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventOrganizeId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
  title: String
  userId: bigint
}

# order by max() on columns of table "event_supervisor"
input EventSupervisorMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventOrganizeId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  title: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type EventSupervisorMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventOrganizeId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
  title: String
  userId: bigint
}

# order by min() on columns of table "event_supervisor"
input EventSupervisorMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventOrganizeId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  title: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "event_supervisor"
type EventSupervisorMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [EventSupervisor!]!
}

# on_conflict condition type for table "event_supervisor"
input EventSupervisorOnConflict {
  constraint: EventSupervisorConstraint!
  updateColumns: [EventSupervisorUpdateColumn!]! = []
  where: EventSupervisorBoolExp
}

# Ordering options when selecting data from "event_supervisor".
input EventSupervisorOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventOrganize: EventOrganizeOrderBy
  eventOrganizeId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  title: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: event_supervisor
input EventSupervisorPkColumnsInput {
  id: bigint!
}

# select columns of table "event_supervisor"
enum EventSupervisorSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventOrganizeId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId

  # column name
  title

  # column name
  userId
}

# input type for updating data in table "event_supervisor"
input EventSupervisorSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventOrganizeId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
  title: String
  userId: bigint
}

# aggregate stddev on columns
type EventSupervisorStddevFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddev() on columns of table "event_supervisor"
input EventSupervisorStddevOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type EventSupervisorStddevPopFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevPop() on columns of table "event_supervisor"
input EventSupervisorStddevPopOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type EventSupervisorStddevSampFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "event_supervisor"
input EventSupervisorStddevSampOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "event_supervisor"
input EventSupervisorStreamCursorInput {
  # Stream column input with initial value
  initialValue: EventSupervisorStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input EventSupervisorStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventOrganizeId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
  title: String
  userId: bigint
}

# aggregate sum on columns
type EventSupervisorSumFields {
  createdById: bigint
  eventOrganizeId: bigint
  id: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by sum() on columns of table "event_supervisor"
input EventSupervisorSumOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# update columns of table "event_supervisor"
enum EventSupervisorUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventOrganizeId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId

  # column name
  title

  # column name
  userId
}

input EventSupervisorUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: EventSupervisorIncInput

  # sets the columns of the filtered rows to the given values
  _set: EventSupervisorSetInput

  # filter the rows which have to be updated
  where: EventSupervisorBoolExp!
}

# aggregate variance on columns
type EventSupervisorVarianceFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by variance() on columns of table "event_supervisor"
input EventSupervisorVarianceOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type EventSupervisorVarPopFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by varPop() on columns of table "event_supervisor"
input EventSupervisorVarPopOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type EventSupervisorVarSampFields {
  createdById: Float
  eventOrganizeId: Float
  id: Float
  tenantScopeId: Float
  userId: Float
}

# order by varSamp() on columns of table "event_supervisor"
input EventSupervisorVarSampOrderBy {
  createdById: OrderBy
  eventOrganizeId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# update columns of table "event"
enum EventUpdateColumn {
  # column name
  bannerId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  end

  # column name
  eventApprovalSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingJoins

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  joinFormId

  # column name
  locationId

  # column name
  maxParticipants

  # column name
  meta

  # column name
  name

  # column name
  nextEventApprovalStepId

  # column name
  pointsAwardedForAttendance

  # column name
  price

  # column name
  slug

  # column name
  start

  # column name
  state

  # column name
  tenantScopeId
}

input EventUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: EventAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: EventDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: EventDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: EventDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: EventIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: EventPrependInput

  # sets the columns of the filtered rows to the given values
  _set: EventSetInput

  # filter the rows which have to be updated
  where: EventBoolExp!
}

# aggregate variance on columns
type EventVarianceFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "event"
input EventVarianceOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type EventVarPopFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "event"
input EventVarPopOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type EventVarSampFields {
  bannerId: Float
  createdById: Float
  eventApprovalSubmissionId: Float
  id: Float
  joinFormId: Float
  locationId: Float
  maxParticipants: Float
  nextEventApprovalStepId: Float
  pointsAwardedForAttendance: Float
  price: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "event"
input EventVarSampOrderBy {
  bannerId: OrderBy
  createdById: OrderBy
  eventApprovalSubmissionId: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  locationId: OrderBy
  maxParticipants: OrderBy
  nextEventApprovalStepId: OrderBy
  pointsAwardedForAttendance: OrderBy
  price: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "expense"
type Expense {
  # An object relationship
  bankInfo: BankInfo!
  bankInfoId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!
  expenseReportId: bigint!

  # An object relationship
  fileUpload: FileUpload!
  hiddenAt: timestamptz
  id: bigint!
  lastNotifiedAt: timestamptz
  processedAt: timestamptz

  # An object relationship
  processedBy: User
  processedById: bigint
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  transaction: Transaction
}

# aggregated selection of "expense"
type ExpenseAggregate {
  aggregate: ExpenseAggregateFields
  nodes: [Expense!]!
}

input ExpenseAggregateBoolExp {
  count: expenseAggregateBoolExpCount
}

input expenseAggregateBoolExpCount {
  arguments: [ExpenseSelectColumn!]
  distinct: Boolean
  filter: ExpenseBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense"
type ExpenseAggregateFields {
  avg: ExpenseAvgFields
  count(columns: [ExpenseSelectColumn!], distinct: Boolean): Int!
  max: ExpenseMaxFields
  min: ExpenseMinFields
  stddev: ExpenseStddevFields
  stddevPop: ExpenseStddevPopFields
  stddevSamp: ExpenseStddevSampFields
  sum: ExpenseSumFields
  varPop: ExpenseVarPopFields
  varSamp: ExpenseVarSampFields
  variance: ExpenseVarianceFields
}

# order by aggregate values of table "expense"
input ExpenseAggregateOrderBy {
  avg: ExpenseAvgOrderBy
  count: OrderBy
  max: ExpenseMaxOrderBy
  min: ExpenseMinOrderBy
  stddev: ExpenseStddevOrderBy
  stddevPop: ExpenseStddevPopOrderBy
  stddevSamp: ExpenseStddevSampOrderBy
  sum: ExpenseSumOrderBy
  varPop: ExpenseVarPopOrderBy
  varSamp: ExpenseVarSampOrderBy
  variance: ExpenseVarianceOrderBy
}

# input type for inserting array relation for remote table "expense"
input ExpenseArrRelInsertInput {
  data: [ExpenseInsertInput!]!

  # upsert condition
  onConflict: ExpenseOnConflict
}

# aggregate avg on columns
type ExpenseAvgFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "expense"
input ExpenseAvgOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "expense". All fields are combined with a logical 'AND'.
input ExpenseBoolExp {
  _and: [ExpenseBoolExp!]
  _not: ExpenseBoolExp
  _or: [ExpenseBoolExp!]
  bankInfo: BankInfoBoolExp
  bankInfoId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  expenseReportId: BigintComparisonExp
  fileUpload: FileUploadBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  lastNotifiedAt: TimestamptzComparisonExp
  processedAt: TimestamptzComparisonExp
  processedBy: UserBoolExp
  processedById: BigintComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transaction: TransactionBoolExp
}

# unique or primary key constraints on table "expense"
enum ExpenseConstraint {
  # unique or primary key constraint on columns "id"
  expense_pkey
}

# input type for incrementing numeric columns in table "expense"
input ExpenseIncInput {
  bankInfoId: bigint
  createdById: bigint
  expenseReportId: bigint
  id: bigint
  processedById: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "expense"
input ExpenseInsertInput {
  bankInfo: BankInfoObjRelInsertInput
  bankInfoId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseItems: ExpenseItemArrRelInsertInput
  expenseReportId: bigint
  fileUpload: FileUploadObjRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  processedAt: timestamptz
  processedBy: UserObjRelInsertInput
  processedById: bigint
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transaction: TransactionObjRelInsertInput
}

# columns and relationships of "expense_item"
type ExpenseItem {
  category: String!

  # An object relationship
  company: LegalUnit
  companyId: bigint
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  expense: Expense
  expenseId: bigint

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  payedAt: timestamptz
  quantity: smallint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  unitCost: Float!
}

# aggregated selection of "expense_item"
type ExpenseItemAggregate {
  aggregate: ExpenseItemAggregateFields
  nodes: [ExpenseItem!]!
}

input ExpenseItemAggregateBoolExp {
  count: expenseItemAggregateBoolExpCount
}

input expenseItemAggregateBoolExpCount {
  arguments: [ExpenseItemSelectColumn!]
  distinct: Boolean
  filter: ExpenseItemBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense_item"
type ExpenseItemAggregateFields {
  avg: ExpenseItemAvgFields
  count(columns: [ExpenseItemSelectColumn!], distinct: Boolean): Int!
  max: ExpenseItemMaxFields
  min: ExpenseItemMinFields
  stddev: ExpenseItemStddevFields
  stddevPop: ExpenseItemStddevPopFields
  stddevSamp: ExpenseItemStddevSampFields
  sum: ExpenseItemSumFields
  varPop: ExpenseItemVarPopFields
  varSamp: ExpenseItemVarSampFields
  variance: ExpenseItemVarianceFields
}

# order by aggregate values of table "expense_item"
input ExpenseItemAggregateOrderBy {
  avg: ExpenseItemAvgOrderBy
  count: OrderBy
  max: ExpenseItemMaxOrderBy
  min: ExpenseItemMinOrderBy
  stddev: ExpenseItemStddevOrderBy
  stddevPop: ExpenseItemStddevPopOrderBy
  stddevSamp: ExpenseItemStddevSampOrderBy
  sum: ExpenseItemSumOrderBy
  varPop: ExpenseItemVarPopOrderBy
  varSamp: ExpenseItemVarSampOrderBy
  variance: ExpenseItemVarianceOrderBy
}

# input type for inserting array relation for remote table "expense_item"
input ExpenseItemArrRelInsertInput {
  data: [ExpenseItemInsertInput!]!

  # upsert condition
  onConflict: ExpenseItemOnConflict
}

# columns and relationships of "expense_item_attachments"
type ExpenseItemAttachments {
  # An object relationship
  attachment: FileUpload!

  # An object relationship
  expenseItem: ExpenseItem!
  expenseItemId: bigint!
  fileUploadId: bigint!
}

# aggregated selection of "expense_item_attachments"
type ExpenseItemAttachmentsAggregate {
  aggregate: ExpenseItemAttachmentsAggregateFields
  nodes: [ExpenseItemAttachments!]!
}

input ExpenseItemAttachmentsAggregateBoolExp {
  count: expenseItemAttachmentsAggregateBoolExpCount
}

input expenseItemAttachmentsAggregateBoolExpCount {
  arguments: [ExpenseItemAttachmentsSelectColumn!]
  distinct: Boolean
  filter: ExpenseItemAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "expense_item_attachments"
type ExpenseItemAttachmentsAggregateFields {
  avg: ExpenseItemAttachmentsAvgFields
  count(columns: [ExpenseItemAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: ExpenseItemAttachmentsMaxFields
  min: ExpenseItemAttachmentsMinFields
  stddev: ExpenseItemAttachmentsStddevFields
  stddevPop: ExpenseItemAttachmentsStddevPopFields
  stddevSamp: ExpenseItemAttachmentsStddevSampFields
  sum: ExpenseItemAttachmentsSumFields
  varPop: ExpenseItemAttachmentsVarPopFields
  varSamp: ExpenseItemAttachmentsVarSampFields
  variance: ExpenseItemAttachmentsVarianceFields
}

# order by aggregate values of table "expense_item_attachments"
input ExpenseItemAttachmentsAggregateOrderBy {
  avg: ExpenseItemAttachmentsAvgOrderBy
  count: OrderBy
  max: ExpenseItemAttachmentsMaxOrderBy
  min: ExpenseItemAttachmentsMinOrderBy
  stddev: ExpenseItemAttachmentsStddevOrderBy
  stddevPop: ExpenseItemAttachmentsStddevPopOrderBy
  stddevSamp: ExpenseItemAttachmentsStddevSampOrderBy
  sum: ExpenseItemAttachmentsSumOrderBy
  varPop: ExpenseItemAttachmentsVarPopOrderBy
  varSamp: ExpenseItemAttachmentsVarSampOrderBy
  variance: ExpenseItemAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "expense_item_attachments"
input ExpenseItemAttachmentsArrRelInsertInput {
  data: [ExpenseItemAttachmentsInsertInput!]!

  # upsert condition
  onConflict: ExpenseItemAttachmentsOnConflict
}

# aggregate avg on columns
type ExpenseItemAttachmentsAvgFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by avg() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsAvgOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# Boolean expression to filter rows from the table "expense_item_attachments". All fields are combined with a logical 'AND'.
input ExpenseItemAttachmentsBoolExp {
  _and: [ExpenseItemAttachmentsBoolExp!]
  _not: ExpenseItemAttachmentsBoolExp
  _or: [ExpenseItemAttachmentsBoolExp!]
  attachment: FileUploadBoolExp
  expenseItem: ExpenseItemBoolExp
  expenseItemId: BigintComparisonExp
  fileUploadId: BigintComparisonExp
}

# unique or primary key constraints on table "expense_item_attachments"
enum ExpenseItemAttachmentsConstraint {
  # unique or primary key constraint on columns "expense_item_id", "file_upload_id"
  expense_item_attachments_pkey
}

# input type for incrementing numeric columns in table "expense_item_attachments"
input ExpenseItemAttachmentsIncInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# input type for inserting data into table "expense_item_attachments"
input ExpenseItemAttachmentsInsertInput {
  attachment: FileUploadObjRelInsertInput
  expenseItem: ExpenseItemObjRelInsertInput
  expenseItemId: bigint
  fileUploadId: bigint
}

# aggregate max on columns
type ExpenseItemAttachmentsMaxFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by max() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsMaxOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate min on columns
type ExpenseItemAttachmentsMinFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by min() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsMinOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# response of any mutation on the table "expense_item_attachments"
type ExpenseItemAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ExpenseItemAttachments!]!
}

# on_conflict condition type for table "expense_item_attachments"
input ExpenseItemAttachmentsOnConflict {
  constraint: ExpenseItemAttachmentsConstraint!
  updateColumns: [ExpenseItemAttachmentsUpdateColumn!]! = []
  where: ExpenseItemAttachmentsBoolExp
}

# Ordering options when selecting data from "expense_item_attachments".
input ExpenseItemAttachmentsOrderBy {
  attachment: FileUploadOrderBy
  expenseItem: ExpenseItemOrderBy
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# primary key columns input for table: expense_item_attachments
input ExpenseItemAttachmentsPkColumnsInput {
  expenseItemId: bigint!
  fileUploadId: bigint!
}

# select columns of table "expense_item_attachments"
enum ExpenseItemAttachmentsSelectColumn {
  # column name
  expenseItemId

  # column name
  fileUploadId
}

# input type for updating data in table "expense_item_attachments"
input ExpenseItemAttachmentsSetInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# aggregate stddev on columns
type ExpenseItemAttachmentsStddevFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddev() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevPop on columns
type ExpenseItemAttachmentsStddevPopFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddevPop() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevPopOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseItemAttachmentsStddevSampFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by stddevSamp() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsStddevSampOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# Streaming cursor of the table "expense_item_attachments"
input ExpenseItemAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseItemAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseItemAttachmentsStreamCursorValueInput {
  expenseItemId: bigint
  fileUploadId: bigint
}

# aggregate sum on columns
type ExpenseItemAttachmentsSumFields {
  expenseItemId: bigint
  fileUploadId: bigint
}

# order by sum() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsSumOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# update columns of table "expense_item_attachments"
enum ExpenseItemAttachmentsUpdateColumn {
  # column name
  expenseItemId

  # column name
  fileUploadId
}

input ExpenseItemAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseItemAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseItemAttachmentsSetInput

  # filter the rows which have to be updated
  where: ExpenseItemAttachmentsBoolExp!
}

# aggregate variance on columns
type ExpenseItemAttachmentsVarianceFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by variance() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarianceOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varPop on columns
type ExpenseItemAttachmentsVarPopFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by varPop() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarPopOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate varSamp on columns
type ExpenseItemAttachmentsVarSampFields {
  expenseItemId: Float
  fileUploadId: Float
}

# order by varSamp() on columns of table "expense_item_attachments"
input ExpenseItemAttachmentsVarSampOrderBy {
  expenseItemId: OrderBy
  fileUploadId: OrderBy
}

# aggregate avg on columns
type ExpenseItemAvgFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by avg() on columns of table "expense_item"
input ExpenseItemAvgOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# Boolean expression to filter rows from the table "expense_item". All fields are combined with a logical 'AND'.
input ExpenseItemBoolExp {
  _and: [ExpenseItemBoolExp!]
  _not: ExpenseItemBoolExp
  _or: [ExpenseItemBoolExp!]
  category: StringComparisonExp
  company: LegalUnitBoolExp
  companyId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  expense: ExpenseBoolExp
  expenseId: BigintComparisonExp
  expenseItemAttachments: ExpenseItemAttachmentsBoolExp
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  payedAt: TimestamptzComparisonExp
  quantity: SmallintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  unitCost: FloatComparisonExp
}

# unique or primary key constraints on table "expense_item"
enum ExpenseItemConstraint {
  # unique or primary key constraint on columns "id"
  expense_item_pkey
}

# input type for incrementing numeric columns in table "expense_item"
input ExpenseItemIncInput {
  companyId: bigint
  createdById: bigint
  expenseId: bigint
  id: bigint
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# input type for inserting data into table "expense_item"
input ExpenseItemInsertInput {
  category: String
  company: LegalUnitObjRelInsertInput
  companyId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expense: ExpenseObjRelInsertInput
  expenseId: bigint
  expenseItemAttachments: ExpenseItemAttachmentsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  unitCost: Float
}

# aggregate max on columns
type ExpenseItemMaxFields {
  category: String
  companyId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# order by max() on columns of table "expense_item"
input ExpenseItemMaxOrderBy {
  category: OrderBy
  companyId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate min on columns
type ExpenseItemMinFields {
  category: String
  companyId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# order by min() on columns of table "expense_item"
input ExpenseItemMinOrderBy {
  category: OrderBy
  companyId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# response of any mutation on the table "expense_item"
type ExpenseItemMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ExpenseItem!]!
}

# input type for inserting object relation for remote table "expense_item"
input ExpenseItemObjRelInsertInput {
  data: ExpenseItemInsertInput!

  # upsert condition
  onConflict: ExpenseItemOnConflict
}

# on_conflict condition type for table "expense_item"
input ExpenseItemOnConflict {
  constraint: ExpenseItemConstraint!
  updateColumns: [ExpenseItemUpdateColumn!]! = []
  where: ExpenseItemBoolExp
}

# Ordering options when selecting data from "expense_item".
input ExpenseItemOrderBy {
  category: OrderBy
  company: LegalUnitOrderBy
  companyId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expense: ExpenseOrderBy
  expenseId: OrderBy
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  payedAt: OrderBy
  quantity: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# primary key columns input for table: expense_item
input ExpenseItemPkColumnsInput {
  id: bigint!
}

# select columns of table "expense_item"
enum ExpenseItemSelectColumn {
  # column name
  category

  # column name
  companyId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  payedAt

  # column name
  quantity

  # column name
  tenantScopeId

  # column name
  unitCost
}

# input type for updating data in table "expense_item"
input ExpenseItemSetInput {
  category: String
  companyId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# aggregate stddev on columns
type ExpenseItemStddevFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by stddev() on columns of table "expense_item"
input ExpenseItemStddevOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate stddevPop on columns
type ExpenseItemStddevPopFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by stddevPop() on columns of table "expense_item"
input ExpenseItemStddevPopOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseItemStddevSampFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by stddevSamp() on columns of table "expense_item"
input ExpenseItemStddevSampOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# Streaming cursor of the table "expense_item"
input ExpenseItemStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseItemStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseItemStreamCursorValueInput {
  category: String
  companyId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  payedAt: timestamptz
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# aggregate sum on columns
type ExpenseItemSumFields {
  companyId: bigint
  createdById: bigint
  expenseId: bigint
  id: bigint
  quantity: smallint
  tenantScopeId: bigint
  unitCost: Float
}

# order by sum() on columns of table "expense_item"
input ExpenseItemSumOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# update columns of table "expense_item"
enum ExpenseItemUpdateColumn {
  # column name
  category

  # column name
  companyId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  payedAt

  # column name
  quantity

  # column name
  tenantScopeId

  # column name
  unitCost
}

input ExpenseItemUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseItemIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseItemSetInput

  # filter the rows which have to be updated
  where: ExpenseItemBoolExp!
}

# aggregate variance on columns
type ExpenseItemVarianceFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by variance() on columns of table "expense_item"
input ExpenseItemVarianceOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate varPop on columns
type ExpenseItemVarPopFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by varPop() on columns of table "expense_item"
input ExpenseItemVarPopOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate varSamp on columns
type ExpenseItemVarSampFields {
  companyId: Float
  createdById: Float
  expenseId: Float
  id: Float
  quantity: Float
  tenantScopeId: Float
  unitCost: Float
}

# order by varSamp() on columns of table "expense_item"
input ExpenseItemVarSampOrderBy {
  companyId: OrderBy
  createdById: OrderBy
  expenseId: OrderBy
  id: OrderBy
  quantity: OrderBy
  tenantScopeId: OrderBy
  unitCost: OrderBy
}

# aggregate max on columns
type ExpenseMaxFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  processedAt: timestamptz
  processedById: bigint
  state: String
  tenantScopeId: bigint
}

# order by max() on columns of table "expense"
input ExpenseMaxOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseReportId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type ExpenseMinFields {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  processedAt: timestamptz
  processedById: bigint
  state: String
  tenantScopeId: bigint
}

# order by min() on columns of table "expense"
input ExpenseMinOrderBy {
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseReportId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "expense"
type ExpenseMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Expense!]!
}

# input type for inserting object relation for remote table "expense"
input ExpenseObjRelInsertInput {
  data: ExpenseInsertInput!

  # upsert condition
  onConflict: ExpenseOnConflict
}

# on_conflict condition type for table "expense"
input ExpenseOnConflict {
  constraint: ExpenseConstraint!
  updateColumns: [ExpenseUpdateColumn!]! = []
  where: ExpenseBoolExp
}

# Ordering options when selecting data from "expense".
input ExpenseOrderBy {
  bankInfo: BankInfoOrderBy
  bankInfoId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  expenseReportId: OrderBy
  fileUpload: FileUploadOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastNotifiedAt: OrderBy
  processedAt: OrderBy
  processedBy: UserOrderBy
  processedById: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transaction: TransactionOrderBy
}

# primary key columns input for table: expense
input ExpensePkColumnsInput {
  id: bigint!
}

# select columns of table "expense"
enum ExpenseSelectColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseReportId

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastNotifiedAt

  # column name
  processedAt

  # column name
  processedById

  # column name
  state

  # column name
  tenantScopeId
}

# input type for updating data in table "expense"
input ExpenseSetInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  processedAt: timestamptz
  processedById: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type ExpenseStddevFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "expense"
input ExpenseStddevOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type ExpenseStddevPopFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "expense"
input ExpenseStddevPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type ExpenseStddevSampFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "expense"
input ExpenseStddevSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "expense"
input ExpenseStreamCursorInput {
  # Stream column input with initial value
  initialValue: ExpenseStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ExpenseStreamCursorValueInput {
  bankInfoId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  expenseReportId: bigint
  hiddenAt: timestamptz
  id: bigint
  lastNotifiedAt: timestamptz
  processedAt: timestamptz
  processedById: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type ExpenseSumFields {
  bankInfoId: bigint
  createdById: bigint
  expenseReportId: bigint
  id: bigint
  processedById: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "expense"
input ExpenseSumOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "expense"
enum ExpenseUpdateColumn {
  # column name
  bankInfoId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  expenseReportId

  # column name
  hiddenAt

  # column name
  id

  # column name
  lastNotifiedAt

  # column name
  processedAt

  # column name
  processedById

  # column name
  state

  # column name
  tenantScopeId
}

input ExpenseUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ExpenseIncInput

  # sets the columns of the filtered rows to the given values
  _set: ExpenseSetInput

  # filter the rows which have to be updated
  where: ExpenseBoolExp!
}

# aggregate variance on columns
type ExpenseVarianceFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "expense"
input ExpenseVarianceOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type ExpenseVarPopFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "expense"
input ExpenseVarPopOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type ExpenseVarSampFields {
  bankInfoId: Float
  createdById: Float
  expenseReportId: Float
  id: Float
  processedById: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "expense"
input ExpenseVarSampOrderBy {
  bankInfoId: OrderBy
  createdById: OrderBy
  expenseReportId: OrderBy
  id: OrderBy
  processedById: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "file_upload"
type FileUpload {
  # An object relationship
  actorImage: ActorImage
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!
  fileLastModifiedAt: timestamptz!

  # An array relationship
  formSubmissionAttachments(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): [FormSubmissionAttachments!]!

  # An aggregate relationship
  formSubmissionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): FormSubmissionAttachmentsAggregate!

  # An array relationship
  grantAllocateAttachments(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): [GrantAllocateAttachments!]!

  # An aggregate relationship
  grantAllocateAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): GrantAllocateAttachmentsAggregate!

  # An array relationship
  grantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  grantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  locationImages(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): [LocationImages!]!

  # An aggregate relationship
  locationImagesAggregate(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): LocationImagesAggregate!
  name: String!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  signatureGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  signatureGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  signedGrantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  signedGrantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!
  size: Int!

  # An array relationship
  tags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  tagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An object relationship
  teamDocument: TeamDocument

  # An array relationship
  teams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  teamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactionAttachments(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): [TransactionAttachments!]!

  # An aggregate relationship
  transactionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): TransactionAttachmentsAggregate!
  type: String!
  url: String!
}

# aggregated selection of "file_upload"
type FileUploadAggregate {
  aggregate: FileUploadAggregateFields
  nodes: [FileUpload!]!
}

input FileUploadAggregateBoolExp {
  count: fileUploadAggregateBoolExpCount
}

input fileUploadAggregateBoolExpCount {
  arguments: [FileUploadSelectColumn!]
  distinct: Boolean
  filter: FileUploadBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "file_upload"
type FileUploadAggregateFields {
  avg: FileUploadAvgFields
  count(columns: [FileUploadSelectColumn!], distinct: Boolean): Int!
  max: FileUploadMaxFields
  min: FileUploadMinFields
  stddev: FileUploadStddevFields
  stddevPop: FileUploadStddevPopFields
  stddevSamp: FileUploadStddevSampFields
  sum: FileUploadSumFields
  varPop: FileUploadVarPopFields
  varSamp: FileUploadVarSampFields
  variance: FileUploadVarianceFields
}

# order by aggregate values of table "file_upload"
input FileUploadAggregateOrderBy {
  avg: FileUploadAvgOrderBy
  count: OrderBy
  max: FileUploadMaxOrderBy
  min: FileUploadMinOrderBy
  stddev: FileUploadStddevOrderBy
  stddevPop: FileUploadStddevPopOrderBy
  stddevSamp: FileUploadStddevSampOrderBy
  sum: FileUploadSumOrderBy
  varPop: FileUploadVarPopOrderBy
  varSamp: FileUploadVarSampOrderBy
  variance: FileUploadVarianceOrderBy
}

# input type for inserting array relation for remote table "file_upload"
input FileUploadArrRelInsertInput {
  data: [FileUploadInsertInput!]!

  # upsert condition
  onConflict: FileUploadOnConflict
}

# aggregate avg on columns
type FileUploadAvgFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "file_upload"
input FileUploadAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "file_upload". All fields are combined with a logical 'AND'.
input FileUploadBoolExp {
  _and: [FileUploadBoolExp!]
  _not: FileUploadBoolExp
  _or: [FileUploadBoolExp!]
  actorImage: ActorImageBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  expenseItemAttachments: ExpenseItemAttachmentsBoolExp
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateBoolExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  fileLastModifiedAt: TimestamptzComparisonExp
  formSubmissionAttachments: FormSubmissionAttachmentsBoolExp
  formSubmissionAttachmentsAggregate: FormSubmissionAttachmentsAggregateBoolExp
  grantAllocateAttachments: GrantAllocateAttachmentsBoolExp
  grantAllocateAttachmentsAggregate: GrantAllocateAttachmentsAggregateBoolExp
  grantAllocates: GrantAllocateBoolExp
  grantAllocatesAggregate: GrantAllocateAggregateBoolExp
  grantAttachments: GrantAttachmentsBoolExp
  grantAttachmentsAggregate: GrantAttachmentsAggregateBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  locationImages: LocationImagesBoolExp
  locationImagesAggregate: LocationImagesAggregateBoolExp
  name: StringComparisonExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  signatureGrants: GrantBoolExp
  signatureGrantsAggregate: GrantAggregateBoolExp
  signedGrantAllocates: GrantAllocateBoolExp
  signedGrantAllocatesAggregate: GrantAllocateAggregateBoolExp
  size: IntComparisonExp
  tags: TagBoolExp
  tagsAggregate: TagAggregateBoolExp
  teamDocument: TeamDocumentBoolExp
  teams: TeamBoolExp
  teamsAggregate: TeamAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactionAttachments: TransactionAttachmentsBoolExp
  transactionAttachmentsAggregate: TransactionAttachmentsAggregateBoolExp
  type: StringComparisonExp
  url: StringComparisonExp
}

# unique or primary key constraints on table "file_upload"
enum FileUploadConstraint {
  # unique or primary key constraint on columns "id"
  file_upload_pkey

  # unique or primary key constraint on columns "url"
  file_upload_url_unique
}

# input type for incrementing numeric columns in table "file_upload"
input FileUploadIncInput {
  createdById: bigint
  id: bigint
  size: Int
  tenantScopeId: bigint
}

# input type for inserting data into table "file_upload"
input FileUploadInsertInput {
  actorImage: ActorImageObjRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventJoins: EventJoinArrRelInsertInput
  events: EventArrRelInsertInput
  expenseItemAttachments: ExpenseItemAttachmentsArrRelInsertInput
  expenses: ExpenseArrRelInsertInput
  fileLastModifiedAt: timestamptz
  formSubmissionAttachments: FormSubmissionAttachmentsArrRelInsertInput
  grantAllocateAttachments: GrantAllocateAttachmentsArrRelInsertInput
  grantAllocates: GrantAllocateArrRelInsertInput
  grantAttachments: GrantAttachmentsArrRelInsertInput
  grants: GrantArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  locationImages: LocationImagesArrRelInsertInput
  name: String
  projects: ProjectArrRelInsertInput
  signatureGrants: GrantArrRelInsertInput
  signedGrantAllocates: GrantAllocateArrRelInsertInput
  size: Int
  tags: TagArrRelInsertInput
  teamDocument: TeamDocumentObjRelInsertInput
  teams: TeamArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactionAttachments: TransactionAttachmentsArrRelInsertInput
  type: String
  url: String
}

# aggregate max on columns
type FileUploadMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantScopeId: bigint
  type: String
  url: String
}

# order by max() on columns of table "file_upload"
input FileUploadMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fileLastModifiedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  url: OrderBy
}

# aggregate min on columns
type FileUploadMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantScopeId: bigint
  type: String
  url: String
}

# order by min() on columns of table "file_upload"
input FileUploadMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fileLastModifiedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  url: OrderBy
}

# response of any mutation on the table "file_upload"
type FileUploadMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FileUpload!]!
}

# input type for inserting object relation for remote table "file_upload"
input FileUploadObjRelInsertInput {
  data: FileUploadInsertInput!

  # upsert condition
  onConflict: FileUploadOnConflict
}

# on_conflict condition type for table "file_upload"
input FileUploadOnConflict {
  constraint: FileUploadConstraint!
  updateColumns: [FileUploadUpdateColumn!]! = []
  where: FileUploadBoolExp
}

# Ordering options when selecting data from "file_upload".
input FileUploadOrderBy {
  actorImage: ActorImageOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventsAggregate: EventAggregateOrderBy
  expenseItemAttachmentsAggregate: ExpenseItemAttachmentsAggregateOrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  fileLastModifiedAt: OrderBy
  formSubmissionAttachmentsAggregate: FormSubmissionAttachmentsAggregateOrderBy
  grantAllocateAttachmentsAggregate: GrantAllocateAttachmentsAggregateOrderBy
  grantAllocatesAggregate: GrantAllocateAggregateOrderBy
  grantAttachmentsAggregate: GrantAttachmentsAggregateOrderBy
  grantsAggregate: GrantAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  locationImagesAggregate: LocationImagesAggregateOrderBy
  name: OrderBy
  projectsAggregate: ProjectAggregateOrderBy
  signatureGrantsAggregate: GrantAggregateOrderBy
  signedGrantAllocatesAggregate: GrantAllocateAggregateOrderBy
  size: OrderBy
  tagsAggregate: TagAggregateOrderBy
  teamDocument: TeamDocumentOrderBy
  teamsAggregate: TeamAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionAttachmentsAggregate: TransactionAttachmentsAggregateOrderBy
  type: OrderBy
  url: OrderBy
}

# primary key columns input for table: file_upload
input FileUploadPkColumnsInput {
  id: bigint!
}

# select columns of table "file_upload"
enum FileUploadSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fileLastModifiedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  size

  # column name
  tenantScopeId

  # column name
  type

  # column name
  url
}

# input type for updating data in table "file_upload"
input FileUploadSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantScopeId: bigint
  type: String
  url: String
}

# aggregate stddev on columns
type FileUploadStddevFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "file_upload"
input FileUploadStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type FileUploadStddevPopFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "file_upload"
input FileUploadStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type FileUploadStddevSampFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "file_upload"
input FileUploadStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "file_upload"
input FileUploadStreamCursorInput {
  # Stream column input with initial value
  initialValue: FileUploadStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FileUploadStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  fileLastModifiedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  size: Int
  tenantScopeId: bigint
  type: String
  url: String
}

# aggregate sum on columns
type FileUploadSumFields {
  createdById: bigint
  id: bigint
  size: Int
  tenantScopeId: bigint
}

# order by sum() on columns of table "file_upload"
input FileUploadSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "file_upload"
enum FileUploadUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  fileLastModifiedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  size

  # column name
  tenantScopeId

  # column name
  type

  # column name
  url
}

input FileUploadUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FileUploadIncInput

  # sets the columns of the filtered rows to the given values
  _set: FileUploadSetInput

  # filter the rows which have to be updated
  where: FileUploadBoolExp!
}

# aggregate variance on columns
type FileUploadVarianceFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "file_upload"
input FileUploadVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type FileUploadVarPopFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "file_upload"
input FileUploadVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type FileUploadVarSampFields {
  createdById: Float
  id: Float
  size: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "file_upload"
input FileUploadVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  size: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
input FloatComparisonExp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _isNull: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

# columns and relationships of "follow"
type Follow {
  # An object relationship
  actor: Actor!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "follow"
type FollowAggregate {
  aggregate: FollowAggregateFields
  nodes: [Follow!]!
}

input FollowAggregateBoolExp {
  count: followAggregateBoolExpCount
}

input followAggregateBoolExpCount {
  arguments: [FollowSelectColumn!]
  distinct: Boolean
  filter: FollowBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "follow"
type FollowAggregateFields {
  avg: FollowAvgFields
  count(columns: [FollowSelectColumn!], distinct: Boolean): Int!
  max: FollowMaxFields
  min: FollowMinFields
  stddev: FollowStddevFields
  stddevPop: FollowStddevPopFields
  stddevSamp: FollowStddevSampFields
  sum: FollowSumFields
  varPop: FollowVarPopFields
  varSamp: FollowVarSampFields
  variance: FollowVarianceFields
}

# order by aggregate values of table "follow"
input FollowAggregateOrderBy {
  avg: FollowAvgOrderBy
  count: OrderBy
  max: FollowMaxOrderBy
  min: FollowMinOrderBy
  stddev: FollowStddevOrderBy
  stddevPop: FollowStddevPopOrderBy
  stddevSamp: FollowStddevSampOrderBy
  sum: FollowSumOrderBy
  varPop: FollowVarPopOrderBy
  varSamp: FollowVarSampOrderBy
  variance: FollowVarianceOrderBy
}

# input type for inserting array relation for remote table "follow"
input FollowArrRelInsertInput {
  data: [FollowInsertInput!]!

  # upsert condition
  onConflict: FollowOnConflict
}

# aggregate avg on columns
type FollowAvgFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "follow"
input FollowAvgOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "follow". All fields are combined with a logical 'AND'.
input FollowBoolExp {
  _and: [FollowBoolExp!]
  _not: FollowBoolExp
  _or: [FollowBoolExp!]
  actor: ActorBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  followedActorId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "follow"
enum FollowConstraint {
  # unique or primary key constraint on columns "id"
  follow_pkey
}

# input type for incrementing numeric columns in table "follow"
input FollowIncInput {
  createdById: bigint
  followedActorId: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "follow"
input FollowInsertInput {
  actor: ActorObjRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type FollowMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "follow"
input FollowMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type FollowMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "follow"
input FollowMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "follow"
type FollowMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Follow!]!
}

# on_conflict condition type for table "follow"
input FollowOnConflict {
  constraint: FollowConstraint!
  updateColumns: [FollowUpdateColumn!]! = []
  where: FollowBoolExp
}

# Ordering options when selecting data from "follow".
input FollowOrderBy {
  actor: ActorOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  followedActorId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: follow
input FollowPkColumnsInput {
  id: bigint!
}

# select columns of table "follow"
enum FollowSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  followedActorId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId
}

# input type for updating data in table "follow"
input FollowSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type FollowStddevFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "follow"
input FollowStddevOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type FollowStddevPopFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "follow"
input FollowStddevPopOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type FollowStddevSampFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "follow"
input FollowStddevSampOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "follow"
input FollowStreamCursorInput {
  # Stream column input with initial value
  initialValue: FollowStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FollowStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  followedActorId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type FollowSumFields {
  createdById: bigint
  followedActorId: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "follow"
input FollowSumOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "follow"
enum FollowUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  followedActorId

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantScopeId
}

input FollowUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FollowIncInput

  # sets the columns of the filtered rows to the given values
  _set: FollowSetInput

  # filter the rows which have to be updated
  where: FollowBoolExp!
}

# aggregate variance on columns
type FollowVarianceFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "follow"
input FollowVarianceOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type FollowVarPopFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "follow"
input FollowVarPopOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type FollowVarSampFields {
  createdById: Float
  followedActorId: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "follow"
input FollowVarSampOrderBy {
  createdById: OrderBy
  followedActorId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "form"
type Form {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  formSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  formSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isAllowingEditingAnswers: Boolean!
  isAllowingMultipleAnswers: Boolean!
  isEnabled: Boolean!
  isLocked: Boolean!
  name: String!
  schema(
    # JSON select path
    path: String
  ): jsonb!

  # An object relationship
  team: Team

  # An object relationship
  tenantById: Tenant

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!
}

# aggregated selection of "form"
type FormAggregate {
  aggregate: FormAggregateFields
  nodes: [Form!]!
}

input FormAggregateBoolExp {
  bool_and: formAggregateBoolExpBool_and
  bool_or: formAggregateBoolExpBool_or
  count: formAggregateBoolExpCount
}

input formAggregateBoolExpBool_and {
  arguments: FormSelectColumnFormAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: FormBoolExp
  predicate: BooleanComparisonExp!
}

input formAggregateBoolExpBool_or {
  arguments: FormSelectColumnFormAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: FormBoolExp
  predicate: BooleanComparisonExp!
}

input formAggregateBoolExpCount {
  arguments: [FormSelectColumn!]
  distinct: Boolean
  filter: FormBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "form"
type FormAggregateFields {
  avg: FormAvgFields
  count(columns: [FormSelectColumn!], distinct: Boolean): Int!
  max: FormMaxFields
  min: FormMinFields
  stddev: FormStddevFields
  stddevPop: FormStddevPopFields
  stddevSamp: FormStddevSampFields
  sum: FormSumFields
  varPop: FormVarPopFields
  varSamp: FormVarSampFields
  variance: FormVarianceFields
}

# order by aggregate values of table "form"
input FormAggregateOrderBy {
  avg: FormAvgOrderBy
  count: OrderBy
  max: FormMaxOrderBy
  min: FormMinOrderBy
  stddev: FormStddevOrderBy
  stddevPop: FormStddevPopOrderBy
  stddevSamp: FormStddevSampOrderBy
  sum: FormSumOrderBy
  varPop: FormVarPopOrderBy
  varSamp: FormVarSampOrderBy
  variance: FormVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input FormAppendInput {
  schema: jsonb
}

# input type for inserting array relation for remote table "form"
input FormArrRelInsertInput {
  data: [FormInsertInput!]!

  # upsert condition
  onConflict: FormOnConflict
}

# aggregate avg on columns
type FormAvgFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "form"
input FormAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "form". All fields are combined with a logical 'AND'.
input FormBoolExp {
  _and: [FormBoolExp!]
  _not: FormBoolExp
  _or: [FormBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  formSubmissions: FormSubmissionBoolExp
  formSubmissionsAggregate: FormSubmissionAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAllowingEditingAnswers: BooleanComparisonExp
  isAllowingMultipleAnswers: BooleanComparisonExp
  isEnabled: BooleanComparisonExp
  isLocked: BooleanComparisonExp
  name: StringComparisonExp
  schema: JsonbComparisonExp
  team: TeamBoolExp
  tenantById: TenantBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "form"
enum FormConstraint {
  # unique or primary key constraint on columns "id"
  form_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input FormDeleteAtPathInput {
  schema: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input FormDeleteElemInput {
  schema: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input FormDeleteKeyInput {
  schema: String
}

# input type for incrementing numeric columns in table "form"
input FormIncInput {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "form"
input FormInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  events: EventArrRelInsertInput
  formSubmissions: FormSubmissionArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isLocked: Boolean
  name: String
  schema: jsonb
  team: TeamObjRelInsertInput
  tenantById: TenantObjRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
}

# aggregate max on columns
type FormMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "form"
input FormMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type FormMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "form"
input FormMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "form"
type FormMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Form!]!
}

# input type for inserting object relation for remote table "form"
input FormObjRelInsertInput {
  data: FormInsertInput!

  # upsert condition
  onConflict: FormOnConflict
}

# on_conflict condition type for table "form"
input FormOnConflict {
  constraint: FormConstraint!
  updateColumns: [FormUpdateColumn!]! = []
  where: FormBoolExp
}

# Ordering options when selecting data from "form".
input FormOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventsAggregate: EventAggregateOrderBy
  formSubmissionsAggregate: FormSubmissionAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAllowingEditingAnswers: OrderBy
  isAllowingMultipleAnswers: OrderBy
  isEnabled: OrderBy
  isLocked: OrderBy
  name: OrderBy
  schema: OrderBy
  team: TeamOrderBy
  tenantById: TenantOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# primary key columns input for table: form
input FormPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input FormPrependInput {
  schema: jsonb
}

# select columns of table "form"
enum FormSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isLocked

  # column name
  name

  # column name
  schema

  # column name
  tenantScopeId

  # column name
  type
}

# select "formAggregateBoolExpBool_andArgumentsColumns" columns of table "form"
enum FormSelectColumnFormAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isLocked
}

# select "formAggregateBoolExpBool_orArgumentsColumns" columns of table "form"
enum FormSelectColumnFormAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isLocked
}

# input type for updating data in table "form"
input FormSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isLocked: Boolean
  name: String
  schema: jsonb
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type FormStddevFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "form"
input FormStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type FormStddevPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "form"
input FormStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type FormStddevSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "form"
input FormStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "form"
input FormStreamCursorInput {
  # Stream column input with initial value
  initialValue: FormStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FormStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  isAllowingEditingAnswers: Boolean
  isAllowingMultipleAnswers: Boolean
  isEnabled: Boolean
  isLocked: Boolean
  name: String
  schema: jsonb
  tenantScopeId: bigint
  type: String
}

# columns and relationships of "form_submission"
type FormSubmission {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  event: Event

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An object relationship
  form: Form!
  formId: bigint!

  # An array relationship
  formSubmissionAttachments(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): [FormSubmissionAttachments!]!

  # An aggregate relationship
  formSubmissionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): FormSubmissionAttachmentsAggregate!
  hiddenAt: timestamptz
  id: bigint!
  submission(
    # JSON select path
    path: String
  ): jsonb!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "form_submission"
type FormSubmissionAggregate {
  aggregate: FormSubmissionAggregateFields
  nodes: [FormSubmission!]!
}

input FormSubmissionAggregateBoolExp {
  count: formSubmissionAggregateBoolExpCount
}

input formSubmissionAggregateBoolExpCount {
  arguments: [FormSubmissionSelectColumn!]
  distinct: Boolean
  filter: FormSubmissionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "form_submission"
type FormSubmissionAggregateFields {
  avg: FormSubmissionAvgFields
  count(columns: [FormSubmissionSelectColumn!], distinct: Boolean): Int!
  max: FormSubmissionMaxFields
  min: FormSubmissionMinFields
  stddev: FormSubmissionStddevFields
  stddevPop: FormSubmissionStddevPopFields
  stddevSamp: FormSubmissionStddevSampFields
  sum: FormSubmissionSumFields
  varPop: FormSubmissionVarPopFields
  varSamp: FormSubmissionVarSampFields
  variance: FormSubmissionVarianceFields
}

# order by aggregate values of table "form_submission"
input FormSubmissionAggregateOrderBy {
  avg: FormSubmissionAvgOrderBy
  count: OrderBy
  max: FormSubmissionMaxOrderBy
  min: FormSubmissionMinOrderBy
  stddev: FormSubmissionStddevOrderBy
  stddevPop: FormSubmissionStddevPopOrderBy
  stddevSamp: FormSubmissionStddevSampOrderBy
  sum: FormSubmissionSumOrderBy
  varPop: FormSubmissionVarPopOrderBy
  varSamp: FormSubmissionVarSampOrderBy
  variance: FormSubmissionVarianceOrderBy
}

# append existing jsonb value of filtered columns with new jsonb value
input FormSubmissionAppendInput {
  submission: jsonb
}

# input type for inserting array relation for remote table "form_submission"
input FormSubmissionArrRelInsertInput {
  data: [FormSubmissionInsertInput!]!

  # upsert condition
  onConflict: FormSubmissionOnConflict
}

# columns and relationships of "form_submission_attachments"
type FormSubmissionAttachments {
  # An object relationship
  attachment: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  formSubmission: FormSubmission!
  formSubmissionId: bigint!
}

# aggregated selection of "form_submission_attachments"
type FormSubmissionAttachmentsAggregate {
  aggregate: FormSubmissionAttachmentsAggregateFields
  nodes: [FormSubmissionAttachments!]!
}

input FormSubmissionAttachmentsAggregateBoolExp {
  count: formSubmissionAttachmentsAggregateBoolExpCount
}

input formSubmissionAttachmentsAggregateBoolExpCount {
  arguments: [FormSubmissionAttachmentsSelectColumn!]
  distinct: Boolean
  filter: FormSubmissionAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "form_submission_attachments"
type FormSubmissionAttachmentsAggregateFields {
  avg: FormSubmissionAttachmentsAvgFields
  count(columns: [FormSubmissionAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: FormSubmissionAttachmentsMaxFields
  min: FormSubmissionAttachmentsMinFields
  stddev: FormSubmissionAttachmentsStddevFields
  stddevPop: FormSubmissionAttachmentsStddevPopFields
  stddevSamp: FormSubmissionAttachmentsStddevSampFields
  sum: FormSubmissionAttachmentsSumFields
  varPop: FormSubmissionAttachmentsVarPopFields
  varSamp: FormSubmissionAttachmentsVarSampFields
  variance: FormSubmissionAttachmentsVarianceFields
}

# order by aggregate values of table "form_submission_attachments"
input FormSubmissionAttachmentsAggregateOrderBy {
  avg: FormSubmissionAttachmentsAvgOrderBy
  count: OrderBy
  max: FormSubmissionAttachmentsMaxOrderBy
  min: FormSubmissionAttachmentsMinOrderBy
  stddev: FormSubmissionAttachmentsStddevOrderBy
  stddevPop: FormSubmissionAttachmentsStddevPopOrderBy
  stddevSamp: FormSubmissionAttachmentsStddevSampOrderBy
  sum: FormSubmissionAttachmentsSumOrderBy
  varPop: FormSubmissionAttachmentsVarPopOrderBy
  varSamp: FormSubmissionAttachmentsVarSampOrderBy
  variance: FormSubmissionAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "form_submission_attachments"
input FormSubmissionAttachmentsArrRelInsertInput {
  data: [FormSubmissionAttachmentsInsertInput!]!

  # upsert condition
  onConflict: FormSubmissionAttachmentsOnConflict
}

# aggregate avg on columns
type FormSubmissionAttachmentsAvgFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by avg() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# Boolean expression to filter rows from the table "form_submission_attachments".
# All fields are combined with a logical 'AND'.
input FormSubmissionAttachmentsBoolExp {
  _and: [FormSubmissionAttachmentsBoolExp!]
  _not: FormSubmissionAttachmentsBoolExp
  _or: [FormSubmissionAttachmentsBoolExp!]
  attachment: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  formSubmission: FormSubmissionBoolExp
  formSubmissionId: BigintComparisonExp
}

# unique or primary key constraints on table "form_submission_attachments"
enum FormSubmissionAttachmentsConstraint {
  # unique or primary key constraint on columns "form_submission_id", "file_upload_id"
  form_submission_attachments_pkey
}

# input type for incrementing numeric columns in table "form_submission_attachments"
input FormSubmissionAttachmentsIncInput {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# input type for inserting data into table "form_submission_attachments"
input FormSubmissionAttachmentsInsertInput {
  attachment: FileUploadObjRelInsertInput
  fileUploadId: bigint
  formSubmission: FormSubmissionObjRelInsertInput
  formSubmissionId: bigint
}

# aggregate max on columns
type FormSubmissionAttachmentsMaxFields {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# order by max() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate min on columns
type FormSubmissionAttachmentsMinFields {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# order by min() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# response of any mutation on the table "form_submission_attachments"
type FormSubmissionAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FormSubmissionAttachments!]!
}

# on_conflict condition type for table "form_submission_attachments"
input FormSubmissionAttachmentsOnConflict {
  constraint: FormSubmissionAttachmentsConstraint!
  updateColumns: [FormSubmissionAttachmentsUpdateColumn!]! = []
  where: FormSubmissionAttachmentsBoolExp
}

# Ordering options when selecting data from "form_submission_attachments".
input FormSubmissionAttachmentsOrderBy {
  attachment: FileUploadOrderBy
  fileUploadId: OrderBy
  formSubmission: FormSubmissionOrderBy
  formSubmissionId: OrderBy
}

# primary key columns input for table: form_submission_attachments
input FormSubmissionAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  formSubmissionId: bigint!
}

# select columns of table "form_submission_attachments"
enum FormSubmissionAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  formSubmissionId
}

# input type for updating data in table "form_submission_attachments"
input FormSubmissionAttachmentsSetInput {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# aggregate stddev on columns
type FormSubmissionAttachmentsStddevFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by stddev() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate stddevPop on columns
type FormSubmissionAttachmentsStddevPopFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by stddevPop() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate stddevSamp on columns
type FormSubmissionAttachmentsStddevSampFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by stddevSamp() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# Streaming cursor of the table "form_submission_attachments"
input FormSubmissionAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: FormSubmissionAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FormSubmissionAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# aggregate sum on columns
type FormSubmissionAttachmentsSumFields {
  fileUploadId: bigint
  formSubmissionId: bigint
}

# order by sum() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# update columns of table "form_submission_attachments"
enum FormSubmissionAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  formSubmissionId
}

input FormSubmissionAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: FormSubmissionAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: FormSubmissionAttachmentsSetInput

  # filter the rows which have to be updated
  where: FormSubmissionAttachmentsBoolExp!
}

# aggregate variance on columns
type FormSubmissionAttachmentsVarianceFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by variance() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate varPop on columns
type FormSubmissionAttachmentsVarPopFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by varPop() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate varSamp on columns
type FormSubmissionAttachmentsVarSampFields {
  fileUploadId: Float
  formSubmissionId: Float
}

# order by varSamp() on columns of table "form_submission_attachments"
input FormSubmissionAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  formSubmissionId: OrderBy
}

# aggregate avg on columns
type FormSubmissionAvgFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "form_submission"
input FormSubmissionAvgOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "form_submission". All fields are combined with a logical 'AND'.
input FormSubmissionBoolExp {
  _and: [FormSubmissionBoolExp!]
  _not: FormSubmissionBoolExp
  _or: [FormSubmissionBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  form: FormBoolExp
  formId: BigintComparisonExp
  formSubmissionAttachments: FormSubmissionAttachmentsBoolExp
  formSubmissionAttachmentsAggregate: FormSubmissionAttachmentsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  submission: JsonbComparisonExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "form_submission"
enum FormSubmissionConstraint {
  # unique or primary key constraint on columns "id"
  form_submission_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input FormSubmissionDeleteAtPathInput {
  submission: [String!]
}

# delete the array element with specified index (negative integers count from the
# end). throws an error if top level container is not an array
input FormSubmissionDeleteElemInput {
  submission: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input FormSubmissionDeleteKeyInput {
  submission: String
}

# input type for incrementing numeric columns in table "form_submission"
input FormSubmissionIncInput {
  createdById: bigint
  formId: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "form_submission"
input FormSubmissionInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  event: EventObjRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  form: FormObjRelInsertInput
  formId: bigint
  formSubmissionAttachments: FormSubmissionAttachmentsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  teamJoins: TeamJoinArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type FormSubmissionMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "form_submission"
input FormSubmissionMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type FormSubmissionMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "form_submission"
input FormSubmissionMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "form_submission"
type FormSubmissionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [FormSubmission!]!
}

# input type for inserting object relation for remote table "form_submission"
input FormSubmissionObjRelInsertInput {
  data: FormSubmissionInsertInput!

  # upsert condition
  onConflict: FormSubmissionOnConflict
}

# on_conflict condition type for table "form_submission"
input FormSubmissionOnConflict {
  constraint: FormSubmissionConstraint!
  updateColumns: [FormSubmissionUpdateColumn!]! = []
  where: FormSubmissionBoolExp
}

# Ordering options when selecting data from "form_submission".
input FormSubmissionOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  event: EventOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  form: FormOrderBy
  formId: OrderBy
  formSubmissionAttachmentsAggregate: FormSubmissionAttachmentsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  submission: OrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: form_submission
input FormSubmissionPkColumnsInput {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input FormSubmissionPrependInput {
  submission: jsonb
}

# select columns of table "form_submission"
enum FormSubmissionSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formId

  # column name
  hiddenAt

  # column name
  id

  # column name
  submission

  # column name
  tenantScopeId
}

# input type for updating data in table "form_submission"
input FormSubmissionSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  tenantScopeId: bigint
}

# aggregate stddev on columns
type FormSubmissionStddevFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "form_submission"
input FormSubmissionStddevOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type FormSubmissionStddevPopFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "form_submission"
input FormSubmissionStddevPopOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type FormSubmissionStddevSampFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "form_submission"
input FormSubmissionStddevSampOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "form_submission"
input FormSubmissionStreamCursorInput {
  # Stream column input with initial value
  initialValue: FormSubmissionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input FormSubmissionStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formId: bigint
  hiddenAt: timestamptz
  id: bigint
  submission: jsonb
  tenantScopeId: bigint
}

# aggregate sum on columns
type FormSubmissionSumFields {
  createdById: bigint
  formId: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "form_submission"
input FormSubmissionSumOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "form_submission"
enum FormSubmissionUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formId

  # column name
  hiddenAt

  # column name
  id

  # column name
  submission

  # column name
  tenantScopeId
}

input FormSubmissionUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: FormSubmissionAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: FormSubmissionDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: FormSubmissionDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: FormSubmissionDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: FormSubmissionIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: FormSubmissionPrependInput

  # sets the columns of the filtered rows to the given values
  _set: FormSubmissionSetInput

  # filter the rows which have to be updated
  where: FormSubmissionBoolExp!
}

# aggregate variance on columns
type FormSubmissionVarianceFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "form_submission"
input FormSubmissionVarianceOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type FormSubmissionVarPopFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "form_submission"
input FormSubmissionVarPopOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type FormSubmissionVarSampFields {
  createdById: Float
  formId: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "form_submission"
input FormSubmissionVarSampOrderBy {
  createdById: OrderBy
  formId: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate sum on columns
type FormSumFields {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "form"
input FormSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "form"
enum FormUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAllowingEditingAnswers

  # column name
  isAllowingMultipleAnswers

  # column name
  isEnabled

  # column name
  isLocked

  # column name
  name

  # column name
  schema

  # column name
  tenantScopeId

  # column name
  type
}

input FormUpdates {
  # append existing jsonb value of filtered columns with new jsonb value
  _append: FormAppendInput

  # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  _deleteAtPath: FormDeleteAtPathInput

  # delete the array element with specified index (negative integers count from
  # the end). throws an error if top level container is not an array
  _deleteElem: FormDeleteElemInput

  # delete key/value pair or string element. key/value pairs are matched based on their key value
  _deleteKey: FormDeleteKeyInput

  # increments the numeric columns with given value of the filtered values
  _inc: FormIncInput

  # prepend existing jsonb value of filtered columns with new jsonb value
  _prepend: FormPrependInput

  # sets the columns of the filtered rows to the given values
  _set: FormSetInput

  # filter the rows which have to be updated
  where: FormBoolExp!
}

# aggregate variance on columns
type FormVarianceFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "form"
input FormVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type FormVarPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "form"
input FormVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type FormVarSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "form"
input FormVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "grant"
type Grant {
  askedAmount: Float!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  generatedDocument: FileUpload
  generatedDocumentId: bigint

  # An array relationship
  grantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  grantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!
  receivedAmount: Float!

  # An object relationship
  receivedAmountProcessed: User
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint

  # An object relationship
  signature: FileUpload
  signatureId: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "grant"
type GrantAggregate {
  aggregate: GrantAggregateFields
  nodes: [Grant!]!
}

input GrantAggregateBoolExp {
  count: grantAggregateBoolExpCount
}

input grantAggregateBoolExpCount {
  arguments: [GrantSelectColumn!]
  distinct: Boolean
  filter: GrantBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant"
type GrantAggregateFields {
  avg: GrantAvgFields
  count(columns: [GrantSelectColumn!], distinct: Boolean): Int!
  max: GrantMaxFields
  min: GrantMinFields
  stddev: GrantStddevFields
  stddevPop: GrantStddevPopFields
  stddevSamp: GrantStddevSampFields
  sum: GrantSumFields
  varPop: GrantVarPopFields
  varSamp: GrantVarSampFields
  variance: GrantVarianceFields
}

# order by aggregate values of table "grant"
input GrantAggregateOrderBy {
  avg: GrantAvgOrderBy
  count: OrderBy
  max: GrantMaxOrderBy
  min: GrantMinOrderBy
  stddev: GrantStddevOrderBy
  stddevPop: GrantStddevPopOrderBy
  stddevSamp: GrantStddevSampOrderBy
  sum: GrantSumOrderBy
  varPop: GrantVarPopOrderBy
  varSamp: GrantVarSampOrderBy
  variance: GrantVarianceOrderBy
}

# columns and relationships of "grant_allocate"
type GrantAllocate {
  askedAmount: Float!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  fileUpload: FileUpload
  generatedDocumentId: bigint

  # An object relationship
  grant: Grant!

  # An array relationship
  grantAllocateAttachments(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): [GrantAllocateAttachments!]!

  # An aggregate relationship
  grantAllocateAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): GrantAllocateAttachmentsAggregate!
  grantId: bigint!
  hiddenAt: timestamptz
  id: bigint!
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz

  # An object relationship
  receivedAmountProcessedBy: User
  receivedAmountProcessedById: bigint

  # An object relationship
  signature: FileUpload
  signatureId: bigint
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  transaction: Transaction
  transactionId: bigint
}

# aggregated selection of "grant_allocate"
type GrantAllocateAggregate {
  aggregate: GrantAllocateAggregateFields
  nodes: [GrantAllocate!]!
}

input GrantAllocateAggregateBoolExp {
  count: grantAllocateAggregateBoolExpCount
}

input grantAllocateAggregateBoolExpCount {
  arguments: [GrantAllocateSelectColumn!]
  distinct: Boolean
  filter: GrantAllocateBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_allocate"
type GrantAllocateAggregateFields {
  avg: GrantAllocateAvgFields
  count(columns: [GrantAllocateSelectColumn!], distinct: Boolean): Int!
  max: GrantAllocateMaxFields
  min: GrantAllocateMinFields
  stddev: GrantAllocateStddevFields
  stddevPop: GrantAllocateStddevPopFields
  stddevSamp: GrantAllocateStddevSampFields
  sum: GrantAllocateSumFields
  varPop: GrantAllocateVarPopFields
  varSamp: GrantAllocateVarSampFields
  variance: GrantAllocateVarianceFields
}

# order by aggregate values of table "grant_allocate"
input GrantAllocateAggregateOrderBy {
  avg: GrantAllocateAvgOrderBy
  count: OrderBy
  max: GrantAllocateMaxOrderBy
  min: GrantAllocateMinOrderBy
  stddev: GrantAllocateStddevOrderBy
  stddevPop: GrantAllocateStddevPopOrderBy
  stddevSamp: GrantAllocateStddevSampOrderBy
  sum: GrantAllocateSumOrderBy
  varPop: GrantAllocateVarPopOrderBy
  varSamp: GrantAllocateVarSampOrderBy
  variance: GrantAllocateVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_allocate"
input GrantAllocateArrRelInsertInput {
  data: [GrantAllocateInsertInput!]!

  # upsert condition
  onConflict: GrantAllocateOnConflict
}

# columns and relationships of "grant_allocate_attachments"
type GrantAllocateAttachments {
  # An object relationship
  attachment: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  grantAllocate: GrantAllocate!
  grantAllocateId: bigint!
}

# aggregated selection of "grant_allocate_attachments"
type GrantAllocateAttachmentsAggregate {
  aggregate: GrantAllocateAttachmentsAggregateFields
  nodes: [GrantAllocateAttachments!]!
}

input GrantAllocateAttachmentsAggregateBoolExp {
  count: grantAllocateAttachmentsAggregateBoolExpCount
}

input grantAllocateAttachmentsAggregateBoolExpCount {
  arguments: [GrantAllocateAttachmentsSelectColumn!]
  distinct: Boolean
  filter: GrantAllocateAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_allocate_attachments"
type GrantAllocateAttachmentsAggregateFields {
  avg: GrantAllocateAttachmentsAvgFields
  count(columns: [GrantAllocateAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: GrantAllocateAttachmentsMaxFields
  min: GrantAllocateAttachmentsMinFields
  stddev: GrantAllocateAttachmentsStddevFields
  stddevPop: GrantAllocateAttachmentsStddevPopFields
  stddevSamp: GrantAllocateAttachmentsStddevSampFields
  sum: GrantAllocateAttachmentsSumFields
  varPop: GrantAllocateAttachmentsVarPopFields
  varSamp: GrantAllocateAttachmentsVarSampFields
  variance: GrantAllocateAttachmentsVarianceFields
}

# order by aggregate values of table "grant_allocate_attachments"
input GrantAllocateAttachmentsAggregateOrderBy {
  avg: GrantAllocateAttachmentsAvgOrderBy
  count: OrderBy
  max: GrantAllocateAttachmentsMaxOrderBy
  min: GrantAllocateAttachmentsMinOrderBy
  stddev: GrantAllocateAttachmentsStddevOrderBy
  stddevPop: GrantAllocateAttachmentsStddevPopOrderBy
  stddevSamp: GrantAllocateAttachmentsStddevSampOrderBy
  sum: GrantAllocateAttachmentsSumOrderBy
  varPop: GrantAllocateAttachmentsVarPopOrderBy
  varSamp: GrantAllocateAttachmentsVarSampOrderBy
  variance: GrantAllocateAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_allocate_attachments"
input GrantAllocateAttachmentsArrRelInsertInput {
  data: [GrantAllocateAttachmentsInsertInput!]!

  # upsert condition
  onConflict: GrantAllocateAttachmentsOnConflict
}

# aggregate avg on columns
type GrantAllocateAttachmentsAvgFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by avg() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# Boolean expression to filter rows from the table "grant_allocate_attachments". All fields are combined with a logical 'AND'.
input GrantAllocateAttachmentsBoolExp {
  _and: [GrantAllocateAttachmentsBoolExp!]
  _not: GrantAllocateAttachmentsBoolExp
  _or: [GrantAllocateAttachmentsBoolExp!]
  attachment: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  grantAllocate: GrantAllocateBoolExp
  grantAllocateId: BigintComparisonExp
}

# unique or primary key constraints on table "grant_allocate_attachments"
enum GrantAllocateAttachmentsConstraint {
  # unique or primary key constraint on columns "grant_allocate_id", "file_upload_id"
  grant_allocate_attachments_pkey
}

# input type for incrementing numeric columns in table "grant_allocate_attachments"
input GrantAllocateAttachmentsIncInput {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# input type for inserting data into table "grant_allocate_attachments"
input GrantAllocateAttachmentsInsertInput {
  attachment: FileUploadObjRelInsertInput
  fileUploadId: bigint
  grantAllocate: GrantAllocateObjRelInsertInput
  grantAllocateId: bigint
}

# aggregate max on columns
type GrantAllocateAttachmentsMaxFields {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# order by max() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate min on columns
type GrantAllocateAttachmentsMinFields {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# order by min() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# response of any mutation on the table "grant_allocate_attachments"
type GrantAllocateAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantAllocateAttachments!]!
}

# on_conflict condition type for table "grant_allocate_attachments"
input GrantAllocateAttachmentsOnConflict {
  constraint: GrantAllocateAttachmentsConstraint!
  updateColumns: [GrantAllocateAttachmentsUpdateColumn!]! = []
  where: GrantAllocateAttachmentsBoolExp
}

# Ordering options when selecting data from "grant_allocate_attachments".
input GrantAllocateAttachmentsOrderBy {
  attachment: FileUploadOrderBy
  fileUploadId: OrderBy
  grantAllocate: GrantAllocateOrderBy
  grantAllocateId: OrderBy
}

# primary key columns input for table: grant_allocate_attachments
input GrantAllocateAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  grantAllocateId: bigint!
}

# select columns of table "grant_allocate_attachments"
enum GrantAllocateAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  grantAllocateId
}

# input type for updating data in table "grant_allocate_attachments"
input GrantAllocateAttachmentsSetInput {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# aggregate stddev on columns
type GrantAllocateAttachmentsStddevFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by stddev() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate stddevPop on columns
type GrantAllocateAttachmentsStddevPopFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by stddevPop() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate stddevSamp on columns
type GrantAllocateAttachmentsStddevSampFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by stddevSamp() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# Streaming cursor of the table "grant_allocate_attachments"
input GrantAllocateAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantAllocateAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantAllocateAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# aggregate sum on columns
type GrantAllocateAttachmentsSumFields {
  fileUploadId: bigint
  grantAllocateId: bigint
}

# order by sum() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# update columns of table "grant_allocate_attachments"
enum GrantAllocateAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  grantAllocateId
}

input GrantAllocateAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantAllocateAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantAllocateAttachmentsSetInput

  # filter the rows which have to be updated
  where: GrantAllocateAttachmentsBoolExp!
}

# aggregate variance on columns
type GrantAllocateAttachmentsVarianceFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by variance() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate varPop on columns
type GrantAllocateAttachmentsVarPopFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by varPop() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate varSamp on columns
type GrantAllocateAttachmentsVarSampFields {
  fileUploadId: Float
  grantAllocateId: Float
}

# order by varSamp() on columns of table "grant_allocate_attachments"
input GrantAllocateAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  grantAllocateId: OrderBy
}

# aggregate avg on columns
type GrantAllocateAvgFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by avg() on columns of table "grant_allocate"
input GrantAllocateAvgOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# Boolean expression to filter rows from the table "grant_allocate". All fields are combined with a logical 'AND'.
input GrantAllocateBoolExp {
  _and: [GrantAllocateBoolExp!]
  _not: GrantAllocateBoolExp
  _or: [GrantAllocateBoolExp!]
  askedAmount: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  fileUpload: FileUploadBoolExp
  generatedDocumentId: BigintComparisonExp
  grant: GrantBoolExp
  grantAllocateAttachments: GrantAllocateAttachmentsBoolExp
  grantAllocateAttachmentsAggregate: GrantAllocateAttachmentsAggregateBoolExp
  grantId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  receivedAmount: FloatComparisonExp
  receivedAmountProcessedAt: TimestamptzComparisonExp
  receivedAmountProcessedBy: UserBoolExp
  receivedAmountProcessedById: BigintComparisonExp
  signature: FileUploadBoolExp
  signatureId: BigintComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transaction: TransactionBoolExp
  transactionId: BigintComparisonExp
}

# unique or primary key constraints on table "grant_allocate"
enum GrantAllocateConstraint {
  # unique or primary key constraint on columns "id"
  grant_allocate_pkey
}

# input type for incrementing numeric columns in table "grant_allocate"
input GrantAllocateIncInput {
  askedAmount: Float
  createdById: bigint
  generatedDocumentId: bigint
  grantId: bigint
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedById: bigint
  signatureId: bigint
  tenantScopeId: bigint
  transactionId: bigint
}

# input type for inserting data into table "grant_allocate"
input GrantAllocateInsertInput {
  askedAmount: Float
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  fileUpload: FileUploadObjRelInsertInput
  generatedDocumentId: bigint
  grant: GrantObjRelInsertInput
  grantAllocateAttachments: GrantAllocateAttachmentsArrRelInsertInput
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedBy: UserObjRelInsertInput
  receivedAmountProcessedById: bigint
  signature: FileUploadObjRelInsertInput
  signatureId: bigint
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transaction: TransactionObjRelInsertInput
  transactionId: bigint
}

# aggregate max on columns
type GrantAllocateMaxFields {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  tenantScopeId: bigint
  transactionId: bigint
}

# order by max() on columns of table "grant_allocate"
input GrantAllocateMaxOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# aggregate min on columns
type GrantAllocateMinFields {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  tenantScopeId: bigint
  transactionId: bigint
}

# order by min() on columns of table "grant_allocate"
input GrantAllocateMinOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# response of any mutation on the table "grant_allocate"
type GrantAllocateMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantAllocate!]!
}

# input type for inserting object relation for remote table "grant_allocate"
input GrantAllocateObjRelInsertInput {
  data: GrantAllocateInsertInput!

  # upsert condition
  onConflict: GrantAllocateOnConflict
}

# on_conflict condition type for table "grant_allocate"
input GrantAllocateOnConflict {
  constraint: GrantAllocateConstraint!
  updateColumns: [GrantAllocateUpdateColumn!]! = []
  where: GrantAllocateBoolExp
}

# Ordering options when selecting data from "grant_allocate".
input GrantAllocateOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  fileUpload: FileUploadOrderBy
  generatedDocumentId: OrderBy
  grant: GrantOrderBy
  grantAllocateAttachmentsAggregate: GrantAllocateAttachmentsAggregateOrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedBy: UserOrderBy
  receivedAmountProcessedById: OrderBy
  signature: FileUploadOrderBy
  signatureId: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transaction: TransactionOrderBy
  transactionId: OrderBy
}

# primary key columns input for table: grant_allocate
input GrantAllocatePkColumnsInput {
  id: bigint!
}

# select columns of table "grant_allocate"
enum GrantAllocateSelectColumn {
  # column name
  askedAmount

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  receivedAmount

  # column name
  receivedAmountProcessedAt

  # column name
  receivedAmountProcessedById

  # column name
  signatureId

  # column name
  state

  # column name
  tenantScopeId

  # column name
  transactionId
}

# input type for updating data in table "grant_allocate"
input GrantAllocateSetInput {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  tenantScopeId: bigint
  transactionId: bigint
}

# aggregate stddev on columns
type GrantAllocateStddevFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by stddev() on columns of table "grant_allocate"
input GrantAllocateStddevOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# aggregate stddevPop on columns
type GrantAllocateStddevPopFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by stddevPop() on columns of table "grant_allocate"
input GrantAllocateStddevPopOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# aggregate stddevSamp on columns
type GrantAllocateStddevSampFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by stddevSamp() on columns of table "grant_allocate"
input GrantAllocateStddevSampOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# Streaming cursor of the table "grant_allocate"
input GrantAllocateStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantAllocateStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantAllocateStreamCursorValueInput {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  tenantScopeId: bigint
  transactionId: bigint
}

# aggregate sum on columns
type GrantAllocateSumFields {
  askedAmount: Float
  createdById: bigint
  generatedDocumentId: bigint
  grantId: bigint
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedById: bigint
  signatureId: bigint
  tenantScopeId: bigint
  transactionId: bigint
}

# order by sum() on columns of table "grant_allocate"
input GrantAllocateSumOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# update columns of table "grant_allocate"
enum GrantAllocateUpdateColumn {
  # column name
  askedAmount

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  receivedAmount

  # column name
  receivedAmountProcessedAt

  # column name
  receivedAmountProcessedById

  # column name
  signatureId

  # column name
  state

  # column name
  tenantScopeId

  # column name
  transactionId
}

input GrantAllocateUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantAllocateIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantAllocateSetInput

  # filter the rows which have to be updated
  where: GrantAllocateBoolExp!
}

# aggregate variance on columns
type GrantAllocateVarianceFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by variance() on columns of table "grant_allocate"
input GrantAllocateVarianceOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# aggregate varPop on columns
type GrantAllocateVarPopFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by varPop() on columns of table "grant_allocate"
input GrantAllocateVarPopOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# aggregate varSamp on columns
type GrantAllocateVarSampFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  grantId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  tenantScopeId: Float
  transactionId: Float
}

# order by varSamp() on columns of table "grant_allocate"
input GrantAllocateVarSampOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  grantId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  tenantScopeId: OrderBy
  transactionId: OrderBy
}

# input type for inserting array relation for remote table "grant"
input GrantArrRelInsertInput {
  data: [GrantInsertInput!]!

  # upsert condition
  onConflict: GrantOnConflict
}

# columns and relationships of "grant_attachments"
type GrantAttachments {
  # An object relationship
  attachment: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  grant: Grant!
  grantId: bigint!
}

# aggregated selection of "grant_attachments"
type GrantAttachmentsAggregate {
  aggregate: GrantAttachmentsAggregateFields
  nodes: [GrantAttachments!]!
}

input GrantAttachmentsAggregateBoolExp {
  count: grantAttachmentsAggregateBoolExpCount
}

input grantAttachmentsAggregateBoolExpCount {
  arguments: [GrantAttachmentsSelectColumn!]
  distinct: Boolean
  filter: GrantAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "grant_attachments"
type GrantAttachmentsAggregateFields {
  avg: GrantAttachmentsAvgFields
  count(columns: [GrantAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: GrantAttachmentsMaxFields
  min: GrantAttachmentsMinFields
  stddev: GrantAttachmentsStddevFields
  stddevPop: GrantAttachmentsStddevPopFields
  stddevSamp: GrantAttachmentsStddevSampFields
  sum: GrantAttachmentsSumFields
  varPop: GrantAttachmentsVarPopFields
  varSamp: GrantAttachmentsVarSampFields
  variance: GrantAttachmentsVarianceFields
}

# order by aggregate values of table "grant_attachments"
input GrantAttachmentsAggregateOrderBy {
  avg: GrantAttachmentsAvgOrderBy
  count: OrderBy
  max: GrantAttachmentsMaxOrderBy
  min: GrantAttachmentsMinOrderBy
  stddev: GrantAttachmentsStddevOrderBy
  stddevPop: GrantAttachmentsStddevPopOrderBy
  stddevSamp: GrantAttachmentsStddevSampOrderBy
  sum: GrantAttachmentsSumOrderBy
  varPop: GrantAttachmentsVarPopOrderBy
  varSamp: GrantAttachmentsVarSampOrderBy
  variance: GrantAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "grant_attachments"
input GrantAttachmentsArrRelInsertInput {
  data: [GrantAttachmentsInsertInput!]!

  # upsert condition
  onConflict: GrantAttachmentsOnConflict
}

# aggregate avg on columns
type GrantAttachmentsAvgFields {
  fileUploadId: Float
  grantId: Float
}

# order by avg() on columns of table "grant_attachments"
input GrantAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# Boolean expression to filter rows from the table "grant_attachments". All fields are combined with a logical 'AND'.
input GrantAttachmentsBoolExp {
  _and: [GrantAttachmentsBoolExp!]
  _not: GrantAttachmentsBoolExp
  _or: [GrantAttachmentsBoolExp!]
  attachment: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  grant: GrantBoolExp
  grantId: BigintComparisonExp
}

# unique or primary key constraints on table "grant_attachments"
enum GrantAttachmentsConstraint {
  # unique or primary key constraint on columns "grant_id", "file_upload_id"
  grant_attachments_pkey
}

# input type for incrementing numeric columns in table "grant_attachments"
input GrantAttachmentsIncInput {
  fileUploadId: bigint
  grantId: bigint
}

# input type for inserting data into table "grant_attachments"
input GrantAttachmentsInsertInput {
  attachment: FileUploadObjRelInsertInput
  fileUploadId: bigint
  grant: GrantObjRelInsertInput
  grantId: bigint
}

# aggregate max on columns
type GrantAttachmentsMaxFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by max() on columns of table "grant_attachments"
input GrantAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate min on columns
type GrantAttachmentsMinFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by min() on columns of table "grant_attachments"
input GrantAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# response of any mutation on the table "grant_attachments"
type GrantAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [GrantAttachments!]!
}

# on_conflict condition type for table "grant_attachments"
input GrantAttachmentsOnConflict {
  constraint: GrantAttachmentsConstraint!
  updateColumns: [GrantAttachmentsUpdateColumn!]! = []
  where: GrantAttachmentsBoolExp
}

# Ordering options when selecting data from "grant_attachments".
input GrantAttachmentsOrderBy {
  attachment: FileUploadOrderBy
  fileUploadId: OrderBy
  grant: GrantOrderBy
  grantId: OrderBy
}

# primary key columns input for table: grant_attachments
input GrantAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  grantId: bigint!
}

# select columns of table "grant_attachments"
enum GrantAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  grantId
}

# input type for updating data in table "grant_attachments"
input GrantAttachmentsSetInput {
  fileUploadId: bigint
  grantId: bigint
}

# aggregate stddev on columns
type GrantAttachmentsStddevFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddev() on columns of table "grant_attachments"
input GrantAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate stddevPop on columns
type GrantAttachmentsStddevPopFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddevPop() on columns of table "grant_attachments"
input GrantAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate stddevSamp on columns
type GrantAttachmentsStddevSampFields {
  fileUploadId: Float
  grantId: Float
}

# order by stddevSamp() on columns of table "grant_attachments"
input GrantAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# Streaming cursor of the table "grant_attachments"
input GrantAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  grantId: bigint
}

# aggregate sum on columns
type GrantAttachmentsSumFields {
  fileUploadId: bigint
  grantId: bigint
}

# order by sum() on columns of table "grant_attachments"
input GrantAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# update columns of table "grant_attachments"
enum GrantAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  grantId
}

input GrantAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantAttachmentsSetInput

  # filter the rows which have to be updated
  where: GrantAttachmentsBoolExp!
}

# aggregate variance on columns
type GrantAttachmentsVarianceFields {
  fileUploadId: Float
  grantId: Float
}

# order by variance() on columns of table "grant_attachments"
input GrantAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate varPop on columns
type GrantAttachmentsVarPopFields {
  fileUploadId: Float
  grantId: Float
}

# order by varPop() on columns of table "grant_attachments"
input GrantAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate varSamp on columns
type GrantAttachmentsVarSampFields {
  fileUploadId: Float
  grantId: Float
}

# order by varSamp() on columns of table "grant_attachments"
input GrantAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  grantId: OrderBy
}

# aggregate avg on columns
type GrantAvgFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "grant"
input GrantAvgOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "grant". All fields are combined with a logical 'AND'.
input GrantBoolExp {
  _and: [GrantBoolExp!]
  _not: GrantBoolExp
  _or: [GrantBoolExp!]
  askedAmount: FloatComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  generatedDocument: FileUploadBoolExp
  generatedDocumentId: BigintComparisonExp
  grantAllocates: GrantAllocateBoolExp
  grantAllocatesAggregate: GrantAllocateAggregateBoolExp
  grantAttachments: GrantAttachmentsBoolExp
  grantAttachmentsAggregate: GrantAttachmentsAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  receivedAmount: FloatComparisonExp
  receivedAmountProcessed: UserBoolExp
  receivedAmountProcessedAt: TimestamptzComparisonExp
  receivedAmountProcessedById: BigintComparisonExp
  signature: FileUploadBoolExp
  signatureId: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "grant"
enum GrantConstraint {
  # unique or primary key constraint on columns "id"
  grant_pkey
}

# input type for incrementing numeric columns in table "grant"
input GrantIncInput {
  askedAmount: Float
  createdById: bigint
  generatedDocumentId: bigint
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedById: bigint
  signatureId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "grant"
input GrantInsertInput {
  askedAmount: Float
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  generatedDocument: FileUploadObjRelInsertInput
  generatedDocumentId: bigint
  grantAllocates: GrantAllocateArrRelInsertInput
  grantAttachments: GrantAttachmentsArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  projects: ProjectArrRelInsertInput
  receivedAmount: Float
  receivedAmountProcessed: UserObjRelInsertInput
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signature: FileUploadObjRelInsertInput
  signatureId: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type GrantMaxFields {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "grant"
input GrantMaxOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type GrantMinFields {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "grant"
input GrantMinOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocumentId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "grant"
type GrantMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Grant!]!
}

# input type for inserting object relation for remote table "grant"
input GrantObjRelInsertInput {
  data: GrantInsertInput!

  # upsert condition
  onConflict: GrantOnConflict
}

# on_conflict condition type for table "grant"
input GrantOnConflict {
  constraint: GrantConstraint!
  updateColumns: [GrantUpdateColumn!]! = []
  where: GrantBoolExp
}

# Ordering options when selecting data from "grant".
input GrantOrderBy {
  askedAmount: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  generatedDocument: FileUploadOrderBy
  generatedDocumentId: OrderBy
  grantAllocatesAggregate: GrantAllocateAggregateOrderBy
  grantAttachmentsAggregate: GrantAttachmentsAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  projectsAggregate: ProjectAggregateOrderBy
  receivedAmount: OrderBy
  receivedAmountProcessed: UserOrderBy
  receivedAmountProcessedAt: OrderBy
  receivedAmountProcessedById: OrderBy
  signature: FileUploadOrderBy
  signatureId: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: grant
input GrantPkColumnsInput {
  id: bigint!
}

# select columns of table "grant"
enum GrantSelectColumn {
  # column name
  askedAmount

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  hiddenAt

  # column name
  id

  # column name
  receivedAmount

  # column name
  receivedAmountProcessedAt

  # column name
  receivedAmountProcessedById

  # column name
  signatureId

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId
}

# input type for updating data in table "grant"
input GrantSetInput {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type GrantStddevFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "grant"
input GrantStddevOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type GrantStddevPopFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "grant"
input GrantStddevPopOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type GrantStddevSampFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "grant"
input GrantStddevSampOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "grant"
input GrantStreamCursorInput {
  # Stream column input with initial value
  initialValue: GrantStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input GrantStreamCursorValueInput {
  askedAmount: Float
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  generatedDocumentId: bigint
  hiddenAt: timestamptz
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedAt: timestamptz
  receivedAmountProcessedById: bigint
  signatureId: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type GrantSumFields {
  askedAmount: Float
  createdById: bigint
  generatedDocumentId: bigint
  id: bigint
  receivedAmount: Float
  receivedAmountProcessedById: bigint
  signatureId: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "grant"
input GrantSumOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "grant"
enum GrantUpdateColumn {
  # column name
  askedAmount

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  generatedDocumentId

  # column name
  hiddenAt

  # column name
  id

  # column name
  receivedAmount

  # column name
  receivedAmountProcessedAt

  # column name
  receivedAmountProcessedById

  # column name
  signatureId

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId
}

input GrantUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: GrantIncInput

  # sets the columns of the filtered rows to the given values
  _set: GrantSetInput

  # filter the rows which have to be updated
  where: GrantBoolExp!
}

# aggregate variance on columns
type GrantVarianceFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "grant"
input GrantVarianceOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type GrantVarPopFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "grant"
input GrantVarPopOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type GrantVarSampFields {
  askedAmount: Float
  createdById: Float
  generatedDocumentId: Float
  id: Float
  receivedAmount: Float
  receivedAmountProcessedById: Float
  signatureId: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "grant"
input GrantVarSampOrderBy {
  askedAmount: OrderBy
  createdById: OrderBy
  generatedDocumentId: OrderBy
  id: OrderBy
  receivedAmount: OrderBy
  receivedAmountProcessedById: OrderBy
  signatureId: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input JsonbCastExp {
  String: StringComparisonExp
}

# Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
input JsonbComparisonExp {
  _cast: JsonbCastExp

  # is the column contained in the given json value
  _containedIn: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _hasKey: String

  # do all of these strings exist as top-level keys in the column
  _hasKeysAll: [String!]

  # do any of these strings exist as top-level keys in the column
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# columns and relationships of "legal_unit"
type LegalUnit {
  activityCategory: String

  # An object relationship
  actor: Actor!
  actorId: bigint!
  bankCode: Int

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  grandFundTeams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  grandFundTeamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!
  headquartersLocation: String
  headquartersNic: String
  id: bigint!
  isFranchise: Boolean!
  isFranchiseBrand: Boolean!
  legalCategory: String
  legalName: String!

  # An array relationship
  legalUnitLocations(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # An aggregate relationship
  legalUnitLocationsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): LegalUnitLocationAggregate!

  # An array relationship
  legalUnits(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # An aggregate relationship
  legalUnitsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # An object relationship
  parent: LegalUnit
  parentId: bigint
  siren: String
  slug: String!
  type: String!
  website: String
}

# aggregated selection of "legal_unit"
type LegalUnitAggregate {
  aggregate: LegalUnitAggregateFields
  nodes: [LegalUnit!]!
}

input LegalUnitAggregateBoolExp {
  bool_and: legalUnitAggregateBoolExpBool_and
  bool_or: legalUnitAggregateBoolExpBool_or
  count: legalUnitAggregateBoolExpCount
}

input legalUnitAggregateBoolExpBool_and {
  arguments: LegalUnitSelectColumnLegalUnitAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: LegalUnitBoolExp
  predicate: BooleanComparisonExp!
}

input legalUnitAggregateBoolExpBool_or {
  arguments: LegalUnitSelectColumnLegalUnitAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: LegalUnitBoolExp
  predicate: BooleanComparisonExp!
}

input legalUnitAggregateBoolExpCount {
  arguments: [LegalUnitSelectColumn!]
  distinct: Boolean
  filter: LegalUnitBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "legal_unit"
type LegalUnitAggregateFields {
  avg: LegalUnitAvgFields
  count(columns: [LegalUnitSelectColumn!], distinct: Boolean): Int!
  max: LegalUnitMaxFields
  min: LegalUnitMinFields
  stddev: LegalUnitStddevFields
  stddevPop: LegalUnitStddevPopFields
  stddevSamp: LegalUnitStddevSampFields
  sum: LegalUnitSumFields
  varPop: LegalUnitVarPopFields
  varSamp: LegalUnitVarSampFields
  variance: LegalUnitVarianceFields
}

# order by aggregate values of table "legal_unit"
input LegalUnitAggregateOrderBy {
  avg: LegalUnitAvgOrderBy
  count: OrderBy
  max: LegalUnitMaxOrderBy
  min: LegalUnitMinOrderBy
  stddev: LegalUnitStddevOrderBy
  stddevPop: LegalUnitStddevPopOrderBy
  stddevSamp: LegalUnitStddevSampOrderBy
  sum: LegalUnitSumOrderBy
  varPop: LegalUnitVarPopOrderBy
  varSamp: LegalUnitVarSampOrderBy
  variance: LegalUnitVarianceOrderBy
}

# input type for inserting array relation for remote table "legal_unit"
input LegalUnitArrRelInsertInput {
  data: [LegalUnitInsertInput!]!

  # upsert condition
  onConflict: LegalUnitOnConflict
}

# aggregate avg on columns
type LegalUnitAvgFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by avg() on columns of table "legal_unit"
input LegalUnitAvgOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# Boolean expression to filter rows from the table "legal_unit". All fields are combined with a logical 'AND'.
input LegalUnitBoolExp {
  _and: [LegalUnitBoolExp!]
  _not: LegalUnitBoolExp
  _or: [LegalUnitBoolExp!]
  activityCategory: StringComparisonExp
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  bankCode: IntComparisonExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  grandFundTeams: TeamBoolExp
  grandFundTeamsAggregate: TeamAggregateBoolExp
  headquartersLocation: StringComparisonExp
  headquartersNic: StringComparisonExp
  id: BigintComparisonExp
  isFranchise: BooleanComparisonExp
  isFranchiseBrand: BooleanComparisonExp
  legalCategory: StringComparisonExp
  legalName: StringComparisonExp
  legalUnitLocations: LegalUnitLocationBoolExp
  legalUnitLocationsAggregate: LegalUnitLocationAggregateBoolExp
  legalUnits: LegalUnitBoolExp
  legalUnitsAggregate: LegalUnitAggregateBoolExp
  parent: LegalUnitBoolExp
  parentId: BigintComparisonExp
  siren: StringComparisonExp
  slug: StringComparisonExp
  type: StringComparisonExp
  website: StringComparisonExp
}

# unique or primary key constraints on table "legal_unit"
enum LegalUnitConstraint {
  # unique or primary key constraint on columns "actor_id"
  legal_unit_actor_id_unique

  # unique or primary key constraint on columns "id"
  legal_unit_pkey

  # unique or primary key constraint on columns "slug"
  legal_unit_slug_unique
}

# input type for incrementing numeric columns in table "legal_unit"
input LegalUnitIncInput {
  actorId: bigint
  bankCode: Int
  createdById: bigint
  id: bigint
  parentId: bigint
}

# input type for inserting data into table "legal_unit"
input LegalUnitInsertInput {
  activityCategory: String
  actor: ActorObjRelInsertInput
  actorId: bigint
  bankCode: Int
  bankInfos: BankInfoArrRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  expenseItems: ExpenseItemArrRelInsertInput
  grandFundTeams: TeamArrRelInsertInput
  headquartersLocation: String
  headquartersNic: String
  id: bigint
  isFranchise: Boolean
  isFranchiseBrand: Boolean
  legalCategory: String
  legalName: String
  legalUnitLocations: LegalUnitLocationArrRelInsertInput
  legalUnits: LegalUnitArrRelInsertInput
  parent: LegalUnitObjRelInsertInput
  parentId: bigint
  siren: String
  slug: String
  type: String
  website: String
}

# columns and relationships of "legal_unit_location"
type LegalUnitLocation {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  bankLocationCode: Int
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint!
  legalName: String!

  # An object relationship
  legalUnit: LegalUnit
  legalUnitId: bigint

  # An object relationship
  location: Location
  locationId: bigint
  locationType: String!
  nic: String
  slug: String!

  # An object relationship
  user: User
}

# aggregated selection of "legal_unit_location"
type LegalUnitLocationAggregate {
  aggregate: LegalUnitLocationAggregateFields
  nodes: [LegalUnitLocation!]!
}

input LegalUnitLocationAggregateBoolExp {
  count: legalUnitLocationAggregateBoolExpCount
}

input legalUnitLocationAggregateBoolExpCount {
  arguments: [LegalUnitLocationSelectColumn!]
  distinct: Boolean
  filter: LegalUnitLocationBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "legal_unit_location"
type LegalUnitLocationAggregateFields {
  avg: LegalUnitLocationAvgFields
  count(columns: [LegalUnitLocationSelectColumn!], distinct: Boolean): Int!
  max: LegalUnitLocationMaxFields
  min: LegalUnitLocationMinFields
  stddev: LegalUnitLocationStddevFields
  stddevPop: LegalUnitLocationStddevPopFields
  stddevSamp: LegalUnitLocationStddevSampFields
  sum: LegalUnitLocationSumFields
  varPop: LegalUnitLocationVarPopFields
  varSamp: LegalUnitLocationVarSampFields
  variance: LegalUnitLocationVarianceFields
}

# order by aggregate values of table "legal_unit_location"
input LegalUnitLocationAggregateOrderBy {
  avg: LegalUnitLocationAvgOrderBy
  count: OrderBy
  max: LegalUnitLocationMaxOrderBy
  min: LegalUnitLocationMinOrderBy
  stddev: LegalUnitLocationStddevOrderBy
  stddevPop: LegalUnitLocationStddevPopOrderBy
  stddevSamp: LegalUnitLocationStddevSampOrderBy
  sum: LegalUnitLocationSumOrderBy
  varPop: LegalUnitLocationVarPopOrderBy
  varSamp: LegalUnitLocationVarSampOrderBy
  variance: LegalUnitLocationVarianceOrderBy
}

# input type for inserting array relation for remote table "legal_unit_location"
input LegalUnitLocationArrRelInsertInput {
  data: [LegalUnitLocationInsertInput!]!

  # upsert condition
  onConflict: LegalUnitLocationOnConflict
}

# aggregate avg on columns
type LegalUnitLocationAvgFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by avg() on columns of table "legal_unit_location"
input LegalUnitLocationAvgOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# Boolean expression to filter rows from the table "legal_unit_location". All fields are combined with a logical 'AND'.
input LegalUnitLocationBoolExp {
  _and: [LegalUnitLocationBoolExp!]
  _not: LegalUnitLocationBoolExp
  _or: [LegalUnitLocationBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  bankLocationCode: IntComparisonExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  differentSiren: StringComparisonExp
  id: BigintComparisonExp
  legalName: StringComparisonExp
  legalUnit: LegalUnitBoolExp
  legalUnitId: BigintComparisonExp
  location: LocationBoolExp
  locationId: BigintComparisonExp
  locationType: StringComparisonExp
  nic: StringComparisonExp
  slug: StringComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "legal_unit_location"
enum LegalUnitLocationConstraint {
  # unique or primary key constraint on columns "actor_id"
  legal_unit_location_actor_id_unique

  # unique or primary key constraint on columns "id"
  legal_unit_location_pkey

  # unique or primary key constraint on columns "slug"
  legal_unit_location_slug_unique
}

# input type for incrementing numeric columns in table "legal_unit_location"
input LegalUnitLocationIncInput {
  actorId: bigint
  bankLocationCode: Int
  createdById: bigint
  id: bigint
  legalUnitId: bigint
  locationId: bigint
}

# input type for inserting data into table "legal_unit_location"
input LegalUnitLocationInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  bankLocationCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint
  legalName: String
  legalUnit: LegalUnitObjRelInsertInput
  legalUnitId: bigint
  location: LocationObjRelInsertInput
  locationId: bigint
  locationType: String
  nic: String
  slug: String
  user: UserObjRelInsertInput
}

# aggregate max on columns
type LegalUnitLocationMaxFields {
  actorId: bigint
  bankLocationCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint
  legalName: String
  legalUnitId: bigint
  locationId: bigint
  locationType: String
  nic: String
  slug: String
}

# order by max() on columns of table "legal_unit_location"
input LegalUnitLocationMaxOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  differentSiren: OrderBy
  id: OrderBy
  legalName: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
  locationType: OrderBy
  nic: OrderBy
  slug: OrderBy
}

# aggregate min on columns
type LegalUnitLocationMinFields {
  actorId: bigint
  bankLocationCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint
  legalName: String
  legalUnitId: bigint
  locationId: bigint
  locationType: String
  nic: String
  slug: String
}

# order by min() on columns of table "legal_unit_location"
input LegalUnitLocationMinOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  differentSiren: OrderBy
  id: OrderBy
  legalName: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
  locationType: OrderBy
  nic: OrderBy
  slug: OrderBy
}

# response of any mutation on the table "legal_unit_location"
type LegalUnitLocationMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [LegalUnitLocation!]!
}

# input type for inserting object relation for remote table "legal_unit_location"
input LegalUnitLocationObjRelInsertInput {
  data: LegalUnitLocationInsertInput!

  # upsert condition
  onConflict: LegalUnitLocationOnConflict
}

# on_conflict condition type for table "legal_unit_location"
input LegalUnitLocationOnConflict {
  constraint: LegalUnitLocationConstraint!
  updateColumns: [LegalUnitLocationUpdateColumn!]! = []
  where: LegalUnitLocationBoolExp
}

# Ordering options when selecting data from "legal_unit_location".
input LegalUnitLocationOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  differentSiren: OrderBy
  id: OrderBy
  legalName: OrderBy
  legalUnit: LegalUnitOrderBy
  legalUnitId: OrderBy
  location: LocationOrderBy
  locationId: OrderBy
  locationType: OrderBy
  nic: OrderBy
  slug: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: legal_unit_location
input LegalUnitLocationPkColumnsInput {
  id: bigint!
}

# select columns of table "legal_unit_location"
enum LegalUnitLocationSelectColumn {
  # column name
  actorId

  # column name
  bankLocationCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  differentSiren

  # column name
  id

  # column name
  legalName

  # column name
  legalUnitId

  # column name
  locationId

  # column name
  locationType

  # column name
  nic

  # column name
  slug
}

# input type for updating data in table "legal_unit_location"
input LegalUnitLocationSetInput {
  actorId: bigint
  bankLocationCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint
  legalName: String
  legalUnitId: bigint
  locationId: bigint
  locationType: String
  nic: String
  slug: String
}

# aggregate stddev on columns
type LegalUnitLocationStddevFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by stddev() on columns of table "legal_unit_location"
input LegalUnitLocationStddevOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# aggregate stddevPop on columns
type LegalUnitLocationStddevPopFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by stddevPop() on columns of table "legal_unit_location"
input LegalUnitLocationStddevPopOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# aggregate stddevSamp on columns
type LegalUnitLocationStddevSampFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by stddevSamp() on columns of table "legal_unit_location"
input LegalUnitLocationStddevSampOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# Streaming cursor of the table "legal_unit_location"
input LegalUnitLocationStreamCursorInput {
  # Stream column input with initial value
  initialValue: LegalUnitLocationStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input LegalUnitLocationStreamCursorValueInput {
  actorId: bigint
  bankLocationCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  differentSiren: String
  id: bigint
  legalName: String
  legalUnitId: bigint
  locationId: bigint
  locationType: String
  nic: String
  slug: String
}

# aggregate sum on columns
type LegalUnitLocationSumFields {
  actorId: bigint
  bankLocationCode: Int
  createdById: bigint
  id: bigint
  legalUnitId: bigint
  locationId: bigint
}

# order by sum() on columns of table "legal_unit_location"
input LegalUnitLocationSumOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# update columns of table "legal_unit_location"
enum LegalUnitLocationUpdateColumn {
  # column name
  actorId

  # column name
  bankLocationCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  differentSiren

  # column name
  id

  # column name
  legalName

  # column name
  legalUnitId

  # column name
  locationId

  # column name
  locationType

  # column name
  nic

  # column name
  slug
}

input LegalUnitLocationUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: LegalUnitLocationIncInput

  # sets the columns of the filtered rows to the given values
  _set: LegalUnitLocationSetInput

  # filter the rows which have to be updated
  where: LegalUnitLocationBoolExp!
}

# aggregate variance on columns
type LegalUnitLocationVarianceFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by variance() on columns of table "legal_unit_location"
input LegalUnitLocationVarianceOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# aggregate varPop on columns
type LegalUnitLocationVarPopFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by varPop() on columns of table "legal_unit_location"
input LegalUnitLocationVarPopOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# aggregate varSamp on columns
type LegalUnitLocationVarSampFields {
  actorId: Float
  bankLocationCode: Float
  createdById: Float
  id: Float
  legalUnitId: Float
  locationId: Float
}

# order by varSamp() on columns of table "legal_unit_location"
input LegalUnitLocationVarSampOrderBy {
  actorId: OrderBy
  bankLocationCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  legalUnitId: OrderBy
  locationId: OrderBy
}

# aggregate max on columns
type LegalUnitMaxFields {
  activityCategory: String
  actorId: bigint
  bankCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  headquartersLocation: String
  headquartersNic: String
  id: bigint
  legalCategory: String
  legalName: String
  parentId: bigint
  siren: String
  slug: String
  type: String
  website: String
}

# order by max() on columns of table "legal_unit"
input LegalUnitMaxOrderBy {
  activityCategory: OrderBy
  actorId: OrderBy
  bankCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  headquartersLocation: OrderBy
  headquartersNic: OrderBy
  id: OrderBy
  legalCategory: OrderBy
  legalName: OrderBy
  parentId: OrderBy
  siren: OrderBy
  slug: OrderBy
  type: OrderBy
  website: OrderBy
}

# aggregate min on columns
type LegalUnitMinFields {
  activityCategory: String
  actorId: bigint
  bankCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  headquartersLocation: String
  headquartersNic: String
  id: bigint
  legalCategory: String
  legalName: String
  parentId: bigint
  siren: String
  slug: String
  type: String
  website: String
}

# order by min() on columns of table "legal_unit"
input LegalUnitMinOrderBy {
  activityCategory: OrderBy
  actorId: OrderBy
  bankCode: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  headquartersLocation: OrderBy
  headquartersNic: OrderBy
  id: OrderBy
  legalCategory: OrderBy
  legalName: OrderBy
  parentId: OrderBy
  siren: OrderBy
  slug: OrderBy
  type: OrderBy
  website: OrderBy
}

# response of any mutation on the table "legal_unit"
type LegalUnitMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [LegalUnit!]!
}

# input type for inserting object relation for remote table "legal_unit"
input LegalUnitObjRelInsertInput {
  data: LegalUnitInsertInput!

  # upsert condition
  onConflict: LegalUnitOnConflict
}

# on_conflict condition type for table "legal_unit"
input LegalUnitOnConflict {
  constraint: LegalUnitConstraint!
  updateColumns: [LegalUnitUpdateColumn!]! = []
  where: LegalUnitBoolExp
}

# Ordering options when selecting data from "legal_unit".
input LegalUnitOrderBy {
  activityCategory: OrderBy
  actor: ActorOrderBy
  actorId: OrderBy
  bankCode: OrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  grandFundTeamsAggregate: TeamAggregateOrderBy
  headquartersLocation: OrderBy
  headquartersNic: OrderBy
  id: OrderBy
  isFranchise: OrderBy
  isFranchiseBrand: OrderBy
  legalCategory: OrderBy
  legalName: OrderBy
  legalUnitLocationsAggregate: LegalUnitLocationAggregateOrderBy
  legalUnitsAggregate: LegalUnitAggregateOrderBy
  parent: LegalUnitOrderBy
  parentId: OrderBy
  siren: OrderBy
  slug: OrderBy
  type: OrderBy
  website: OrderBy
}

# primary key columns input for table: legal_unit
input LegalUnitPkColumnsInput {
  id: bigint!
}

# select columns of table "legal_unit"
enum LegalUnitSelectColumn {
  # column name
  activityCategory

  # column name
  actorId

  # column name
  bankCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  headquartersLocation

  # column name
  headquartersNic

  # column name
  id

  # column name
  isFranchise

  # column name
  isFranchiseBrand

  # column name
  legalCategory

  # column name
  legalName

  # column name
  parentId

  # column name
  siren

  # column name
  slug

  # column name
  type

  # column name
  website
}

# select "legalUnitAggregateBoolExpBool_andArgumentsColumns" columns of table "legal_unit"
enum LegalUnitSelectColumnLegalUnitAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isFranchise

  # column name
  isFranchiseBrand
}

# select "legalUnitAggregateBoolExpBool_orArgumentsColumns" columns of table "legal_unit"
enum LegalUnitSelectColumnLegalUnitAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isFranchise

  # column name
  isFranchiseBrand
}

# input type for updating data in table "legal_unit"
input LegalUnitSetInput {
  activityCategory: String
  actorId: bigint
  bankCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  headquartersLocation: String
  headquartersNic: String
  id: bigint
  isFranchise: Boolean
  isFranchiseBrand: Boolean
  legalCategory: String
  legalName: String
  parentId: bigint
  siren: String
  slug: String
  type: String
  website: String
}

# aggregate stddev on columns
type LegalUnitStddevFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by stddev() on columns of table "legal_unit"
input LegalUnitStddevOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# aggregate stddevPop on columns
type LegalUnitStddevPopFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by stddevPop() on columns of table "legal_unit"
input LegalUnitStddevPopOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# aggregate stddevSamp on columns
type LegalUnitStddevSampFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by stddevSamp() on columns of table "legal_unit"
input LegalUnitStddevSampOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# Streaming cursor of the table "legal_unit"
input LegalUnitStreamCursorInput {
  # Stream column input with initial value
  initialValue: LegalUnitStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input LegalUnitStreamCursorValueInput {
  activityCategory: String
  actorId: bigint
  bankCode: Int
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  headquartersLocation: String
  headquartersNic: String
  id: bigint
  isFranchise: Boolean
  isFranchiseBrand: Boolean
  legalCategory: String
  legalName: String
  parentId: bigint
  siren: String
  slug: String
  type: String
  website: String
}

# aggregate sum on columns
type LegalUnitSumFields {
  actorId: bigint
  bankCode: Int
  createdById: bigint
  id: bigint
  parentId: bigint
}

# order by sum() on columns of table "legal_unit"
input LegalUnitSumOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# update columns of table "legal_unit"
enum LegalUnitUpdateColumn {
  # column name
  activityCategory

  # column name
  actorId

  # column name
  bankCode

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  headquartersLocation

  # column name
  headquartersNic

  # column name
  id

  # column name
  isFranchise

  # column name
  isFranchiseBrand

  # column name
  legalCategory

  # column name
  legalName

  # column name
  parentId

  # column name
  siren

  # column name
  slug

  # column name
  type

  # column name
  website
}

input LegalUnitUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: LegalUnitIncInput

  # sets the columns of the filtered rows to the given values
  _set: LegalUnitSetInput

  # filter the rows which have to be updated
  where: LegalUnitBoolExp!
}

# aggregate variance on columns
type LegalUnitVarianceFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by variance() on columns of table "legal_unit"
input LegalUnitVarianceOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# aggregate varPop on columns
type LegalUnitVarPopFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by varPop() on columns of table "legal_unit"
input LegalUnitVarPopOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# aggregate varSamp on columns
type LegalUnitVarSampFields {
  actorId: Float
  bankCode: Float
  createdById: Float
  id: Float
  parentId: Float
}

# order by varSamp() on columns of table "legal_unit"
input LegalUnitVarSampOrderBy {
  actorId: OrderBy
  bankCode: OrderBy
  createdById: OrderBy
  id: OrderBy
  parentId: OrderBy
}

# columns and relationships of "location"
type Location {
  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An object relationship
  address: Address
  addressId: bigint

  # An array relationship
  campuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  campusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  details: String!

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  legalUnitLocations(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # An aggregate relationship
  legalUnitLocationsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): LegalUnitLocationAggregate!
  link: String!

  # An array relationship
  locationImages(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): [LocationImages!]!

  # An aggregate relationship
  locationImagesAggregate(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): LocationImagesAggregate!
  name: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  transactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!
  type: String!

  # An object relationship
  user: User
}

# aggregated selection of "location"
type LocationAggregate {
  aggregate: LocationAggregateFields
  nodes: [Location!]!
}

input LocationAggregateBoolExp {
  count: locationAggregateBoolExpCount
}

input locationAggregateBoolExpCount {
  arguments: [LocationSelectColumn!]
  distinct: Boolean
  filter: LocationBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "location"
type LocationAggregateFields {
  avg: LocationAvgFields
  count(columns: [LocationSelectColumn!], distinct: Boolean): Int!
  max: LocationMaxFields
  min: LocationMinFields
  stddev: LocationStddevFields
  stddevPop: LocationStddevPopFields
  stddevSamp: LocationStddevSampFields
  sum: LocationSumFields
  varPop: LocationVarPopFields
  varSamp: LocationVarSampFields
  variance: LocationVarianceFields
}

# order by aggregate values of table "location"
input LocationAggregateOrderBy {
  avg: LocationAvgOrderBy
  count: OrderBy
  max: LocationMaxOrderBy
  min: LocationMinOrderBy
  stddev: LocationStddevOrderBy
  stddevPop: LocationStddevPopOrderBy
  stddevSamp: LocationStddevSampOrderBy
  sum: LocationSumOrderBy
  varPop: LocationVarPopOrderBy
  varSamp: LocationVarSampOrderBy
  variance: LocationVarianceOrderBy
}

# input type for inserting array relation for remote table "location"
input LocationArrRelInsertInput {
  data: [LocationInsertInput!]!

  # upsert condition
  onConflict: LocationOnConflict
}

# aggregate avg on columns
type LocationAvgFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "location"
input LocationAvgOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "location". All fields are combined with a logical 'AND'.
input LocationBoolExp {
  _and: [LocationBoolExp!]
  _not: LocationBoolExp
  _or: [LocationBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  address: AddressBoolExp
  addressId: BigintComparisonExp
  campuses: CampusBoolExp
  campusesAggregate: CampusAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  details: StringComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  legalUnitLocations: LegalUnitLocationBoolExp
  legalUnitLocationsAggregate: LegalUnitLocationAggregateBoolExp
  link: StringComparisonExp
  locationImages: LocationImagesBoolExp
  locationImagesAggregate: LocationImagesAggregateBoolExp
  name: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactions: TransactionBoolExp
  transactionsAggregate: TransactionAggregateBoolExp
  type: StringComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "location"
enum LocationConstraint {
  # unique or primary key constraint on columns "id"
  location_pkey
}

# columns and relationships of "location_images"
type LocationImages {
  # An object relationship
  fileUpload: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  location: Location!
  locationId: bigint!
}

# aggregated selection of "location_images"
type LocationImagesAggregate {
  aggregate: LocationImagesAggregateFields
  nodes: [LocationImages!]!
}

input LocationImagesAggregateBoolExp {
  count: locationImagesAggregateBoolExpCount
}

input locationImagesAggregateBoolExpCount {
  arguments: [LocationImagesSelectColumn!]
  distinct: Boolean
  filter: LocationImagesBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "location_images"
type LocationImagesAggregateFields {
  avg: LocationImagesAvgFields
  count(columns: [LocationImagesSelectColumn!], distinct: Boolean): Int!
  max: LocationImagesMaxFields
  min: LocationImagesMinFields
  stddev: LocationImagesStddevFields
  stddevPop: LocationImagesStddevPopFields
  stddevSamp: LocationImagesStddevSampFields
  sum: LocationImagesSumFields
  varPop: LocationImagesVarPopFields
  varSamp: LocationImagesVarSampFields
  variance: LocationImagesVarianceFields
}

# order by aggregate values of table "location_images"
input LocationImagesAggregateOrderBy {
  avg: LocationImagesAvgOrderBy
  count: OrderBy
  max: LocationImagesMaxOrderBy
  min: LocationImagesMinOrderBy
  stddev: LocationImagesStddevOrderBy
  stddevPop: LocationImagesStddevPopOrderBy
  stddevSamp: LocationImagesStddevSampOrderBy
  sum: LocationImagesSumOrderBy
  varPop: LocationImagesVarPopOrderBy
  varSamp: LocationImagesVarSampOrderBy
  variance: LocationImagesVarianceOrderBy
}

# input type for inserting array relation for remote table "location_images"
input LocationImagesArrRelInsertInput {
  data: [LocationImagesInsertInput!]!

  # upsert condition
  onConflict: LocationImagesOnConflict
}

# aggregate avg on columns
type LocationImagesAvgFields {
  fileUploadId: Float
  locationId: Float
}

# order by avg() on columns of table "location_images"
input LocationImagesAvgOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# Boolean expression to filter rows from the table "location_images". All fields are combined with a logical 'AND'.
input LocationImagesBoolExp {
  _and: [LocationImagesBoolExp!]
  _not: LocationImagesBoolExp
  _or: [LocationImagesBoolExp!]
  fileUpload: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  location: LocationBoolExp
  locationId: BigintComparisonExp
}

# unique or primary key constraints on table "location_images"
enum LocationImagesConstraint {
  # unique or primary key constraint on columns "location_id", "file_upload_id"
  location_images_pkey
}

# input type for incrementing numeric columns in table "location_images"
input LocationImagesIncInput {
  fileUploadId: bigint
  locationId: bigint
}

# input type for inserting data into table "location_images"
input LocationImagesInsertInput {
  fileUpload: FileUploadObjRelInsertInput
  fileUploadId: bigint
  location: LocationObjRelInsertInput
  locationId: bigint
}

# aggregate max on columns
type LocationImagesMaxFields {
  fileUploadId: bigint
  locationId: bigint
}

# order by max() on columns of table "location_images"
input LocationImagesMaxOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# aggregate min on columns
type LocationImagesMinFields {
  fileUploadId: bigint
  locationId: bigint
}

# order by min() on columns of table "location_images"
input LocationImagesMinOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# response of any mutation on the table "location_images"
type LocationImagesMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [LocationImages!]!
}

# on_conflict condition type for table "location_images"
input LocationImagesOnConflict {
  constraint: LocationImagesConstraint!
  updateColumns: [LocationImagesUpdateColumn!]! = []
  where: LocationImagesBoolExp
}

# Ordering options when selecting data from "location_images".
input LocationImagesOrderBy {
  fileUpload: FileUploadOrderBy
  fileUploadId: OrderBy
  location: LocationOrderBy
  locationId: OrderBy
}

# primary key columns input for table: location_images
input LocationImagesPkColumnsInput {
  fileUploadId: bigint!
  locationId: bigint!
}

# select columns of table "location_images"
enum LocationImagesSelectColumn {
  # column name
  fileUploadId

  # column name
  locationId
}

# input type for updating data in table "location_images"
input LocationImagesSetInput {
  fileUploadId: bigint
  locationId: bigint
}

# aggregate stddev on columns
type LocationImagesStddevFields {
  fileUploadId: Float
  locationId: Float
}

# order by stddev() on columns of table "location_images"
input LocationImagesStddevOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# aggregate stddevPop on columns
type LocationImagesStddevPopFields {
  fileUploadId: Float
  locationId: Float
}

# order by stddevPop() on columns of table "location_images"
input LocationImagesStddevPopOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# aggregate stddevSamp on columns
type LocationImagesStddevSampFields {
  fileUploadId: Float
  locationId: Float
}

# order by stddevSamp() on columns of table "location_images"
input LocationImagesStddevSampOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# Streaming cursor of the table "location_images"
input LocationImagesStreamCursorInput {
  # Stream column input with initial value
  initialValue: LocationImagesStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input LocationImagesStreamCursorValueInput {
  fileUploadId: bigint
  locationId: bigint
}

# aggregate sum on columns
type LocationImagesSumFields {
  fileUploadId: bigint
  locationId: bigint
}

# order by sum() on columns of table "location_images"
input LocationImagesSumOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# update columns of table "location_images"
enum LocationImagesUpdateColumn {
  # column name
  fileUploadId

  # column name
  locationId
}

input LocationImagesUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: LocationImagesIncInput

  # sets the columns of the filtered rows to the given values
  _set: LocationImagesSetInput

  # filter the rows which have to be updated
  where: LocationImagesBoolExp!
}

# aggregate variance on columns
type LocationImagesVarianceFields {
  fileUploadId: Float
  locationId: Float
}

# order by variance() on columns of table "location_images"
input LocationImagesVarianceOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# aggregate varPop on columns
type LocationImagesVarPopFields {
  fileUploadId: Float
  locationId: Float
}

# order by varPop() on columns of table "location_images"
input LocationImagesVarPopOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# aggregate varSamp on columns
type LocationImagesVarSampFields {
  fileUploadId: Float
  locationId: Float
}

# order by varSamp() on columns of table "location_images"
input LocationImagesVarSampOrderBy {
  fileUploadId: OrderBy
  locationId: OrderBy
}

# input type for incrementing numeric columns in table "location"
input LocationIncInput {
  actorId: bigint
  addressId: bigint
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "location"
input LocationInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  address: AddressObjRelInsertInput
  addressId: bigint
  campuses: CampusArrRelInsertInput
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  details: String
  events: EventArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  legalUnitLocations: LegalUnitLocationArrRelInsertInput
  link: String
  locationImages: LocationImagesArrRelInsertInput
  name: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactions: TransactionArrRelInsertInput
  type: String
  user: UserObjRelInsertInput
}

# aggregate max on columns
type LocationMaxFields {
  actorId: bigint
  addressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  details: String
  hiddenAt: timestamptz
  id: bigint
  link: String
  name: String
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "location"
input LocationMaxOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  details: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  link: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type LocationMinFields {
  actorId: bigint
  addressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  details: String
  hiddenAt: timestamptz
  id: bigint
  link: String
  name: String
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "location"
input LocationMinOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  details: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  link: OrderBy
  name: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "location"
type LocationMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Location!]!
}

# input type for inserting object relation for remote table "location"
input LocationObjRelInsertInput {
  data: LocationInsertInput!

  # upsert condition
  onConflict: LocationOnConflict
}

# on_conflict condition type for table "location"
input LocationOnConflict {
  constraint: LocationConstraint!
  updateColumns: [LocationUpdateColumn!]! = []
  where: LocationBoolExp
}

# Ordering options when selecting data from "location".
input LocationOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  address: AddressOrderBy
  addressId: OrderBy
  campusesAggregate: CampusAggregateOrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  details: OrderBy
  eventsAggregate: EventAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  legalUnitLocationsAggregate: LegalUnitLocationAggregateOrderBy
  link: OrderBy
  locationImagesAggregate: LocationImagesAggregateOrderBy
  name: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionsAggregate: TransactionAggregateOrderBy
  type: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: location
input LocationPkColumnsInput {
  id: bigint!
}

# select columns of table "location"
enum LocationSelectColumn {
  # column name
  actorId

  # column name
  addressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  details

  # column name
  hiddenAt

  # column name
  id

  # column name
  link

  # column name
  name

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "location"
input LocationSetInput {
  actorId: bigint
  addressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  details: String
  hiddenAt: timestamptz
  id: bigint
  link: String
  name: String
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type LocationStddevFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "location"
input LocationStddevOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type LocationStddevPopFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "location"
input LocationStddevPopOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type LocationStddevSampFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "location"
input LocationStddevSampOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "location"
input LocationStreamCursorInput {
  # Stream column input with initial value
  initialValue: LocationStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input LocationStreamCursorValueInput {
  actorId: bigint
  addressId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  details: String
  hiddenAt: timestamptz
  id: bigint
  link: String
  name: String
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type LocationSumFields {
  actorId: bigint
  addressId: bigint
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "location"
input LocationSumOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "location"
enum LocationUpdateColumn {
  # column name
  actorId

  # column name
  addressId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  details

  # column name
  hiddenAt

  # column name
  id

  # column name
  link

  # column name
  name

  # column name
  tenantScopeId

  # column name
  type
}

input LocationUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: LocationIncInput

  # sets the columns of the filtered rows to the given values
  _set: LocationSetInput

  # filter the rows which have to be updated
  where: LocationBoolExp!
}

# aggregate variance on columns
type LocationVarianceFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "location"
input LocationVarianceOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type LocationVarPopFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "location"
input LocationVarPopOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type LocationVarSampFields {
  actorId: Float
  addressId: Float
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "location"
input LocationVarSampOrderBy {
  actorId: OrderBy
  addressId: OrderBy
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "mission"
type Mission {
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  eventManageId: bigint

  # An object relationship
  eventOrganize: EventOrganize
  hiddenAt: timestamptz
  id: bigint!
  isAutoAcceptingMembers: Boolean!
  isTemplate: Boolean!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!
  name: String!
  pointsMaximum: smallint!
  pointsMinimum: smallint!

  # An object relationship
  project: Project
  projectId: bigint
  quantity: smallint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "mission"
type MissionAggregate {
  aggregate: MissionAggregateFields
  nodes: [Mission!]!
}

input MissionAggregateBoolExp {
  bool_and: missionAggregateBoolExpBool_and
  bool_or: missionAggregateBoolExpBool_or
  count: missionAggregateBoolExpCount
}

input missionAggregateBoolExpBool_and {
  arguments: MissionSelectColumnMissionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: MissionBoolExp
  predicate: BooleanComparisonExp!
}

input missionAggregateBoolExpBool_or {
  arguments: MissionSelectColumnMissionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: MissionBoolExp
  predicate: BooleanComparisonExp!
}

input missionAggregateBoolExpCount {
  arguments: [MissionSelectColumn!]
  distinct: Boolean
  filter: MissionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "mission"
type MissionAggregateFields {
  avg: MissionAvgFields
  count(columns: [MissionSelectColumn!], distinct: Boolean): Int!
  max: MissionMaxFields
  min: MissionMinFields
  stddev: MissionStddevFields
  stddevPop: MissionStddevPopFields
  stddevSamp: MissionStddevSampFields
  sum: MissionSumFields
  varPop: MissionVarPopFields
  varSamp: MissionVarSampFields
  variance: MissionVarianceFields
}

# order by aggregate values of table "mission"
input MissionAggregateOrderBy {
  avg: MissionAvgOrderBy
  count: OrderBy
  max: MissionMaxOrderBy
  min: MissionMinOrderBy
  stddev: MissionStddevOrderBy
  stddevPop: MissionStddevPopOrderBy
  stddevSamp: MissionStddevSampOrderBy
  sum: MissionSumOrderBy
  varPop: MissionVarPopOrderBy
  varSamp: MissionVarSampOrderBy
  variance: MissionVarianceOrderBy
}

# input type for inserting array relation for remote table "mission"
input MissionArrRelInsertInput {
  data: [MissionInsertInput!]!

  # upsert condition
  onConflict: MissionOnConflict
}

# aggregate avg on columns
type MissionAvgFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "mission"
input MissionAvgOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "mission". All fields are combined with a logical 'AND'.
input MissionBoolExp {
  _and: [MissionBoolExp!]
  _not: MissionBoolExp
  _or: [MissionBoolExp!]
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  eventManageId: BigintComparisonExp
  eventOrganize: EventOrganizeBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isAutoAcceptingMembers: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  name: StringComparisonExp
  pointsMaximum: SmallintComparisonExp
  pointsMinimum: SmallintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  quantity: SmallintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "mission"
enum MissionConstraint {
  # unique or primary key constraint on columns "id"
  mission_pkey
}

# input type for incrementing numeric columns in table "mission"
input MissionIncInput {
  createdById: bigint
  eventManageId: bigint
  id: bigint
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "mission"
input MissionInsertInput {
  color: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  eventOrganize: EventOrganizeObjRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  missionJoins: MissionJoinArrRelInsertInput
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  project: ProjectObjRelInsertInput
  projectId: bigint
  quantity: smallint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# columns and relationships of "mission_join"
type MissionJoin {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  eventJoin: EventJoin
  eventJoinId: bigint

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  joinedBy: User!
  joinedById: bigint!

  # An object relationship
  mission: Mission!
  missionId: bigint!
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz

  # An object relationship
  processedBy: User
  processedById: bigint

  # An object relationship
  project: Project
  projectId: bigint
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  user: User
}

# aggregated selection of "mission_join"
type MissionJoinAggregate {
  aggregate: MissionJoinAggregateFields
  nodes: [MissionJoin!]!
}

input MissionJoinAggregateBoolExp {
  count: missionJoinAggregateBoolExpCount
}

input missionJoinAggregateBoolExpCount {
  arguments: [MissionJoinSelectColumn!]
  distinct: Boolean
  filter: MissionJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "mission_join"
type MissionJoinAggregateFields {
  avg: MissionJoinAvgFields
  count(columns: [MissionJoinSelectColumn!], distinct: Boolean): Int!
  max: MissionJoinMaxFields
  min: MissionJoinMinFields
  stddev: MissionJoinStddevFields
  stddevPop: MissionJoinStddevPopFields
  stddevSamp: MissionJoinStddevSampFields
  sum: MissionJoinSumFields
  varPop: MissionJoinVarPopFields
  varSamp: MissionJoinVarSampFields
  variance: MissionJoinVarianceFields
}

# order by aggregate values of table "mission_join"
input MissionJoinAggregateOrderBy {
  avg: MissionJoinAvgOrderBy
  count: OrderBy
  max: MissionJoinMaxOrderBy
  min: MissionJoinMinOrderBy
  stddev: MissionJoinStddevOrderBy
  stddevPop: MissionJoinStddevPopOrderBy
  stddevSamp: MissionJoinStddevSampOrderBy
  sum: MissionJoinSumOrderBy
  varPop: MissionJoinVarPopOrderBy
  varSamp: MissionJoinVarSampOrderBy
  variance: MissionJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "mission_join"
input MissionJoinArrRelInsertInput {
  data: [MissionJoinInsertInput!]!

  # upsert condition
  onConflict: MissionJoinOnConflict
}

# aggregate avg on columns
type MissionJoinAvgFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "mission_join"
input MissionJoinAvgOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "mission_join". All fields are combined with a logical 'AND'.
input MissionJoinBoolExp {
  _and: [MissionJoinBoolExp!]
  _not: MissionJoinBoolExp
  _or: [MissionJoinBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventJoin: EventJoinBoolExp
  eventJoinId: BigintComparisonExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  joinedBy: UserBoolExp
  joinedById: BigintComparisonExp
  mission: MissionBoolExp
  missionId: BigintComparisonExp
  points: SmallintComparisonExp
  pointsProcessedAt: TimestamptzComparisonExp
  pointsProcessedById: BigintComparisonExp
  processedAt: TimestamptzComparisonExp
  processedBy: UserBoolExp
  processedById: BigintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "mission_join"
enum MissionJoinConstraint {
  # unique or primary key constraint on columns "event_join_id"
  mission_join_event_join_id_unique

  # unique or primary key constraint on columns "id"
  mission_join_pkey
}

# input type for incrementing numeric columns in table "mission_join"
input MissionJoinIncInput {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedById: bigint
  processedById: bigint
  projectId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "mission_join"
input MissionJoinInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventJoin: EventJoinObjRelInsertInput
  eventJoinId: bigint
  eventJoins: EventJoinArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  joinedBy: UserObjRelInsertInput
  joinedById: bigint
  mission: MissionObjRelInsertInput
  missionId: bigint
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz
  processedBy: UserObjRelInsertInput
  processedById: bigint
  project: ProjectObjRelInsertInput
  projectId: bigint
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
}

# aggregate max on columns
type MissionJoinMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz
  processedById: bigint
  projectId: bigint
  state: String
  tenantScopeId: bigint
}

# order by max() on columns of table "mission_join"
input MissionJoinMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedById: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type MissionJoinMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz
  processedById: bigint
  projectId: bigint
  state: String
  tenantScopeId: bigint
}

# order by min() on columns of table "mission_join"
input MissionJoinMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoinId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedById: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "mission_join"
type MissionJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [MissionJoin!]!
}

# input type for inserting object relation for remote table "mission_join"
input MissionJoinObjRelInsertInput {
  data: MissionJoinInsertInput!

  # upsert condition
  onConflict: MissionJoinOnConflict
}

# on_conflict condition type for table "mission_join"
input MissionJoinOnConflict {
  constraint: MissionJoinConstraint!
  updateColumns: [MissionJoinUpdateColumn!]! = []
  where: MissionJoinBoolExp
}

# Ordering options when selecting data from "mission_join".
input MissionJoinOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventJoin: EventJoinOrderBy
  eventJoinId: OrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedBy: UserOrderBy
  joinedById: OrderBy
  mission: MissionOrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedAt: OrderBy
  pointsProcessedById: OrderBy
  processedAt: OrderBy
  processedBy: UserOrderBy
  processedById: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: mission_join
input MissionJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "mission_join"
enum MissionJoinSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedById

  # column name
  missionId

  # column name
  points

  # column name
  pointsProcessedAt

  # column name
  pointsProcessedById

  # column name
  processedAt

  # column name
  processedById

  # column name
  projectId

  # column name
  state

  # column name
  tenantScopeId
}

# input type for updating data in table "mission_join"
input MissionJoinSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz
  processedById: bigint
  projectId: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type MissionJoinStddevFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "mission_join"
input MissionJoinStddevOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type MissionJoinStddevPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "mission_join"
input MissionJoinStddevPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type MissionJoinStddevSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "mission_join"
input MissionJoinStddevSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "mission_join"
input MissionJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: MissionJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input MissionJoinStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventJoinId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedAt: timestamptz
  pointsProcessedById: bigint
  processedAt: timestamptz
  processedById: bigint
  projectId: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type MissionJoinSumFields {
  createdById: bigint
  eventJoinId: bigint
  id: bigint
  joinedById: bigint
  missionId: bigint
  points: smallint
  pointsProcessedById: bigint
  processedById: bigint
  projectId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "mission_join"
input MissionJoinSumOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "mission_join"
enum MissionJoinUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventJoinId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedById

  # column name
  missionId

  # column name
  points

  # column name
  pointsProcessedAt

  # column name
  pointsProcessedById

  # column name
  processedAt

  # column name
  processedById

  # column name
  projectId

  # column name
  state

  # column name
  tenantScopeId
}

input MissionJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: MissionJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: MissionJoinSetInput

  # filter the rows which have to be updated
  where: MissionJoinBoolExp!
}

# aggregate variance on columns
type MissionJoinVarianceFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "mission_join"
input MissionJoinVarianceOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type MissionJoinVarPopFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "mission_join"
input MissionJoinVarPopOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type MissionJoinVarSampFields {
  createdById: Float
  eventJoinId: Float
  id: Float
  joinedById: Float
  missionId: Float
  points: Float
  pointsProcessedById: Float
  processedById: Float
  projectId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "mission_join"
input MissionJoinVarSampOrderBy {
  createdById: OrderBy
  eventJoinId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  missionId: OrderBy
  points: OrderBy
  pointsProcessedById: OrderBy
  processedById: OrderBy
  projectId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate max on columns
type MissionMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "mission"
input MissionMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManageId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type MissionMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "mission"
input MissionMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManageId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "mission"
type MissionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Mission!]!
}

# input type for inserting object relation for remote table "mission"
input MissionObjRelInsertInput {
  data: MissionInsertInput!

  # upsert condition
  onConflict: MissionOnConflict
}

# on_conflict condition type for table "mission"
input MissionOnConflict {
  constraint: MissionConstraint!
  updateColumns: [MissionUpdateColumn!]! = []
  where: MissionBoolExp
}

# Ordering options when selecting data from "mission".
input MissionOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventManageId: OrderBy
  eventOrganize: EventOrganizeOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isAutoAcceptingMembers: OrderBy
  isTemplate: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  name: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  quantity: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: mission
input MissionPkColumnsInput {
  id: bigint!
}

# select columns of table "mission"
enum MissionSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventManageId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate

  # column name
  name

  # column name
  pointsMaximum

  # column name
  pointsMinimum

  # column name
  projectId

  # column name
  quantity

  # column name
  teamId

  # column name
  tenantScopeId
}

# select "missionAggregateBoolExpBool_andArgumentsColumns" columns of table "mission"
enum MissionSelectColumnMissionAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate
}

# select "missionAggregateBoolExpBool_orArgumentsColumns" columns of table "mission"
enum MissionSelectColumnMissionAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate
}

# input type for updating data in table "mission"
input MissionSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type MissionStddevFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "mission"
input MissionStddevOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type MissionStddevPopFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "mission"
input MissionStddevPopOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type MissionStddevSampFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "mission"
input MissionStddevSampOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "mission"
input MissionStreamCursorInput {
  # Stream column input with initial value
  initialValue: MissionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input MissionStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventManageId: bigint
  hiddenAt: timestamptz
  id: bigint
  isAutoAcceptingMembers: Boolean
  isTemplate: Boolean
  name: String
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type MissionSumFields {
  createdById: bigint
  eventManageId: bigint
  id: bigint
  pointsMaximum: smallint
  pointsMinimum: smallint
  projectId: bigint
  quantity: smallint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "mission"
input MissionSumOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "mission"
enum MissionUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventManageId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isAutoAcceptingMembers

  # column name
  isTemplate

  # column name
  name

  # column name
  pointsMaximum

  # column name
  pointsMinimum

  # column name
  projectId

  # column name
  quantity

  # column name
  teamId

  # column name
  tenantScopeId
}

input MissionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: MissionIncInput

  # sets the columns of the filtered rows to the given values
  _set: MissionSetInput

  # filter the rows which have to be updated
  where: MissionBoolExp!
}

# aggregate variance on columns
type MissionVarianceFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "mission"
input MissionVarianceOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type MissionVarPopFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "mission"
input MissionVarPopOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type MissionVarSampFields {
  createdById: Float
  eventManageId: Float
  id: Float
  pointsMaximum: Float
  pointsMinimum: Float
  projectId: Float
  quantity: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "mission"
input MissionVarSampOrderBy {
  createdById: OrderBy
  eventManageId: OrderBy
  id: OrderBy
  pointsMaximum: OrderBy
  pointsMinimum: OrderBy
  projectId: OrderBy
  quantity: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# mutation root
type Mutation {
  # delete data from the table: "action"
  deleteAction(
    # filter the rows which have to be deleted
    where: ActionBoolExp!
  ): ActionMutationResponse

  # delete single row from the table: "action"
  deleteActionByPk(id: bigint!): Action

  # delete data from the table: "actor"
  deleteActor(
    # filter the rows which have to be deleted
    where: ActorBoolExp!
  ): ActorMutationResponse

  # delete single row from the table: "actor"
  deleteActorByPk(id: bigint!): Actor

  # delete data from the table: "actor_image"
  deleteActorImage(
    # filter the rows which have to be deleted
    where: ActorImageBoolExp!
  ): ActorImageMutationResponse

  # delete single row from the table: "actor_image"
  deleteActorImageByPk(id: bigint!): ActorImage

  # delete data from the table: "actor_tag"
  deleteActorTag(
    # filter the rows which have to be deleted
    where: ActorTagBoolExp!
  ): ActorTagMutationResponse

  # delete single row from the table: "actor_tag"
  deleteActorTagByPk(id: bigint!): ActorTag

  # delete data from the table: "address"
  deleteAddress(
    # filter the rows which have to be deleted
    where: AddressBoolExp!
  ): AddressMutationResponse

  # delete single row from the table: "address"
  deleteAddressByPk(id: bigint!): Address

  # delete data from the table: "bank_account"
  deleteBankAccount(
    # filter the rows which have to be deleted
    where: BankAccountBoolExp!
  ): BankAccountMutationResponse

  # delete single row from the table: "bank_account"
  deleteBankAccountByPk(id: bigint!): BankAccount

  # delete data from the table: "bank_info"
  deleteBankInfo(
    # filter the rows which have to be deleted
    where: BankInfoBoolExp!
  ): BankInfoMutationResponse

  # delete single row from the table: "bank_info"
  deleteBankInfoByPk(id: bigint!): BankInfo

  # delete data from the table: "campus"
  deleteCampus(
    # filter the rows which have to be deleted
    where: CampusBoolExp!
  ): CampusMutationResponse

  # delete single row from the table: "campus"
  deleteCampusByPk(id: bigint!): Campus

  # delete data from the table: "campus_cluster"
  deleteCampusCluster(
    # filter the rows which have to be deleted
    where: CampusClusterBoolExp!
  ): CampusClusterMutationResponse

  # delete single row from the table: "campus_cluster"
  deleteCampusClusterByPk(id: bigint!): CampusCluster

  # delete data from the table: "event"
  deleteEvent(
    # filter the rows which have to be deleted
    where: EventBoolExp!
  ): EventMutationResponse

  # delete data from the table: "event_approval"
  deleteEventApproval(
    # filter the rows which have to be deleted
    where: EventApprovalBoolExp!
  ): EventApprovalMutationResponse

  # delete single row from the table: "event_approval"
  deleteEventApprovalByPk(id: bigint!): EventApproval

  # delete data from the table: "event_approval_step"
  deleteEventApprovalStep(
    # filter the rows which have to be deleted
    where: EventApprovalStepBoolExp!
  ): EventApprovalStepMutationResponse

  # delete single row from the table: "event_approval_step"
  deleteEventApprovalStepByPk(id: bigint!): EventApprovalStep

  # delete data from the table: "event_approval_step_notifiees"
  deleteEventApprovalStepNotifiees(
    # filter the rows which have to be deleted
    where: EventApprovalStepNotifieesBoolExp!
  ): EventApprovalStepNotifieesMutationResponse

  # delete single row from the table: "event_approval_step_notifiees"
  deleteEventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepNotifiees

  # delete data from the table: "event_approval_step_validators"
  deleteEventApprovalStepValidators(
    # filter the rows which have to be deleted
    where: EventApprovalStepValidatorsBoolExp!
  ): EventApprovalStepValidatorsMutationResponse

  # delete single row from the table: "event_approval_step_validators"
  deleteEventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepValidators

  # delete single row from the table: "event"
  deleteEventByPk(id: bigint!): Event

  # delete data from the table: "event_favorite"
  deleteEventFavorite(
    # filter the rows which have to be deleted
    where: EventFavoriteBoolExp!
  ): EventFavoriteMutationResponse

  # delete single row from the table: "event_favorite"
  deleteEventFavoriteByPk(id: bigint!): EventFavorite

  # delete data from the table: "event_join"
  deleteEventJoin(
    # filter the rows which have to be deleted
    where: EventJoinBoolExp!
  ): EventJoinMutationResponse

  # delete single row from the table: "event_join"
  deleteEventJoinByPk(id: bigint!): EventJoin

  # delete data from the table: "event_organize"
  deleteEventOrganize(
    # filter the rows which have to be deleted
    where: EventOrganizeBoolExp!
  ): EventOrganizeMutationResponse

  # delete single row from the table: "event_organize"
  deleteEventOrganizeByPk(id: bigint!): EventOrganize

  # delete data from the table: "event_supervisor"
  deleteEventSupervisor(
    # filter the rows which have to be deleted
    where: EventSupervisorBoolExp!
  ): EventSupervisorMutationResponse

  # delete single row from the table: "event_supervisor"
  deleteEventSupervisorByPk(id: bigint!): EventSupervisor

  # delete data from the table: "expense"
  deleteExpense(
    # filter the rows which have to be deleted
    where: ExpenseBoolExp!
  ): ExpenseMutationResponse

  # delete single row from the table: "expense"
  deleteExpenseByPk(id: bigint!): Expense

  # delete data from the table: "expense_item"
  deleteExpenseItem(
    # filter the rows which have to be deleted
    where: ExpenseItemBoolExp!
  ): ExpenseItemMutationResponse

  # delete data from the table: "expense_item_attachments"
  deleteExpenseItemAttachments(
    # filter the rows which have to be deleted
    where: ExpenseItemAttachmentsBoolExp!
  ): ExpenseItemAttachmentsMutationResponse

  # delete single row from the table: "expense_item_attachments"
  deleteExpenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # delete single row from the table: "expense_item"
  deleteExpenseItemByPk(id: bigint!): ExpenseItem

  # delete data from the table: "file_upload"
  deleteFileUpload(
    # filter the rows which have to be deleted
    where: FileUploadBoolExp!
  ): FileUploadMutationResponse

  # delete single row from the table: "file_upload"
  deleteFileUploadByPk(id: bigint!): FileUpload

  # delete data from the table: "follow"
  deleteFollow(
    # filter the rows which have to be deleted
    where: FollowBoolExp!
  ): FollowMutationResponse

  # delete single row from the table: "follow"
  deleteFollowByPk(id: bigint!): Follow

  # delete data from the table: "form"
  deleteForm(
    # filter the rows which have to be deleted
    where: FormBoolExp!
  ): FormMutationResponse

  # delete single row from the table: "form"
  deleteFormByPk(id: bigint!): Form

  # delete data from the table: "form_submission"
  deleteFormSubmission(
    # filter the rows which have to be deleted
    where: FormSubmissionBoolExp!
  ): FormSubmissionMutationResponse

  # delete data from the table: "form_submission_attachments"
  deleteFormSubmissionAttachments(
    # filter the rows which have to be deleted
    where: FormSubmissionAttachmentsBoolExp!
  ): FormSubmissionAttachmentsMutationResponse

  # delete single row from the table: "form_submission_attachments"
  deleteFormSubmissionAttachmentsByPk(fileUploadId: bigint!, formSubmissionId: bigint!): FormSubmissionAttachments

  # delete single row from the table: "form_submission"
  deleteFormSubmissionByPk(id: bigint!): FormSubmission

  # delete data from the table: "grant"
  deleteGrant(
    # filter the rows which have to be deleted
    where: GrantBoolExp!
  ): GrantMutationResponse

  # delete data from the table: "grant_allocate"
  deleteGrantAllocate(
    # filter the rows which have to be deleted
    where: GrantAllocateBoolExp!
  ): GrantAllocateMutationResponse

  # delete data from the table: "grant_allocate_attachments"
  deleteGrantAllocateAttachments(
    # filter the rows which have to be deleted
    where: GrantAllocateAttachmentsBoolExp!
  ): GrantAllocateAttachmentsMutationResponse

  # delete single row from the table: "grant_allocate_attachments"
  deleteGrantAllocateAttachmentsByPk(fileUploadId: bigint!, grantAllocateId: bigint!): GrantAllocateAttachments

  # delete single row from the table: "grant_allocate"
  deleteGrantAllocateByPk(id: bigint!): GrantAllocate

  # delete data from the table: "grant_attachments"
  deleteGrantAttachments(
    # filter the rows which have to be deleted
    where: GrantAttachmentsBoolExp!
  ): GrantAttachmentsMutationResponse

  # delete single row from the table: "grant_attachments"
  deleteGrantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # delete single row from the table: "grant"
  deleteGrantByPk(id: bigint!): Grant

  # delete data from the table: "legal_unit"
  deleteLegalUnit(
    # filter the rows which have to be deleted
    where: LegalUnitBoolExp!
  ): LegalUnitMutationResponse

  # delete single row from the table: "legal_unit"
  deleteLegalUnitByPk(id: bigint!): LegalUnit

  # delete data from the table: "legal_unit_location"
  deleteLegalUnitLocation(
    # filter the rows which have to be deleted
    where: LegalUnitLocationBoolExp!
  ): LegalUnitLocationMutationResponse

  # delete single row from the table: "legal_unit_location"
  deleteLegalUnitLocationByPk(id: bigint!): LegalUnitLocation

  # delete data from the table: "location"
  deleteLocation(
    # filter the rows which have to be deleted
    where: LocationBoolExp!
  ): LocationMutationResponse

  # delete single row from the table: "location"
  deleteLocationByPk(id: bigint!): Location

  # delete data from the table: "location_images"
  deleteLocationImages(
    # filter the rows which have to be deleted
    where: LocationImagesBoolExp!
  ): LocationImagesMutationResponse

  # delete single row from the table: "location_images"
  deleteLocationImagesByPk(fileUploadId: bigint!, locationId: bigint!): LocationImages

  # delete data from the table: "mission"
  deleteMission(
    # filter the rows which have to be deleted
    where: MissionBoolExp!
  ): MissionMutationResponse

  # delete single row from the table: "mission"
  deleteMissionByPk(id: bigint!): Mission

  # delete data from the table: "mission_join"
  deleteMissionJoin(
    # filter the rows which have to be deleted
    where: MissionJoinBoolExp!
  ): MissionJoinMutationResponse

  # delete single row from the table: "mission_join"
  deleteMissionJoinByPk(id: bigint!): MissionJoin

  # delete data from the table: "pole"
  deletePole(
    # filter the rows which have to be deleted
    where: PoleBoolExp!
  ): PoleMutationResponse

  # delete single row from the table: "pole"
  deletePoleByPk(id: bigint!): Pole

  # delete data from the table: "project"
  deleteProject(
    # filter the rows which have to be deleted
    where: ProjectBoolExp!
  ): ProjectMutationResponse

  # delete single row from the table: "project"
  deleteProjectByPk(id: bigint!): Project

  # delete data from the table: "project_supervisors"
  deleteProjectSupervisors(
    # filter the rows which have to be deleted
    where: ProjectSupervisorsBoolExp!
  ): ProjectSupervisorsMutationResponse

  # delete single row from the table: "project_supervisors"
  deleteProjectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # delete data from the table: "social"
  deleteSocial(
    # filter the rows which have to be deleted
    where: SocialBoolExp!
  ): SocialMutationResponse

  # delete single row from the table: "social"
  deleteSocialByPk(id: bigint!): Social

  # delete data from the table: "tag"
  deleteTag(
    # filter the rows which have to be deleted
    where: TagBoolExp!
  ): TagMutationResponse

  # delete single row from the table: "tag"
  deleteTagByPk(id: bigint!): Tag

  # delete data from the table: "team"
  deleteTeam(
    # filter the rows which have to be deleted
    where: TeamBoolExp!
  ): TeamMutationResponse

  # delete single row from the table: "team"
  deleteTeamByPk(id: bigint!): Team

  # delete data from the table: "team_document"
  deleteTeamDocument(
    # filter the rows which have to be deleted
    where: TeamDocumentBoolExp!
  ): TeamDocumentMutationResponse

  # delete single row from the table: "team_document"
  deleteTeamDocumentByPk(id: bigint!): TeamDocument

  # delete data from the table: "team_history"
  deleteTeamHistory(
    # filter the rows which have to be deleted
    where: TeamHistoryBoolExp!
  ): TeamHistoryMutationResponse

  # delete single row from the table: "team_history"
  deleteTeamHistoryByPk(id: bigint!): TeamHistory

  # delete data from the table: "team_join"
  deleteTeamJoin(
    # filter the rows which have to be deleted
    where: TeamJoinBoolExp!
  ): TeamJoinMutationResponse

  # delete single row from the table: "team_join"
  deleteTeamJoinByPk(id: bigint!): TeamJoin

  # delete data from the table: "team_member"
  deleteTeamMember(
    # filter the rows which have to be deleted
    where: TeamMemberBoolExp!
  ): TeamMemberMutationResponse

  # delete single row from the table: "team_member"
  deleteTeamMemberByPk(id: bigint!): TeamMember

  # delete data from the table: "team_member_role"
  deleteTeamMemberRole(
    # filter the rows which have to be deleted
    where: TeamMemberRoleBoolExp!
  ): TeamMemberRoleMutationResponse

  # delete single row from the table: "team_member_role"
  deleteTeamMemberRoleByPk(id: bigint!): TeamMemberRole

  # delete data from the table: "team_role"
  deleteTeamRole(
    # filter the rows which have to be deleted
    where: TeamRoleBoolExp!
  ): TeamRoleMutationResponse

  # delete single row from the table: "team_role"
  deleteTeamRoleByPk(id: bigint!): TeamRole

  # delete data from the table: "tenant"
  deleteTenant(
    # filter the rows which have to be deleted
    where: TenantBoolExp!
  ): TenantMutationResponse

  # delete single row from the table: "tenant"
  deleteTenantByPk(id: bigint!): Tenant

  # delete data from the table: "tenant_member"
  deleteTenantMember(
    # filter the rows which have to be deleted
    where: TenantMemberBoolExp!
  ): TenantMemberMutationResponse

  # delete single row from the table: "tenant_member"
  deleteTenantMemberByPk(id: bigint!): TenantMember

  # delete data from the table: "tenant_member_role"
  deleteTenantMemberRole(
    # filter the rows which have to be deleted
    where: TenantMemberRoleBoolExp!
  ): TenantMemberRoleMutationResponse

  # delete single row from the table: "tenant_member_role"
  deleteTenantMemberRoleByPk(id: bigint!): TenantMemberRole

  # delete data from the table: "tenant_organize"
  deleteTenantOrganize(
    # filter the rows which have to be deleted
    where: TenantOrganizeBoolExp!
  ): TenantOrganizeMutationResponse

  # delete single row from the table: "tenant_organize"
  deleteTenantOrganizeByPk(id: bigint!): TenantOrganize

  # delete data from the table: "tenant_role"
  deleteTenantRole(
    # filter the rows which have to be deleted
    where: TenantRoleBoolExp!
  ): TenantRoleMutationResponse

  # delete single row from the table: "tenant_role"
  deleteTenantRoleByPk(id: bigint!): TenantRole

  # delete data from the table: "transaction"
  deleteTransaction(
    # filter the rows which have to be deleted
    where: TransactionBoolExp!
  ): TransactionMutationResponse

  # delete data from the table: "transaction_attachments"
  deleteTransactionAttachments(
    # filter the rows which have to be deleted
    where: TransactionAttachmentsBoolExp!
  ): TransactionAttachmentsMutationResponse

  # delete single row from the table: "transaction_attachments"
  deleteTransactionAttachmentsByPk(fileUploadId: bigint!, transactionId: bigint!): TransactionAttachments

  # delete single row from the table: "transaction"
  deleteTransactionByPk(id: bigint!): Transaction

  # delete data from the table: "user"
  deleteUser(
    # filter the rows which have to be deleted
    where: UserBoolExp!
  ): UserMutationResponse

  # delete single row from the table: "user"
  deleteUserByPk(id: bigint!): User

  # insert data into the table: "action"
  insertAction(
    # the rows to be inserted
    objects: [ActionInsertInput!]!

    # upsert condition
    onConflict: ActionOnConflict
  ): ActionMutationResponse

  # insert a single row into the table: "action"
  insertActionOne(
    # the row to be inserted
    object: ActionInsertInput!

    # upsert condition
    onConflict: ActionOnConflict
  ): Action

  # insert data into the table: "actor"
  insertActor(
    # the rows to be inserted
    objects: [ActorInsertInput!]!

    # upsert condition
    onConflict: ActorOnConflict
  ): ActorMutationResponse

  # insert data into the table: "actor_image"
  insertActorImage(
    # the rows to be inserted
    objects: [ActorImageInsertInput!]!

    # upsert condition
    onConflict: ActorImageOnConflict
  ): ActorImageMutationResponse

  # insert a single row into the table: "actor_image"
  insertActorImageOne(
    # the row to be inserted
    object: ActorImageInsertInput!

    # upsert condition
    onConflict: ActorImageOnConflict
  ): ActorImage

  # insert a single row into the table: "actor"
  insertActorOne(
    # the row to be inserted
    object: ActorInsertInput!

    # upsert condition
    onConflict: ActorOnConflict
  ): Actor

  # insert data into the table: "actor_tag"
  insertActorTag(
    # the rows to be inserted
    objects: [ActorTagInsertInput!]!

    # upsert condition
    onConflict: ActorTagOnConflict
  ): ActorTagMutationResponse

  # insert a single row into the table: "actor_tag"
  insertActorTagOne(
    # the row to be inserted
    object: ActorTagInsertInput!

    # upsert condition
    onConflict: ActorTagOnConflict
  ): ActorTag

  # insert data into the table: "address"
  insertAddress(
    # the rows to be inserted
    objects: [AddressInsertInput!]!

    # upsert condition
    onConflict: AddressOnConflict
  ): AddressMutationResponse

  # insert a single row into the table: "address"
  insertAddressOne(
    # the row to be inserted
    object: AddressInsertInput!

    # upsert condition
    onConflict: AddressOnConflict
  ): Address

  # insert data into the table: "bank_account"
  insertBankAccount(
    # the rows to be inserted
    objects: [BankAccountInsertInput!]!

    # upsert condition
    onConflict: BankAccountOnConflict
  ): BankAccountMutationResponse

  # insert a single row into the table: "bank_account"
  insertBankAccountOne(
    # the row to be inserted
    object: BankAccountInsertInput!

    # upsert condition
    onConflict: BankAccountOnConflict
  ): BankAccount

  # insert data into the table: "bank_info"
  insertBankInfo(
    # the rows to be inserted
    objects: [BankInfoInsertInput!]!

    # upsert condition
    onConflict: BankInfoOnConflict
  ): BankInfoMutationResponse

  # insert a single row into the table: "bank_info"
  insertBankInfoOne(
    # the row to be inserted
    object: BankInfoInsertInput!

    # upsert condition
    onConflict: BankInfoOnConflict
  ): BankInfo

  # insert data into the table: "campus"
  insertCampus(
    # the rows to be inserted
    objects: [CampusInsertInput!]!

    # upsert condition
    onConflict: CampusOnConflict
  ): CampusMutationResponse

  # insert data into the table: "campus_cluster"
  insertCampusCluster(
    # the rows to be inserted
    objects: [CampusClusterInsertInput!]!

    # upsert condition
    onConflict: CampusClusterOnConflict
  ): CampusClusterMutationResponse

  # insert a single row into the table: "campus_cluster"
  insertCampusClusterOne(
    # the row to be inserted
    object: CampusClusterInsertInput!

    # upsert condition
    onConflict: CampusClusterOnConflict
  ): CampusCluster

  # insert a single row into the table: "campus"
  insertCampusOne(
    # the row to be inserted
    object: CampusInsertInput!

    # upsert condition
    onConflict: CampusOnConflict
  ): Campus

  # insert data into the table: "event"
  insertEvent(
    # the rows to be inserted
    objects: [EventInsertInput!]!

    # upsert condition
    onConflict: EventOnConflict
  ): EventMutationResponse

  # insert data into the table: "event_approval"
  insertEventApproval(
    # the rows to be inserted
    objects: [EventApprovalInsertInput!]!

    # upsert condition
    onConflict: EventApprovalOnConflict
  ): EventApprovalMutationResponse

  # insert a single row into the table: "event_approval"
  insertEventApprovalOne(
    # the row to be inserted
    object: EventApprovalInsertInput!

    # upsert condition
    onConflict: EventApprovalOnConflict
  ): EventApproval

  # insert data into the table: "event_approval_step"
  insertEventApprovalStep(
    # the rows to be inserted
    objects: [EventApprovalStepInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepOnConflict
  ): EventApprovalStepMutationResponse

  # insert data into the table: "event_approval_step_notifiees"
  insertEventApprovalStepNotifiees(
    # the rows to be inserted
    objects: [EventApprovalStepNotifieesInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepNotifieesOnConflict
  ): EventApprovalStepNotifieesMutationResponse

  # insert a single row into the table: "event_approval_step_notifiees"
  insertEventApprovalStepNotifieesOne(
    # the row to be inserted
    object: EventApprovalStepNotifieesInsertInput!

    # upsert condition
    onConflict: EventApprovalStepNotifieesOnConflict
  ): EventApprovalStepNotifiees

  # insert a single row into the table: "event_approval_step"
  insertEventApprovalStepOne(
    # the row to be inserted
    object: EventApprovalStepInsertInput!

    # upsert condition
    onConflict: EventApprovalStepOnConflict
  ): EventApprovalStep

  # insert data into the table: "event_approval_step_validators"
  insertEventApprovalStepValidators(
    # the rows to be inserted
    objects: [EventApprovalStepValidatorsInsertInput!]!

    # upsert condition
    onConflict: EventApprovalStepValidatorsOnConflict
  ): EventApprovalStepValidatorsMutationResponse

  # insert a single row into the table: "event_approval_step_validators"
  insertEventApprovalStepValidatorsOne(
    # the row to be inserted
    object: EventApprovalStepValidatorsInsertInput!

    # upsert condition
    onConflict: EventApprovalStepValidatorsOnConflict
  ): EventApprovalStepValidators

  # insert data into the table: "event_favorite"
  insertEventFavorite(
    # the rows to be inserted
    objects: [EventFavoriteInsertInput!]!

    # upsert condition
    onConflict: EventFavoriteOnConflict
  ): EventFavoriteMutationResponse

  # insert a single row into the table: "event_favorite"
  insertEventFavoriteOne(
    # the row to be inserted
    object: EventFavoriteInsertInput!

    # upsert condition
    onConflict: EventFavoriteOnConflict
  ): EventFavorite

  # insert data into the table: "event_join"
  insertEventJoin(
    # the rows to be inserted
    objects: [EventJoinInsertInput!]!

    # upsert condition
    onConflict: EventJoinOnConflict
  ): EventJoinMutationResponse

  # insert a single row into the table: "event_join"
  insertEventJoinOne(
    # the row to be inserted
    object: EventJoinInsertInput!

    # upsert condition
    onConflict: EventJoinOnConflict
  ): EventJoin

  # insert a single row into the table: "event"
  insertEventOne(
    # the row to be inserted
    object: EventInsertInput!

    # upsert condition
    onConflict: EventOnConflict
  ): Event

  # insert data into the table: "event_organize"
  insertEventOrganize(
    # the rows to be inserted
    objects: [EventOrganizeInsertInput!]!

    # upsert condition
    onConflict: EventOrganizeOnConflict
  ): EventOrganizeMutationResponse

  # insert a single row into the table: "event_organize"
  insertEventOrganizeOne(
    # the row to be inserted
    object: EventOrganizeInsertInput!

    # upsert condition
    onConflict: EventOrganizeOnConflict
  ): EventOrganize

  # insert data into the table: "event_supervisor"
  insertEventSupervisor(
    # the rows to be inserted
    objects: [EventSupervisorInsertInput!]!

    # upsert condition
    onConflict: EventSupervisorOnConflict
  ): EventSupervisorMutationResponse

  # insert a single row into the table: "event_supervisor"
  insertEventSupervisorOne(
    # the row to be inserted
    object: EventSupervisorInsertInput!

    # upsert condition
    onConflict: EventSupervisorOnConflict
  ): EventSupervisor

  # insert data into the table: "expense"
  insertExpense(
    # the rows to be inserted
    objects: [ExpenseInsertInput!]!

    # upsert condition
    onConflict: ExpenseOnConflict
  ): ExpenseMutationResponse

  # insert data into the table: "expense_item"
  insertExpenseItem(
    # the rows to be inserted
    objects: [ExpenseItemInsertInput!]!

    # upsert condition
    onConflict: ExpenseItemOnConflict
  ): ExpenseItemMutationResponse

  # insert data into the table: "expense_item_attachments"
  insertExpenseItemAttachments(
    # the rows to be inserted
    objects: [ExpenseItemAttachmentsInsertInput!]!

    # upsert condition
    onConflict: ExpenseItemAttachmentsOnConflict
  ): ExpenseItemAttachmentsMutationResponse

  # insert a single row into the table: "expense_item_attachments"
  insertExpenseItemAttachmentsOne(
    # the row to be inserted
    object: ExpenseItemAttachmentsInsertInput!

    # upsert condition
    onConflict: ExpenseItemAttachmentsOnConflict
  ): ExpenseItemAttachments

  # insert a single row into the table: "expense_item"
  insertExpenseItemOne(
    # the row to be inserted
    object: ExpenseItemInsertInput!

    # upsert condition
    onConflict: ExpenseItemOnConflict
  ): ExpenseItem

  # insert a single row into the table: "expense"
  insertExpenseOne(
    # the row to be inserted
    object: ExpenseInsertInput!

    # upsert condition
    onConflict: ExpenseOnConflict
  ): Expense

  # insert data into the table: "file_upload"
  insertFileUpload(
    # the rows to be inserted
    objects: [FileUploadInsertInput!]!

    # upsert condition
    onConflict: FileUploadOnConflict
  ): FileUploadMutationResponse

  # insert a single row into the table: "file_upload"
  insertFileUploadOne(
    # the row to be inserted
    object: FileUploadInsertInput!

    # upsert condition
    onConflict: FileUploadOnConflict
  ): FileUpload

  # insert data into the table: "follow"
  insertFollow(
    # the rows to be inserted
    objects: [FollowInsertInput!]!

    # upsert condition
    onConflict: FollowOnConflict
  ): FollowMutationResponse

  # insert a single row into the table: "follow"
  insertFollowOne(
    # the row to be inserted
    object: FollowInsertInput!

    # upsert condition
    onConflict: FollowOnConflict
  ): Follow

  # insert data into the table: "form"
  insertForm(
    # the rows to be inserted
    objects: [FormInsertInput!]!

    # upsert condition
    onConflict: FormOnConflict
  ): FormMutationResponse

  # insert a single row into the table: "form"
  insertFormOne(
    # the row to be inserted
    object: FormInsertInput!

    # upsert condition
    onConflict: FormOnConflict
  ): Form

  # insert data into the table: "form_submission"
  insertFormSubmission(
    # the rows to be inserted
    objects: [FormSubmissionInsertInput!]!

    # upsert condition
    onConflict: FormSubmissionOnConflict
  ): FormSubmissionMutationResponse

  # insert data into the table: "form_submission_attachments"
  insertFormSubmissionAttachments(
    # the rows to be inserted
    objects: [FormSubmissionAttachmentsInsertInput!]!

    # upsert condition
    onConflict: FormSubmissionAttachmentsOnConflict
  ): FormSubmissionAttachmentsMutationResponse

  # insert a single row into the table: "form_submission_attachments"
  insertFormSubmissionAttachmentsOne(
    # the row to be inserted
    object: FormSubmissionAttachmentsInsertInput!

    # upsert condition
    onConflict: FormSubmissionAttachmentsOnConflict
  ): FormSubmissionAttachments

  # insert a single row into the table: "form_submission"
  insertFormSubmissionOne(
    # the row to be inserted
    object: FormSubmissionInsertInput!

    # upsert condition
    onConflict: FormSubmissionOnConflict
  ): FormSubmission

  # insert data into the table: "grant"
  insertGrant(
    # the rows to be inserted
    objects: [GrantInsertInput!]!

    # upsert condition
    onConflict: GrantOnConflict
  ): GrantMutationResponse

  # insert data into the table: "grant_allocate"
  insertGrantAllocate(
    # the rows to be inserted
    objects: [GrantAllocateInsertInput!]!

    # upsert condition
    onConflict: GrantAllocateOnConflict
  ): GrantAllocateMutationResponse

  # insert data into the table: "grant_allocate_attachments"
  insertGrantAllocateAttachments(
    # the rows to be inserted
    objects: [GrantAllocateAttachmentsInsertInput!]!

    # upsert condition
    onConflict: GrantAllocateAttachmentsOnConflict
  ): GrantAllocateAttachmentsMutationResponse

  # insert a single row into the table: "grant_allocate_attachments"
  insertGrantAllocateAttachmentsOne(
    # the row to be inserted
    object: GrantAllocateAttachmentsInsertInput!

    # upsert condition
    onConflict: GrantAllocateAttachmentsOnConflict
  ): GrantAllocateAttachments

  # insert a single row into the table: "grant_allocate"
  insertGrantAllocateOne(
    # the row to be inserted
    object: GrantAllocateInsertInput!

    # upsert condition
    onConflict: GrantAllocateOnConflict
  ): GrantAllocate

  # insert data into the table: "grant_attachments"
  insertGrantAttachments(
    # the rows to be inserted
    objects: [GrantAttachmentsInsertInput!]!

    # upsert condition
    onConflict: GrantAttachmentsOnConflict
  ): GrantAttachmentsMutationResponse

  # insert a single row into the table: "grant_attachments"
  insertGrantAttachmentsOne(
    # the row to be inserted
    object: GrantAttachmentsInsertInput!

    # upsert condition
    onConflict: GrantAttachmentsOnConflict
  ): GrantAttachments

  # insert a single row into the table: "grant"
  insertGrantOne(
    # the row to be inserted
    object: GrantInsertInput!

    # upsert condition
    onConflict: GrantOnConflict
  ): Grant

  # insert data into the table: "legal_unit"
  insertLegalUnit(
    # the rows to be inserted
    objects: [LegalUnitInsertInput!]!

    # upsert condition
    onConflict: LegalUnitOnConflict
  ): LegalUnitMutationResponse

  # insert data into the table: "legal_unit_location"
  insertLegalUnitLocation(
    # the rows to be inserted
    objects: [LegalUnitLocationInsertInput!]!

    # upsert condition
    onConflict: LegalUnitLocationOnConflict
  ): LegalUnitLocationMutationResponse

  # insert a single row into the table: "legal_unit_location"
  insertLegalUnitLocationOne(
    # the row to be inserted
    object: LegalUnitLocationInsertInput!

    # upsert condition
    onConflict: LegalUnitLocationOnConflict
  ): LegalUnitLocation

  # insert a single row into the table: "legal_unit"
  insertLegalUnitOne(
    # the row to be inserted
    object: LegalUnitInsertInput!

    # upsert condition
    onConflict: LegalUnitOnConflict
  ): LegalUnit

  # insert data into the table: "location"
  insertLocation(
    # the rows to be inserted
    objects: [LocationInsertInput!]!

    # upsert condition
    onConflict: LocationOnConflict
  ): LocationMutationResponse

  # insert data into the table: "location_images"
  insertLocationImages(
    # the rows to be inserted
    objects: [LocationImagesInsertInput!]!

    # upsert condition
    onConflict: LocationImagesOnConflict
  ): LocationImagesMutationResponse

  # insert a single row into the table: "location_images"
  insertLocationImagesOne(
    # the row to be inserted
    object: LocationImagesInsertInput!

    # upsert condition
    onConflict: LocationImagesOnConflict
  ): LocationImages

  # insert a single row into the table: "location"
  insertLocationOne(
    # the row to be inserted
    object: LocationInsertInput!

    # upsert condition
    onConflict: LocationOnConflict
  ): Location

  # insert data into the table: "mission"
  insertMission(
    # the rows to be inserted
    objects: [MissionInsertInput!]!

    # upsert condition
    onConflict: MissionOnConflict
  ): MissionMutationResponse

  # insert data into the table: "mission_join"
  insertMissionJoin(
    # the rows to be inserted
    objects: [MissionJoinInsertInput!]!

    # upsert condition
    onConflict: MissionJoinOnConflict
  ): MissionJoinMutationResponse

  # insert a single row into the table: "mission_join"
  insertMissionJoinOne(
    # the row to be inserted
    object: MissionJoinInsertInput!

    # upsert condition
    onConflict: MissionJoinOnConflict
  ): MissionJoin

  # insert a single row into the table: "mission"
  insertMissionOne(
    # the row to be inserted
    object: MissionInsertInput!

    # upsert condition
    onConflict: MissionOnConflict
  ): Mission

  # insert data into the table: "pole"
  insertPole(
    # the rows to be inserted
    objects: [PoleInsertInput!]!

    # upsert condition
    onConflict: PoleOnConflict
  ): PoleMutationResponse

  # insert a single row into the table: "pole"
  insertPoleOne(
    # the row to be inserted
    object: PoleInsertInput!

    # upsert condition
    onConflict: PoleOnConflict
  ): Pole

  # insert data into the table: "project"
  insertProject(
    # the rows to be inserted
    objects: [ProjectInsertInput!]!

    # upsert condition
    onConflict: ProjectOnConflict
  ): ProjectMutationResponse

  # insert a single row into the table: "project"
  insertProjectOne(
    # the row to be inserted
    object: ProjectInsertInput!

    # upsert condition
    onConflict: ProjectOnConflict
  ): Project

  # insert data into the table: "project_supervisors"
  insertProjectSupervisors(
    # the rows to be inserted
    objects: [ProjectSupervisorsInsertInput!]!

    # upsert condition
    onConflict: ProjectSupervisorsOnConflict
  ): ProjectSupervisorsMutationResponse

  # insert a single row into the table: "project_supervisors"
  insertProjectSupervisorsOne(
    # the row to be inserted
    object: ProjectSupervisorsInsertInput!

    # upsert condition
    onConflict: ProjectSupervisorsOnConflict
  ): ProjectSupervisors

  # insert data into the table: "social"
  insertSocial(
    # the rows to be inserted
    objects: [SocialInsertInput!]!

    # upsert condition
    onConflict: SocialOnConflict
  ): SocialMutationResponse

  # insert a single row into the table: "social"
  insertSocialOne(
    # the row to be inserted
    object: SocialInsertInput!

    # upsert condition
    onConflict: SocialOnConflict
  ): Social

  # insert data into the table: "tag"
  insertTag(
    # the rows to be inserted
    objects: [TagInsertInput!]!

    # upsert condition
    onConflict: TagOnConflict
  ): TagMutationResponse

  # insert a single row into the table: "tag"
  insertTagOne(
    # the row to be inserted
    object: TagInsertInput!

    # upsert condition
    onConflict: TagOnConflict
  ): Tag

  # insert data into the table: "team"
  insertTeam(
    # the rows to be inserted
    objects: [TeamInsertInput!]!

    # upsert condition
    onConflict: TeamOnConflict
  ): TeamMutationResponse

  # insert data into the table: "team_document"
  insertTeamDocument(
    # the rows to be inserted
    objects: [TeamDocumentInsertInput!]!

    # upsert condition
    onConflict: TeamDocumentOnConflict
  ): TeamDocumentMutationResponse

  # insert a single row into the table: "team_document"
  insertTeamDocumentOne(
    # the row to be inserted
    object: TeamDocumentInsertInput!

    # upsert condition
    onConflict: TeamDocumentOnConflict
  ): TeamDocument

  # insert data into the table: "team_history"
  insertTeamHistory(
    # the rows to be inserted
    objects: [TeamHistoryInsertInput!]!

    # upsert condition
    onConflict: TeamHistoryOnConflict
  ): TeamHistoryMutationResponse

  # insert a single row into the table: "team_history"
  insertTeamHistoryOne(
    # the row to be inserted
    object: TeamHistoryInsertInput!

    # upsert condition
    onConflict: TeamHistoryOnConflict
  ): TeamHistory

  # insert data into the table: "team_join"
  insertTeamJoin(
    # the rows to be inserted
    objects: [TeamJoinInsertInput!]!

    # upsert condition
    onConflict: TeamJoinOnConflict
  ): TeamJoinMutationResponse

  # insert a single row into the table: "team_join"
  insertTeamJoinOne(
    # the row to be inserted
    object: TeamJoinInsertInput!

    # upsert condition
    onConflict: TeamJoinOnConflict
  ): TeamJoin

  # insert data into the table: "team_member"
  insertTeamMember(
    # the rows to be inserted
    objects: [TeamMemberInsertInput!]!

    # upsert condition
    onConflict: TeamMemberOnConflict
  ): TeamMemberMutationResponse

  # insert a single row into the table: "team_member"
  insertTeamMemberOne(
    # the row to be inserted
    object: TeamMemberInsertInput!

    # upsert condition
    onConflict: TeamMemberOnConflict
  ): TeamMember

  # insert data into the table: "team_member_role"
  insertTeamMemberRole(
    # the rows to be inserted
    objects: [TeamMemberRoleInsertInput!]!

    # upsert condition
    onConflict: TeamMemberRoleOnConflict
  ): TeamMemberRoleMutationResponse

  # insert a single row into the table: "team_member_role"
  insertTeamMemberRoleOne(
    # the row to be inserted
    object: TeamMemberRoleInsertInput!

    # upsert condition
    onConflict: TeamMemberRoleOnConflict
  ): TeamMemberRole

  # insert a single row into the table: "team"
  insertTeamOne(
    # the row to be inserted
    object: TeamInsertInput!

    # upsert condition
    onConflict: TeamOnConflict
  ): Team

  # insert data into the table: "team_role"
  insertTeamRole(
    # the rows to be inserted
    objects: [TeamRoleInsertInput!]!

    # upsert condition
    onConflict: TeamRoleOnConflict
  ): TeamRoleMutationResponse

  # insert a single row into the table: "team_role"
  insertTeamRoleOne(
    # the row to be inserted
    object: TeamRoleInsertInput!

    # upsert condition
    onConflict: TeamRoleOnConflict
  ): TeamRole

  # insert data into the table: "tenant"
  insertTenant(
    # the rows to be inserted
    objects: [TenantInsertInput!]!

    # upsert condition
    onConflict: TenantOnConflict
  ): TenantMutationResponse

  # insert data into the table: "tenant_member"
  insertTenantMember(
    # the rows to be inserted
    objects: [TenantMemberInsertInput!]!

    # upsert condition
    onConflict: TenantMemberOnConflict
  ): TenantMemberMutationResponse

  # insert a single row into the table: "tenant_member"
  insertTenantMemberOne(
    # the row to be inserted
    object: TenantMemberInsertInput!

    # upsert condition
    onConflict: TenantMemberOnConflict
  ): TenantMember

  # insert data into the table: "tenant_member_role"
  insertTenantMemberRole(
    # the rows to be inserted
    objects: [TenantMemberRoleInsertInput!]!

    # upsert condition
    onConflict: TenantMemberRoleOnConflict
  ): TenantMemberRoleMutationResponse

  # insert a single row into the table: "tenant_member_role"
  insertTenantMemberRoleOne(
    # the row to be inserted
    object: TenantMemberRoleInsertInput!

    # upsert condition
    onConflict: TenantMemberRoleOnConflict
  ): TenantMemberRole

  # insert a single row into the table: "tenant"
  insertTenantOne(
    # the row to be inserted
    object: TenantInsertInput!

    # upsert condition
    onConflict: TenantOnConflict
  ): Tenant

  # insert data into the table: "tenant_organize"
  insertTenantOrganize(
    # the rows to be inserted
    objects: [TenantOrganizeInsertInput!]!

    # upsert condition
    onConflict: TenantOrganizeOnConflict
  ): TenantOrganizeMutationResponse

  # insert a single row into the table: "tenant_organize"
  insertTenantOrganizeOne(
    # the row to be inserted
    object: TenantOrganizeInsertInput!

    # upsert condition
    onConflict: TenantOrganizeOnConflict
  ): TenantOrganize

  # insert data into the table: "tenant_role"
  insertTenantRole(
    # the rows to be inserted
    objects: [TenantRoleInsertInput!]!

    # upsert condition
    onConflict: TenantRoleOnConflict
  ): TenantRoleMutationResponse

  # insert a single row into the table: "tenant_role"
  insertTenantRoleOne(
    # the row to be inserted
    object: TenantRoleInsertInput!

    # upsert condition
    onConflict: TenantRoleOnConflict
  ): TenantRole

  # insert data into the table: "transaction"
  insertTransaction(
    # the rows to be inserted
    objects: [TransactionInsertInput!]!

    # upsert condition
    onConflict: TransactionOnConflict
  ): TransactionMutationResponse

  # insert data into the table: "transaction_attachments"
  insertTransactionAttachments(
    # the rows to be inserted
    objects: [TransactionAttachmentsInsertInput!]!

    # upsert condition
    onConflict: TransactionAttachmentsOnConflict
  ): TransactionAttachmentsMutationResponse

  # insert a single row into the table: "transaction_attachments"
  insertTransactionAttachmentsOne(
    # the row to be inserted
    object: TransactionAttachmentsInsertInput!

    # upsert condition
    onConflict: TransactionAttachmentsOnConflict
  ): TransactionAttachments

  # insert a single row into the table: "transaction"
  insertTransactionOne(
    # the row to be inserted
    object: TransactionInsertInput!

    # upsert condition
    onConflict: TransactionOnConflict
  ): Transaction

  # insert data into the table: "user"
  insertUser(
    # the rows to be inserted
    objects: [UserInsertInput!]!

    # upsert condition
    onConflict: UserOnConflict
  ): UserMutationResponse

  # insert a single row into the table: "user"
  insertUserOne(
    # the row to be inserted
    object: UserInsertInput!

    # upsert condition
    onConflict: UserOnConflict
  ): User

  # update data of the table: "action"
  updateAction(
    # increments the numeric columns with given value of the filtered values
    _inc: ActionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActionSetInput

    # filter the rows which have to be updated
    where: ActionBoolExp!
  ): ActionMutationResponse

  # update single row of the table: "action"
  updateActionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActionIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActionSetInput
    pkColumns: ActionPkColumnsInput!
  ): Action

  # update multiples rows of table: "action"
  updateActionMany(
    # updates to execute, in order
    updates: [ActionUpdates!]!
  ): [ActionMutationResponse]

  # update data of the table: "actor"
  updateActor(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorSetInput

    # filter the rows which have to be updated
    where: ActorBoolExp!
  ): ActorMutationResponse

  # update single row of the table: "actor"
  updateActorByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorSetInput
    pkColumns: ActorPkColumnsInput!
  ): Actor

  # update data of the table: "actor_image"
  updateActorImage(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorImageIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorImageSetInput

    # filter the rows which have to be updated
    where: ActorImageBoolExp!
  ): ActorImageMutationResponse

  # update single row of the table: "actor_image"
  updateActorImageByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorImageIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorImageSetInput
    pkColumns: ActorImagePkColumnsInput!
  ): ActorImage

  # update multiples rows of table: "actor_image"
  updateActorImageMany(
    # updates to execute, in order
    updates: [ActorImageUpdates!]!
  ): [ActorImageMutationResponse]

  # update multiples rows of table: "actor"
  updateActorMany(
    # updates to execute, in order
    updates: [ActorUpdates!]!
  ): [ActorMutationResponse]

  # update data of the table: "actor_tag"
  updateActorTag(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorTagIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorTagSetInput

    # filter the rows which have to be updated
    where: ActorTagBoolExp!
  ): ActorTagMutationResponse

  # update single row of the table: "actor_tag"
  updateActorTagByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ActorTagIncInput

    # sets the columns of the filtered rows to the given values
    _set: ActorTagSetInput
    pkColumns: ActorTagPkColumnsInput!
  ): ActorTag

  # update multiples rows of table: "actor_tag"
  updateActorTagMany(
    # updates to execute, in order
    updates: [ActorTagUpdates!]!
  ): [ActorTagMutationResponse]

  # update data of the table: "address"
  updateAddress(
    # increments the numeric columns with given value of the filtered values
    _inc: AddressIncInput

    # sets the columns of the filtered rows to the given values
    _set: AddressSetInput

    # filter the rows which have to be updated
    where: AddressBoolExp!
  ): AddressMutationResponse

  # update single row of the table: "address"
  updateAddressByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: AddressIncInput

    # sets the columns of the filtered rows to the given values
    _set: AddressSetInput
    pkColumns: AddressPkColumnsInput!
  ): Address

  # update multiples rows of table: "address"
  updateAddressMany(
    # updates to execute, in order
    updates: [AddressUpdates!]!
  ): [AddressMutationResponse]

  # update data of the table: "bank_account"
  updateBankAccount(
    # increments the numeric columns with given value of the filtered values
    _inc: BankAccountIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankAccountSetInput

    # filter the rows which have to be updated
    where: BankAccountBoolExp!
  ): BankAccountMutationResponse

  # update single row of the table: "bank_account"
  updateBankAccountByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: BankAccountIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankAccountSetInput
    pkColumns: BankAccountPkColumnsInput!
  ): BankAccount

  # update multiples rows of table: "bank_account"
  updateBankAccountMany(
    # updates to execute, in order
    updates: [BankAccountUpdates!]!
  ): [BankAccountMutationResponse]

  # update data of the table: "bank_info"
  updateBankInfo(
    # increments the numeric columns with given value of the filtered values
    _inc: BankInfoIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankInfoSetInput

    # filter the rows which have to be updated
    where: BankInfoBoolExp!
  ): BankInfoMutationResponse

  # update single row of the table: "bank_info"
  updateBankInfoByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: BankInfoIncInput

    # sets the columns of the filtered rows to the given values
    _set: BankInfoSetInput
    pkColumns: BankInfoPkColumnsInput!
  ): BankInfo

  # update multiples rows of table: "bank_info"
  updateBankInfoMany(
    # updates to execute, in order
    updates: [BankInfoUpdates!]!
  ): [BankInfoMutationResponse]

  # update data of the table: "campus"
  updateCampus(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusSetInput

    # filter the rows which have to be updated
    where: CampusBoolExp!
  ): CampusMutationResponse

  # update single row of the table: "campus"
  updateCampusByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusSetInput
    pkColumns: CampusPkColumnsInput!
  ): Campus

  # update data of the table: "campus_cluster"
  updateCampusCluster(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusClusterIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusClusterSetInput

    # filter the rows which have to be updated
    where: CampusClusterBoolExp!
  ): CampusClusterMutationResponse

  # update single row of the table: "campus_cluster"
  updateCampusClusterByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: CampusClusterIncInput

    # sets the columns of the filtered rows to the given values
    _set: CampusClusterSetInput
    pkColumns: CampusClusterPkColumnsInput!
  ): CampusCluster

  # update multiples rows of table: "campus_cluster"
  updateCampusClusterMany(
    # updates to execute, in order
    updates: [CampusClusterUpdates!]!
  ): [CampusClusterMutationResponse]

  # update multiples rows of table: "campus"
  updateCampusMany(
    # updates to execute, in order
    updates: [CampusUpdates!]!
  ): [CampusMutationResponse]

  # update data of the table: "event"
  updateEvent(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: EventAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: EventDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: EventDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: EventDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: EventIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: EventPrependInput

    # sets the columns of the filtered rows to the given values
    _set: EventSetInput

    # filter the rows which have to be updated
    where: EventBoolExp!
  ): EventMutationResponse

  # update data of the table: "event_approval"
  updateEventApproval(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalSetInput

    # filter the rows which have to be updated
    where: EventApprovalBoolExp!
  ): EventApprovalMutationResponse

  # update single row of the table: "event_approval"
  updateEventApprovalByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalSetInput
    pkColumns: EventApprovalPkColumnsInput!
  ): EventApproval

  # update multiples rows of table: "event_approval"
  updateEventApprovalMany(
    # updates to execute, in order
    updates: [EventApprovalUpdates!]!
  ): [EventApprovalMutationResponse]

  # update data of the table: "event_approval_step"
  updateEventApprovalStep(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepBoolExp!
  ): EventApprovalStepMutationResponse

  # update single row of the table: "event_approval_step"
  updateEventApprovalStepByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepSetInput
    pkColumns: EventApprovalStepPkColumnsInput!
  ): EventApprovalStep

  # update multiples rows of table: "event_approval_step"
  updateEventApprovalStepMany(
    # updates to execute, in order
    updates: [EventApprovalStepUpdates!]!
  ): [EventApprovalStepMutationResponse]

  # update data of the table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifiees(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepNotifieesIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepNotifieesSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepNotifieesBoolExp!
  ): EventApprovalStepNotifieesMutationResponse

  # update single row of the table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifieesByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepNotifieesIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepNotifieesSetInput
    pkColumns: EventApprovalStepNotifieesPkColumnsInput!
  ): EventApprovalStepNotifiees

  # update multiples rows of table: "event_approval_step_notifiees"
  updateEventApprovalStepNotifieesMany(
    # updates to execute, in order
    updates: [EventApprovalStepNotifieesUpdates!]!
  ): [EventApprovalStepNotifieesMutationResponse]

  # update data of the table: "event_approval_step_validators"
  updateEventApprovalStepValidators(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepValidatorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepValidatorsSetInput

    # filter the rows which have to be updated
    where: EventApprovalStepValidatorsBoolExp!
  ): EventApprovalStepValidatorsMutationResponse

  # update single row of the table: "event_approval_step_validators"
  updateEventApprovalStepValidatorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventApprovalStepValidatorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventApprovalStepValidatorsSetInput
    pkColumns: EventApprovalStepValidatorsPkColumnsInput!
  ): EventApprovalStepValidators

  # update multiples rows of table: "event_approval_step_validators"
  updateEventApprovalStepValidatorsMany(
    # updates to execute, in order
    updates: [EventApprovalStepValidatorsUpdates!]!
  ): [EventApprovalStepValidatorsMutationResponse]

  # update single row of the table: "event"
  updateEventByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: EventAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: EventDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: EventDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: EventDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: EventIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: EventPrependInput

    # sets the columns of the filtered rows to the given values
    _set: EventSetInput
    pkColumns: EventPkColumnsInput!
  ): Event

  # update data of the table: "event_favorite"
  updateEventFavorite(
    # increments the numeric columns with given value of the filtered values
    _inc: EventFavoriteIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventFavoriteSetInput

    # filter the rows which have to be updated
    where: EventFavoriteBoolExp!
  ): EventFavoriteMutationResponse

  # update single row of the table: "event_favorite"
  updateEventFavoriteByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventFavoriteIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventFavoriteSetInput
    pkColumns: EventFavoritePkColumnsInput!
  ): EventFavorite

  # update multiples rows of table: "event_favorite"
  updateEventFavoriteMany(
    # updates to execute, in order
    updates: [EventFavoriteUpdates!]!
  ): [EventFavoriteMutationResponse]

  # update data of the table: "event_join"
  updateEventJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: EventJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventJoinSetInput

    # filter the rows which have to be updated
    where: EventJoinBoolExp!
  ): EventJoinMutationResponse

  # update single row of the table: "event_join"
  updateEventJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventJoinSetInput
    pkColumns: EventJoinPkColumnsInput!
  ): EventJoin

  # update multiples rows of table: "event_join"
  updateEventJoinMany(
    # updates to execute, in order
    updates: [EventJoinUpdates!]!
  ): [EventJoinMutationResponse]

  # update multiples rows of table: "event"
  updateEventMany(
    # updates to execute, in order
    updates: [EventUpdates!]!
  ): [EventMutationResponse]

  # update data of the table: "event_organize"
  updateEventOrganize(
    # increments the numeric columns with given value of the filtered values
    _inc: EventOrganizeIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventOrganizeSetInput

    # filter the rows which have to be updated
    where: EventOrganizeBoolExp!
  ): EventOrganizeMutationResponse

  # update single row of the table: "event_organize"
  updateEventOrganizeByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventOrganizeIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventOrganizeSetInput
    pkColumns: EventOrganizePkColumnsInput!
  ): EventOrganize

  # update multiples rows of table: "event_organize"
  updateEventOrganizeMany(
    # updates to execute, in order
    updates: [EventOrganizeUpdates!]!
  ): [EventOrganizeMutationResponse]

  # update data of the table: "event_supervisor"
  updateEventSupervisor(
    # increments the numeric columns with given value of the filtered values
    _inc: EventSupervisorIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventSupervisorSetInput

    # filter the rows which have to be updated
    where: EventSupervisorBoolExp!
  ): EventSupervisorMutationResponse

  # update single row of the table: "event_supervisor"
  updateEventSupervisorByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: EventSupervisorIncInput

    # sets the columns of the filtered rows to the given values
    _set: EventSupervisorSetInput
    pkColumns: EventSupervisorPkColumnsInput!
  ): EventSupervisor

  # update multiples rows of table: "event_supervisor"
  updateEventSupervisorMany(
    # updates to execute, in order
    updates: [EventSupervisorUpdates!]!
  ): [EventSupervisorMutationResponse]

  # update data of the table: "expense"
  updateExpense(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseSetInput

    # filter the rows which have to be updated
    where: ExpenseBoolExp!
  ): ExpenseMutationResponse

  # update single row of the table: "expense"
  updateExpenseByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseSetInput
    pkColumns: ExpensePkColumnsInput!
  ): Expense

  # update data of the table: "expense_item"
  updateExpenseItem(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemSetInput

    # filter the rows which have to be updated
    where: ExpenseItemBoolExp!
  ): ExpenseItemMutationResponse

  # update data of the table: "expense_item_attachments"
  updateExpenseItemAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemAttachmentsSetInput

    # filter the rows which have to be updated
    where: ExpenseItemAttachmentsBoolExp!
  ): ExpenseItemAttachmentsMutationResponse

  # update single row of the table: "expense_item_attachments"
  updateExpenseItemAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemAttachmentsSetInput
    pkColumns: ExpenseItemAttachmentsPkColumnsInput!
  ): ExpenseItemAttachments

  # update multiples rows of table: "expense_item_attachments"
  updateExpenseItemAttachmentsMany(
    # updates to execute, in order
    updates: [ExpenseItemAttachmentsUpdates!]!
  ): [ExpenseItemAttachmentsMutationResponse]

  # update single row of the table: "expense_item"
  updateExpenseItemByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ExpenseItemIncInput

    # sets the columns of the filtered rows to the given values
    _set: ExpenseItemSetInput
    pkColumns: ExpenseItemPkColumnsInput!
  ): ExpenseItem

  # update multiples rows of table: "expense_item"
  updateExpenseItemMany(
    # updates to execute, in order
    updates: [ExpenseItemUpdates!]!
  ): [ExpenseItemMutationResponse]

  # update multiples rows of table: "expense"
  updateExpenseMany(
    # updates to execute, in order
    updates: [ExpenseUpdates!]!
  ): [ExpenseMutationResponse]

  # update data of the table: "file_upload"
  updateFileUpload(
    # increments the numeric columns with given value of the filtered values
    _inc: FileUploadIncInput

    # sets the columns of the filtered rows to the given values
    _set: FileUploadSetInput

    # filter the rows which have to be updated
    where: FileUploadBoolExp!
  ): FileUploadMutationResponse

  # update single row of the table: "file_upload"
  updateFileUploadByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FileUploadIncInput

    # sets the columns of the filtered rows to the given values
    _set: FileUploadSetInput
    pkColumns: FileUploadPkColumnsInput!
  ): FileUpload

  # update multiples rows of table: "file_upload"
  updateFileUploadMany(
    # updates to execute, in order
    updates: [FileUploadUpdates!]!
  ): [FileUploadMutationResponse]

  # update data of the table: "follow"
  updateFollow(
    # increments the numeric columns with given value of the filtered values
    _inc: FollowIncInput

    # sets the columns of the filtered rows to the given values
    _set: FollowSetInput

    # filter the rows which have to be updated
    where: FollowBoolExp!
  ): FollowMutationResponse

  # update single row of the table: "follow"
  updateFollowByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FollowIncInput

    # sets the columns of the filtered rows to the given values
    _set: FollowSetInput
    pkColumns: FollowPkColumnsInput!
  ): Follow

  # update multiples rows of table: "follow"
  updateFollowMany(
    # updates to execute, in order
    updates: [FollowUpdates!]!
  ): [FollowMutationResponse]

  # update data of the table: "form"
  updateForm(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSetInput

    # filter the rows which have to be updated
    where: FormBoolExp!
  ): FormMutationResponse

  # update single row of the table: "form"
  updateFormByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSetInput
    pkColumns: FormPkColumnsInput!
  ): Form

  # update multiples rows of table: "form"
  updateFormMany(
    # updates to execute, in order
    updates: [FormUpdates!]!
  ): [FormMutationResponse]

  # update data of the table: "form_submission"
  updateFormSubmission(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormSubmissionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormSubmissionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormSubmissionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormSubmissionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormSubmissionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionSetInput

    # filter the rows which have to be updated
    where: FormSubmissionBoolExp!
  ): FormSubmissionMutationResponse

  # update data of the table: "form_submission_attachments"
  updateFormSubmissionAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionAttachmentsSetInput

    # filter the rows which have to be updated
    where: FormSubmissionAttachmentsBoolExp!
  ): FormSubmissionAttachmentsMutationResponse

  # update single row of the table: "form_submission_attachments"
  updateFormSubmissionAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionAttachmentsSetInput
    pkColumns: FormSubmissionAttachmentsPkColumnsInput!
  ): FormSubmissionAttachments

  # update multiples rows of table: "form_submission_attachments"
  updateFormSubmissionAttachmentsMany(
    # updates to execute, in order
    updates: [FormSubmissionAttachmentsUpdates!]!
  ): [FormSubmissionAttachmentsMutationResponse]

  # update single row of the table: "form_submission"
  updateFormSubmissionByPk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: FormSubmissionAppendInput

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _deleteAtPath: FormSubmissionDeleteAtPathInput

    # delete the array element with specified index (negative integers count from
    # the end). throws an error if top level container is not an array
    _deleteElem: FormSubmissionDeleteElemInput

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _deleteKey: FormSubmissionDeleteKeyInput

    # increments the numeric columns with given value of the filtered values
    _inc: FormSubmissionIncInput

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: FormSubmissionPrependInput

    # sets the columns of the filtered rows to the given values
    _set: FormSubmissionSetInput
    pkColumns: FormSubmissionPkColumnsInput!
  ): FormSubmission

  # update multiples rows of table: "form_submission"
  updateFormSubmissionMany(
    # updates to execute, in order
    updates: [FormSubmissionUpdates!]!
  ): [FormSubmissionMutationResponse]

  # update data of the table: "grant"
  updateGrant(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantSetInput

    # filter the rows which have to be updated
    where: GrantBoolExp!
  ): GrantMutationResponse

  # update data of the table: "grant_allocate"
  updateGrantAllocate(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAllocateIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAllocateSetInput

    # filter the rows which have to be updated
    where: GrantAllocateBoolExp!
  ): GrantAllocateMutationResponse

  # update data of the table: "grant_allocate_attachments"
  updateGrantAllocateAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAllocateAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAllocateAttachmentsSetInput

    # filter the rows which have to be updated
    where: GrantAllocateAttachmentsBoolExp!
  ): GrantAllocateAttachmentsMutationResponse

  # update single row of the table: "grant_allocate_attachments"
  updateGrantAllocateAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAllocateAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAllocateAttachmentsSetInput
    pkColumns: GrantAllocateAttachmentsPkColumnsInput!
  ): GrantAllocateAttachments

  # update multiples rows of table: "grant_allocate_attachments"
  updateGrantAllocateAttachmentsMany(
    # updates to execute, in order
    updates: [GrantAllocateAttachmentsUpdates!]!
  ): [GrantAllocateAttachmentsMutationResponse]

  # update single row of the table: "grant_allocate"
  updateGrantAllocateByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAllocateIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAllocateSetInput
    pkColumns: GrantAllocatePkColumnsInput!
  ): GrantAllocate

  # update multiples rows of table: "grant_allocate"
  updateGrantAllocateMany(
    # updates to execute, in order
    updates: [GrantAllocateUpdates!]!
  ): [GrantAllocateMutationResponse]

  # update data of the table: "grant_attachments"
  updateGrantAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAttachmentsSetInput

    # filter the rows which have to be updated
    where: GrantAttachmentsBoolExp!
  ): GrantAttachmentsMutationResponse

  # update single row of the table: "grant_attachments"
  updateGrantAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantAttachmentsSetInput
    pkColumns: GrantAttachmentsPkColumnsInput!
  ): GrantAttachments

  # update multiples rows of table: "grant_attachments"
  updateGrantAttachmentsMany(
    # updates to execute, in order
    updates: [GrantAttachmentsUpdates!]!
  ): [GrantAttachmentsMutationResponse]

  # update single row of the table: "grant"
  updateGrantByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: GrantIncInput

    # sets the columns of the filtered rows to the given values
    _set: GrantSetInput
    pkColumns: GrantPkColumnsInput!
  ): Grant

  # update multiples rows of table: "grant"
  updateGrantMany(
    # updates to execute, in order
    updates: [GrantUpdates!]!
  ): [GrantMutationResponse]

  # update data of the table: "legal_unit"
  updateLegalUnit(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitSetInput

    # filter the rows which have to be updated
    where: LegalUnitBoolExp!
  ): LegalUnitMutationResponse

  # update single row of the table: "legal_unit"
  updateLegalUnitByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitSetInput
    pkColumns: LegalUnitPkColumnsInput!
  ): LegalUnit

  # update data of the table: "legal_unit_location"
  updateLegalUnitLocation(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitLocationIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitLocationSetInput

    # filter the rows which have to be updated
    where: LegalUnitLocationBoolExp!
  ): LegalUnitLocationMutationResponse

  # update single row of the table: "legal_unit_location"
  updateLegalUnitLocationByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: LegalUnitLocationIncInput

    # sets the columns of the filtered rows to the given values
    _set: LegalUnitLocationSetInput
    pkColumns: LegalUnitLocationPkColumnsInput!
  ): LegalUnitLocation

  # update multiples rows of table: "legal_unit_location"
  updateLegalUnitLocationMany(
    # updates to execute, in order
    updates: [LegalUnitLocationUpdates!]!
  ): [LegalUnitLocationMutationResponse]

  # update multiples rows of table: "legal_unit"
  updateLegalUnitMany(
    # updates to execute, in order
    updates: [LegalUnitUpdates!]!
  ): [LegalUnitMutationResponse]

  # update data of the table: "location"
  updateLocation(
    # increments the numeric columns with given value of the filtered values
    _inc: LocationIncInput

    # sets the columns of the filtered rows to the given values
    _set: LocationSetInput

    # filter the rows which have to be updated
    where: LocationBoolExp!
  ): LocationMutationResponse

  # update single row of the table: "location"
  updateLocationByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: LocationIncInput

    # sets the columns of the filtered rows to the given values
    _set: LocationSetInput
    pkColumns: LocationPkColumnsInput!
  ): Location

  # update data of the table: "location_images"
  updateLocationImages(
    # increments the numeric columns with given value of the filtered values
    _inc: LocationImagesIncInput

    # sets the columns of the filtered rows to the given values
    _set: LocationImagesSetInput

    # filter the rows which have to be updated
    where: LocationImagesBoolExp!
  ): LocationImagesMutationResponse

  # update single row of the table: "location_images"
  updateLocationImagesByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: LocationImagesIncInput

    # sets the columns of the filtered rows to the given values
    _set: LocationImagesSetInput
    pkColumns: LocationImagesPkColumnsInput!
  ): LocationImages

  # update multiples rows of table: "location_images"
  updateLocationImagesMany(
    # updates to execute, in order
    updates: [LocationImagesUpdates!]!
  ): [LocationImagesMutationResponse]

  # update multiples rows of table: "location"
  updateLocationMany(
    # updates to execute, in order
    updates: [LocationUpdates!]!
  ): [LocationMutationResponse]

  # update data of the table: "mission"
  updateMission(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionSetInput

    # filter the rows which have to be updated
    where: MissionBoolExp!
  ): MissionMutationResponse

  # update single row of the table: "mission"
  updateMissionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionSetInput
    pkColumns: MissionPkColumnsInput!
  ): Mission

  # update data of the table: "mission_join"
  updateMissionJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionJoinSetInput

    # filter the rows which have to be updated
    where: MissionJoinBoolExp!
  ): MissionJoinMutationResponse

  # update single row of the table: "mission_join"
  updateMissionJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: MissionJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: MissionJoinSetInput
    pkColumns: MissionJoinPkColumnsInput!
  ): MissionJoin

  # update multiples rows of table: "mission_join"
  updateMissionJoinMany(
    # updates to execute, in order
    updates: [MissionJoinUpdates!]!
  ): [MissionJoinMutationResponse]

  # update multiples rows of table: "mission"
  updateMissionMany(
    # updates to execute, in order
    updates: [MissionUpdates!]!
  ): [MissionMutationResponse]

  # update data of the table: "pole"
  updatePole(
    # increments the numeric columns with given value of the filtered values
    _inc: PoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: PoleSetInput

    # filter the rows which have to be updated
    where: PoleBoolExp!
  ): PoleMutationResponse

  # update single row of the table: "pole"
  updatePoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: PoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: PoleSetInput
    pkColumns: PolePkColumnsInput!
  ): Pole

  # update multiples rows of table: "pole"
  updatePoleMany(
    # updates to execute, in order
    updates: [PoleUpdates!]!
  ): [PoleMutationResponse]

  # update data of the table: "project"
  updateProject(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSetInput

    # filter the rows which have to be updated
    where: ProjectBoolExp!
  ): ProjectMutationResponse

  # update single row of the table: "project"
  updateProjectByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSetInput
    pkColumns: ProjectPkColumnsInput!
  ): Project

  # update multiples rows of table: "project"
  updateProjectMany(
    # updates to execute, in order
    updates: [ProjectUpdates!]!
  ): [ProjectMutationResponse]

  # update data of the table: "project_supervisors"
  updateProjectSupervisors(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSupervisorsSetInput

    # filter the rows which have to be updated
    where: ProjectSupervisorsBoolExp!
  ): ProjectSupervisorsMutationResponse

  # update single row of the table: "project_supervisors"
  updateProjectSupervisorsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: ProjectSupervisorsIncInput

    # sets the columns of the filtered rows to the given values
    _set: ProjectSupervisorsSetInput
    pkColumns: ProjectSupervisorsPkColumnsInput!
  ): ProjectSupervisors

  # update multiples rows of table: "project_supervisors"
  updateProjectSupervisorsMany(
    # updates to execute, in order
    updates: [ProjectSupervisorsUpdates!]!
  ): [ProjectSupervisorsMutationResponse]

  # update data of the table: "social"
  updateSocial(
    # increments the numeric columns with given value of the filtered values
    _inc: SocialIncInput

    # sets the columns of the filtered rows to the given values
    _set: SocialSetInput

    # filter the rows which have to be updated
    where: SocialBoolExp!
  ): SocialMutationResponse

  # update single row of the table: "social"
  updateSocialByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: SocialIncInput

    # sets the columns of the filtered rows to the given values
    _set: SocialSetInput
    pkColumns: SocialPkColumnsInput!
  ): Social

  # update multiples rows of table: "social"
  updateSocialMany(
    # updates to execute, in order
    updates: [SocialUpdates!]!
  ): [SocialMutationResponse]

  # update data of the table: "tag"
  updateTag(
    # increments the numeric columns with given value of the filtered values
    _inc: TagIncInput

    # sets the columns of the filtered rows to the given values
    _set: TagSetInput

    # filter the rows which have to be updated
    where: TagBoolExp!
  ): TagMutationResponse

  # update single row of the table: "tag"
  updateTagByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TagIncInput

    # sets the columns of the filtered rows to the given values
    _set: TagSetInput
    pkColumns: TagPkColumnsInput!
  ): Tag

  # update multiples rows of table: "tag"
  updateTagMany(
    # updates to execute, in order
    updates: [TagUpdates!]!
  ): [TagMutationResponse]

  # update data of the table: "team"
  updateTeam(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamSetInput

    # filter the rows which have to be updated
    where: TeamBoolExp!
  ): TeamMutationResponse

  # update single row of the table: "team"
  updateTeamByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamSetInput
    pkColumns: TeamPkColumnsInput!
  ): Team

  # update data of the table: "team_document"
  updateTeamDocument(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamDocumentIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamDocumentSetInput

    # filter the rows which have to be updated
    where: TeamDocumentBoolExp!
  ): TeamDocumentMutationResponse

  # update single row of the table: "team_document"
  updateTeamDocumentByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamDocumentIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamDocumentSetInput
    pkColumns: TeamDocumentPkColumnsInput!
  ): TeamDocument

  # update multiples rows of table: "team_document"
  updateTeamDocumentMany(
    # updates to execute, in order
    updates: [TeamDocumentUpdates!]!
  ): [TeamDocumentMutationResponse]

  # update data of the table: "team_history"
  updateTeamHistory(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamHistoryIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamHistorySetInput

    # filter the rows which have to be updated
    where: TeamHistoryBoolExp!
  ): TeamHistoryMutationResponse

  # update single row of the table: "team_history"
  updateTeamHistoryByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamHistoryIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamHistorySetInput
    pkColumns: TeamHistoryPkColumnsInput!
  ): TeamHistory

  # update multiples rows of table: "team_history"
  updateTeamHistoryMany(
    # updates to execute, in order
    updates: [TeamHistoryUpdates!]!
  ): [TeamHistoryMutationResponse]

  # update data of the table: "team_join"
  updateTeamJoin(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamJoinSetInput

    # filter the rows which have to be updated
    where: TeamJoinBoolExp!
  ): TeamJoinMutationResponse

  # update single row of the table: "team_join"
  updateTeamJoinByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamJoinIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamJoinSetInput
    pkColumns: TeamJoinPkColumnsInput!
  ): TeamJoin

  # update multiples rows of table: "team_join"
  updateTeamJoinMany(
    # updates to execute, in order
    updates: [TeamJoinUpdates!]!
  ): [TeamJoinMutationResponse]

  # update multiples rows of table: "team"
  updateTeamMany(
    # updates to execute, in order
    updates: [TeamUpdates!]!
  ): [TeamMutationResponse]

  # update data of the table: "team_member"
  updateTeamMember(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberSetInput

    # filter the rows which have to be updated
    where: TeamMemberBoolExp!
  ): TeamMemberMutationResponse

  # update single row of the table: "team_member"
  updateTeamMemberByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberSetInput
    pkColumns: TeamMemberPkColumnsInput!
  ): TeamMember

  # update multiples rows of table: "team_member"
  updateTeamMemberMany(
    # updates to execute, in order
    updates: [TeamMemberUpdates!]!
  ): [TeamMemberMutationResponse]

  # update data of the table: "team_member_role"
  updateTeamMemberRole(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberRoleSetInput

    # filter the rows which have to be updated
    where: TeamMemberRoleBoolExp!
  ): TeamMemberRoleMutationResponse

  # update single row of the table: "team_member_role"
  updateTeamMemberRoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamMemberRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamMemberRoleSetInput
    pkColumns: TeamMemberRolePkColumnsInput!
  ): TeamMemberRole

  # update multiples rows of table: "team_member_role"
  updateTeamMemberRoleMany(
    # updates to execute, in order
    updates: [TeamMemberRoleUpdates!]!
  ): [TeamMemberRoleMutationResponse]

  # update data of the table: "team_role"
  updateTeamRole(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamRoleSetInput

    # filter the rows which have to be updated
    where: TeamRoleBoolExp!
  ): TeamRoleMutationResponse

  # update single row of the table: "team_role"
  updateTeamRoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TeamRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TeamRoleSetInput
    pkColumns: TeamRolePkColumnsInput!
  ): TeamRole

  # update multiples rows of table: "team_role"
  updateTeamRoleMany(
    # updates to execute, in order
    updates: [TeamRoleUpdates!]!
  ): [TeamRoleMutationResponse]

  # update data of the table: "tenant"
  updateTenant(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantSetInput

    # filter the rows which have to be updated
    where: TenantBoolExp!
  ): TenantMutationResponse

  # update single row of the table: "tenant"
  updateTenantByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantSetInput
    pkColumns: TenantPkColumnsInput!
  ): Tenant

  # update multiples rows of table: "tenant"
  updateTenantMany(
    # updates to execute, in order
    updates: [TenantUpdates!]!
  ): [TenantMutationResponse]

  # update data of the table: "tenant_member"
  updateTenantMember(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantMemberSetInput

    # filter the rows which have to be updated
    where: TenantMemberBoolExp!
  ): TenantMemberMutationResponse

  # update single row of the table: "tenant_member"
  updateTenantMemberByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantMemberIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantMemberSetInput
    pkColumns: TenantMemberPkColumnsInput!
  ): TenantMember

  # update multiples rows of table: "tenant_member"
  updateTenantMemberMany(
    # updates to execute, in order
    updates: [TenantMemberUpdates!]!
  ): [TenantMemberMutationResponse]

  # update data of the table: "tenant_member_role"
  updateTenantMemberRole(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantMemberRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantMemberRoleSetInput

    # filter the rows which have to be updated
    where: TenantMemberRoleBoolExp!
  ): TenantMemberRoleMutationResponse

  # update single row of the table: "tenant_member_role"
  updateTenantMemberRoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantMemberRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantMemberRoleSetInput
    pkColumns: TenantMemberRolePkColumnsInput!
  ): TenantMemberRole

  # update multiples rows of table: "tenant_member_role"
  updateTenantMemberRoleMany(
    # updates to execute, in order
    updates: [TenantMemberRoleUpdates!]!
  ): [TenantMemberRoleMutationResponse]

  # update data of the table: "tenant_organize"
  updateTenantOrganize(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantOrganizeIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantOrganizeSetInput

    # filter the rows which have to be updated
    where: TenantOrganizeBoolExp!
  ): TenantOrganizeMutationResponse

  # update single row of the table: "tenant_organize"
  updateTenantOrganizeByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantOrganizeIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantOrganizeSetInput
    pkColumns: TenantOrganizePkColumnsInput!
  ): TenantOrganize

  # update multiples rows of table: "tenant_organize"
  updateTenantOrganizeMany(
    # updates to execute, in order
    updates: [TenantOrganizeUpdates!]!
  ): [TenantOrganizeMutationResponse]

  # update data of the table: "tenant_role"
  updateTenantRole(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantRoleSetInput

    # filter the rows which have to be updated
    where: TenantRoleBoolExp!
  ): TenantRoleMutationResponse

  # update single row of the table: "tenant_role"
  updateTenantRoleByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TenantRoleIncInput

    # sets the columns of the filtered rows to the given values
    _set: TenantRoleSetInput
    pkColumns: TenantRolePkColumnsInput!
  ): TenantRole

  # update multiples rows of table: "tenant_role"
  updateTenantRoleMany(
    # updates to execute, in order
    updates: [TenantRoleUpdates!]!
  ): [TenantRoleMutationResponse]

  # update data of the table: "transaction"
  updateTransaction(
    # increments the numeric columns with given value of the filtered values
    _inc: TransactionIncInput

    # sets the columns of the filtered rows to the given values
    _set: TransactionSetInput

    # filter the rows which have to be updated
    where: TransactionBoolExp!
  ): TransactionMutationResponse

  # update data of the table: "transaction_attachments"
  updateTransactionAttachments(
    # increments the numeric columns with given value of the filtered values
    _inc: TransactionAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: TransactionAttachmentsSetInput

    # filter the rows which have to be updated
    where: TransactionAttachmentsBoolExp!
  ): TransactionAttachmentsMutationResponse

  # update single row of the table: "transaction_attachments"
  updateTransactionAttachmentsByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TransactionAttachmentsIncInput

    # sets the columns of the filtered rows to the given values
    _set: TransactionAttachmentsSetInput
    pkColumns: TransactionAttachmentsPkColumnsInput!
  ): TransactionAttachments

  # update multiples rows of table: "transaction_attachments"
  updateTransactionAttachmentsMany(
    # updates to execute, in order
    updates: [TransactionAttachmentsUpdates!]!
  ): [TransactionAttachmentsMutationResponse]

  # update single row of the table: "transaction"
  updateTransactionByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: TransactionIncInput

    # sets the columns of the filtered rows to the given values
    _set: TransactionSetInput
    pkColumns: TransactionPkColumnsInput!
  ): Transaction

  # update multiples rows of table: "transaction"
  updateTransactionMany(
    # updates to execute, in order
    updates: [TransactionUpdates!]!
  ): [TransactionMutationResponse]

  # update data of the table: "user"
  updateUser(
    # increments the numeric columns with given value of the filtered values
    _inc: UserIncInput

    # sets the columns of the filtered rows to the given values
    _set: UserSetInput

    # filter the rows which have to be updated
    where: UserBoolExp!
  ): UserMutationResponse

  # update single row of the table: "user"
  updateUserByPk(
    # increments the numeric columns with given value of the filtered values
    _inc: UserIncInput

    # sets the columns of the filtered rows to the given values
    _set: UserSetInput
    pkColumns: UserPkColumnsInput!
  ): User

  # update multiples rows of table: "user"
  updateUserMany(
    # updates to execute, in order
    updates: [UserUpdates!]!
  ): [UserMutationResponse]
}

# column ordering options
enum OrderBy {
  # in ascending order, nulls last
  ASC

  # in ascending order, nulls first
  ASC_NULLS_FIRST

  # in ascending order, nulls last
  ASC_NULLS_LAST

  # in descending order, nulls first
  DESC

  # in descending order, nulls first
  DESC_NULLS_FIRST

  # in descending order, nulls last
  DESC_NULLS_LAST
}

# columns and relationships of "pole"
type Pole {
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  hiddenAt: timestamptz
  id: bigint!
  isLocked: Boolean!
  name: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "pole"
type PoleAggregate {
  aggregate: PoleAggregateFields
  nodes: [Pole!]!
}

input PoleAggregateBoolExp {
  bool_and: poleAggregateBoolExpBool_and
  bool_or: poleAggregateBoolExpBool_or
  count: poleAggregateBoolExpCount
}

input poleAggregateBoolExpBool_and {
  arguments: PoleSelectColumnPoleAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: PoleBoolExp
  predicate: BooleanComparisonExp!
}

input poleAggregateBoolExpBool_or {
  arguments: PoleSelectColumnPoleAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: PoleBoolExp
  predicate: BooleanComparisonExp!
}

input poleAggregateBoolExpCount {
  arguments: [PoleSelectColumn!]
  distinct: Boolean
  filter: PoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "pole"
type PoleAggregateFields {
  avg: PoleAvgFields
  count(columns: [PoleSelectColumn!], distinct: Boolean): Int!
  max: PoleMaxFields
  min: PoleMinFields
  stddev: PoleStddevFields
  stddevPop: PoleStddevPopFields
  stddevSamp: PoleStddevSampFields
  sum: PoleSumFields
  varPop: PoleVarPopFields
  varSamp: PoleVarSampFields
  variance: PoleVarianceFields
}

# order by aggregate values of table "pole"
input PoleAggregateOrderBy {
  avg: PoleAvgOrderBy
  count: OrderBy
  max: PoleMaxOrderBy
  min: PoleMinOrderBy
  stddev: PoleStddevOrderBy
  stddevPop: PoleStddevPopOrderBy
  stddevSamp: PoleStddevSampOrderBy
  sum: PoleSumOrderBy
  varPop: PoleVarPopOrderBy
  varSamp: PoleVarSampOrderBy
  variance: PoleVarianceOrderBy
}

# input type for inserting array relation for remote table "pole"
input PoleArrRelInsertInput {
  data: [PoleInsertInput!]!

  # upsert condition
  onConflict: PoleOnConflict
}

# aggregate avg on columns
type PoleAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "pole"
input PoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "pole". All fields are combined with a logical 'AND'.
input PoleBoolExp {
  _and: [PoleBoolExp!]
  _not: PoleBoolExp
  _or: [PoleBoolExp!]
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isLocked: BooleanComparisonExp
  name: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "pole"
enum PoleConstraint {
  # unique or primary key constraint on columns "id"
  pole_pkey
}

# input type for incrementing numeric columns in table "pole"
input PoleIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "pole"
input PoleInsertInput {
  category: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isLocked: Boolean
  name: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type PoleMaxFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "pole"
input PoleMaxOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type PoleMinFields {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "pole"
input PoleMinOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "pole"
type PoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Pole!]!
}

# on_conflict condition type for table "pole"
input PoleOnConflict {
  constraint: PoleConstraint!
  updateColumns: [PoleUpdateColumn!]! = []
  where: PoleBoolExp
}

# Ordering options when selecting data from "pole".
input PoleOrderBy {
  category: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isLocked: OrderBy
  name: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: pole
input PolePkColumnsInput {
  id: bigint!
}

# select columns of table "pole"
enum PoleSelectColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  isLocked

  # column name
  name

  # column name
  teamId

  # column name
  tenantScopeId
}

# select "poleAggregateBoolExpBool_andArgumentsColumns" columns of table "pole"
enum PoleSelectColumnPoleAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isLocked
}

# select "poleAggregateBoolExpBool_orArgumentsColumns" columns of table "pole"
enum PoleSelectColumnPoleAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isLocked
}

# input type for updating data in table "pole"
input PoleSetInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isLocked: Boolean
  name: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type PoleStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "pole"
input PoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type PoleStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "pole"
input PoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type PoleStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "pole"
input PoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "pole"
input PoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: PoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input PoleStreamCursorValueInput {
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  isLocked: Boolean
  name: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type PoleSumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "pole"
input PoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "pole"
enum PoleUpdateColumn {
  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  isLocked

  # column name
  name

  # column name
  teamId

  # column name
  tenantScopeId
}

input PoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: PoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: PoleSetInput

  # filter the rows which have to be updated
  where: PoleBoolExp!
}

# aggregate variance on columns
type PoleVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "pole"
input PoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type PoleVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "pole"
input PoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type PoleVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "pole"
input PoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "project"
type Project {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  banner: FileUpload
  bannerId: bigint
  budget: Float!
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  end: timestamptz

  # An array relationship
  eventOrganizes(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # An aggregate relationship
  eventOrganizesAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!

  # An object relationship
  grant: Grant
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint!
  isPrivate: Boolean!
  isTemplate: Boolean!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!
  name: String!

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!
  regularEventInterval: String!
  slug: String!
  start: timestamptz

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  transactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!
  type: String!
}

# aggregated selection of "project"
type ProjectAggregate {
  aggregate: ProjectAggregateFields
  nodes: [Project!]!
}

input ProjectAggregateBoolExp {
  bool_and: projectAggregateBoolExpBool_and
  bool_or: projectAggregateBoolExpBool_or
  count: projectAggregateBoolExpCount
}

input projectAggregateBoolExpBool_and {
  arguments: ProjectSelectColumnProjectAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: BooleanComparisonExp!
}

input projectAggregateBoolExpBool_or {
  arguments: ProjectSelectColumnProjectAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: BooleanComparisonExp!
}

input projectAggregateBoolExpCount {
  arguments: [ProjectSelectColumn!]
  distinct: Boolean
  filter: ProjectBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "project"
type ProjectAggregateFields {
  avg: ProjectAvgFields
  count(columns: [ProjectSelectColumn!], distinct: Boolean): Int!
  max: ProjectMaxFields
  min: ProjectMinFields
  stddev: ProjectStddevFields
  stddevPop: ProjectStddevPopFields
  stddevSamp: ProjectStddevSampFields
  sum: ProjectSumFields
  varPop: ProjectVarPopFields
  varSamp: ProjectVarSampFields
  variance: ProjectVarianceFields
}

# order by aggregate values of table "project"
input ProjectAggregateOrderBy {
  avg: ProjectAvgOrderBy
  count: OrderBy
  max: ProjectMaxOrderBy
  min: ProjectMinOrderBy
  stddev: ProjectStddevOrderBy
  stddevPop: ProjectStddevPopOrderBy
  stddevSamp: ProjectStddevSampOrderBy
  sum: ProjectSumOrderBy
  varPop: ProjectVarPopOrderBy
  varSamp: ProjectVarSampOrderBy
  variance: ProjectVarianceOrderBy
}

# input type for inserting array relation for remote table "project"
input ProjectArrRelInsertInput {
  data: [ProjectInsertInput!]!

  # upsert condition
  onConflict: ProjectOnConflict
}

# aggregate avg on columns
type ProjectAvgFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "project"
input ProjectAvgOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "project". All fields are combined with a logical 'AND'.
input ProjectBoolExp {
  _and: [ProjectBoolExp!]
  _not: ProjectBoolExp
  _or: [ProjectBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  banner: FileUploadBoolExp
  bannerId: BigintComparisonExp
  budget: FloatComparisonExp
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  end: TimestamptzComparisonExp
  eventOrganizes: EventOrganizeBoolExp
  eventOrganizesAggregate: EventOrganizeAggregateBoolExp
  grant: GrantBoolExp
  grantId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isPrivate: BooleanComparisonExp
  isTemplate: BooleanComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  name: StringComparisonExp
  projectSupervisors: ProjectSupervisorsBoolExp
  projectSupervisorsAggregate: ProjectSupervisorsAggregateBoolExp
  regularEventInterval: StringComparisonExp
  slug: StringComparisonExp
  start: TimestamptzComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactions: TransactionBoolExp
  transactionsAggregate: TransactionAggregateBoolExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "project"
enum ProjectConstraint {
  # unique or primary key constraint on columns "id"
  project_pkey
}

# input type for incrementing numeric columns in table "project"
input ProjectIncInput {
  bannerId: bigint
  budget: Float
  createdById: bigint
  grantId: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "project"
input ProjectInsertInput {
  actions: ActionArrRelInsertInput
  banner: FileUploadObjRelInsertInput
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  eventOrganizes: EventOrganizeArrRelInsertInput
  grant: GrantObjRelInsertInput
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  missionJoins: MissionJoinArrRelInsertInput
  missions: MissionArrRelInsertInput
  name: String
  projectSupervisors: ProjectSupervisorsArrRelInsertInput
  regularEventInterval: String
  slug: String
  start: timestamptz
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactions: TransactionArrRelInsertInput
  type: String
}

# aggregate max on columns
type ProjectMaxFields {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  regularEventInterval: String
  slug: String
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "project"
input ProjectMaxOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  start: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type ProjectMinFields {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  regularEventInterval: String
  slug: String
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "project"
input ProjectMinOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  start: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "project"
type ProjectMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Project!]!
}

# input type for inserting object relation for remote table "project"
input ProjectObjRelInsertInput {
  data: ProjectInsertInput!

  # upsert condition
  onConflict: ProjectOnConflict
}

# on_conflict condition type for table "project"
input ProjectOnConflict {
  constraint: ProjectConstraint!
  updateColumns: [ProjectUpdateColumn!]! = []
  where: ProjectBoolExp
}

# Ordering options when selecting data from "project".
input ProjectOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  banner: FileUploadOrderBy
  bannerId: OrderBy
  budget: OrderBy
  color: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  end: OrderBy
  eventOrganizesAggregate: EventOrganizeAggregateOrderBy
  grant: GrantOrderBy
  grantId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isPrivate: OrderBy
  isTemplate: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  missionsAggregate: MissionAggregateOrderBy
  name: OrderBy
  projectSupervisorsAggregate: ProjectSupervisorsAggregateOrderBy
  regularEventInterval: OrderBy
  slug: OrderBy
  start: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionsAggregate: TransactionAggregateOrderBy
  type: OrderBy
}

# primary key columns input for table: project
input ProjectPkColumnsInput {
  id: bigint!
}

# select columns of table "project"
enum ProjectSelectColumn {
  # column name
  bannerId

  # column name
  budget

  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  end

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  name

  # column name
  regularEventInterval

  # column name
  slug

  # column name
  start

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

# select "projectAggregateBoolExpBool_andArgumentsColumns" columns of table "project"
enum ProjectSelectColumnProjectAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isPrivate

  # column name
  isTemplate
}

# select "projectAggregateBoolExpBool_orArgumentsColumns" columns of table "project"
enum ProjectSelectColumnProjectAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isPrivate

  # column name
  isTemplate
}

# input type for updating data in table "project"
input ProjectSetInput {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  name: String
  regularEventInterval: String
  slug: String
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type ProjectStddevFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "project"
input ProjectStddevOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type ProjectStddevPopFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "project"
input ProjectStddevPopOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type ProjectStddevSampFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "project"
input ProjectStddevSampOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "project"
input ProjectStreamCursorInput {
  # Stream column input with initial value
  initialValue: ProjectStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ProjectStreamCursorValueInput {
  bannerId: bigint
  budget: Float
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  end: timestamptz
  grantId: bigint
  hiddenAt: timestamptz
  id: bigint
  isPrivate: Boolean
  isTemplate: Boolean
  name: String
  regularEventInterval: String
  slug: String
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type ProjectSumFields {
  bannerId: bigint
  budget: Float
  createdById: bigint
  grantId: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "project"
input ProjectSumOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "project_supervisors"
type ProjectSupervisors {
  # An object relationship
  project: Project!
  projectId: bigint!

  # An object relationship
  teamMember: TeamMember!
  teamMemberId: bigint!
}

# aggregated selection of "project_supervisors"
type ProjectSupervisorsAggregate {
  aggregate: ProjectSupervisorsAggregateFields
  nodes: [ProjectSupervisors!]!
}

input ProjectSupervisorsAggregateBoolExp {
  count: projectSupervisorsAggregateBoolExpCount
}

input projectSupervisorsAggregateBoolExpCount {
  arguments: [ProjectSupervisorsSelectColumn!]
  distinct: Boolean
  filter: ProjectSupervisorsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "project_supervisors"
type ProjectSupervisorsAggregateFields {
  avg: ProjectSupervisorsAvgFields
  count(columns: [ProjectSupervisorsSelectColumn!], distinct: Boolean): Int!
  max: ProjectSupervisorsMaxFields
  min: ProjectSupervisorsMinFields
  stddev: ProjectSupervisorsStddevFields
  stddevPop: ProjectSupervisorsStddevPopFields
  stddevSamp: ProjectSupervisorsStddevSampFields
  sum: ProjectSupervisorsSumFields
  varPop: ProjectSupervisorsVarPopFields
  varSamp: ProjectSupervisorsVarSampFields
  variance: ProjectSupervisorsVarianceFields
}

# order by aggregate values of table "project_supervisors"
input ProjectSupervisorsAggregateOrderBy {
  avg: ProjectSupervisorsAvgOrderBy
  count: OrderBy
  max: ProjectSupervisorsMaxOrderBy
  min: ProjectSupervisorsMinOrderBy
  stddev: ProjectSupervisorsStddevOrderBy
  stddevPop: ProjectSupervisorsStddevPopOrderBy
  stddevSamp: ProjectSupervisorsStddevSampOrderBy
  sum: ProjectSupervisorsSumOrderBy
  varPop: ProjectSupervisorsVarPopOrderBy
  varSamp: ProjectSupervisorsVarSampOrderBy
  variance: ProjectSupervisorsVarianceOrderBy
}

# input type for inserting array relation for remote table "project_supervisors"
input ProjectSupervisorsArrRelInsertInput {
  data: [ProjectSupervisorsInsertInput!]!

  # upsert condition
  onConflict: ProjectSupervisorsOnConflict
}

# aggregate avg on columns
type ProjectSupervisorsAvgFields {
  projectId: Float
  teamMemberId: Float
}

# order by avg() on columns of table "project_supervisors"
input ProjectSupervisorsAvgOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# Boolean expression to filter rows from the table "project_supervisors". All fields are combined with a logical 'AND'.
input ProjectSupervisorsBoolExp {
  _and: [ProjectSupervisorsBoolExp!]
  _not: ProjectSupervisorsBoolExp
  _or: [ProjectSupervisorsBoolExp!]
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  teamMember: TeamMemberBoolExp
  teamMemberId: BigintComparisonExp
}

# unique or primary key constraints on table "project_supervisors"
enum ProjectSupervisorsConstraint {
  # unique or primary key constraint on columns "project_id", "team_member_id"
  project_supervisors_pkey
}

# input type for incrementing numeric columns in table "project_supervisors"
input ProjectSupervisorsIncInput {
  projectId: bigint
  teamMemberId: bigint
}

# input type for inserting data into table "project_supervisors"
input ProjectSupervisorsInsertInput {
  project: ProjectObjRelInsertInput
  projectId: bigint
  teamMember: TeamMemberObjRelInsertInput
  teamMemberId: bigint
}

# aggregate max on columns
type ProjectSupervisorsMaxFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by max() on columns of table "project_supervisors"
input ProjectSupervisorsMaxOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate min on columns
type ProjectSupervisorsMinFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by min() on columns of table "project_supervisors"
input ProjectSupervisorsMinOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# response of any mutation on the table "project_supervisors"
type ProjectSupervisorsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [ProjectSupervisors!]!
}

# on_conflict condition type for table "project_supervisors"
input ProjectSupervisorsOnConflict {
  constraint: ProjectSupervisorsConstraint!
  updateColumns: [ProjectSupervisorsUpdateColumn!]! = []
  where: ProjectSupervisorsBoolExp
}

# Ordering options when selecting data from "project_supervisors".
input ProjectSupervisorsOrderBy {
  project: ProjectOrderBy
  projectId: OrderBy
  teamMember: TeamMemberOrderBy
  teamMemberId: OrderBy
}

# primary key columns input for table: project_supervisors
input ProjectSupervisorsPkColumnsInput {
  projectId: bigint!
  teamMemberId: bigint!
}

# select columns of table "project_supervisors"
enum ProjectSupervisorsSelectColumn {
  # column name
  projectId

  # column name
  teamMemberId
}

# input type for updating data in table "project_supervisors"
input ProjectSupervisorsSetInput {
  projectId: bigint
  teamMemberId: bigint
}

# aggregate stddev on columns
type ProjectSupervisorsStddevFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddev() on columns of table "project_supervisors"
input ProjectSupervisorsStddevOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevPop on columns
type ProjectSupervisorsStddevPopFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddevPop() on columns of table "project_supervisors"
input ProjectSupervisorsStddevPopOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate stddevSamp on columns
type ProjectSupervisorsStddevSampFields {
  projectId: Float
  teamMemberId: Float
}

# order by stddevSamp() on columns of table "project_supervisors"
input ProjectSupervisorsStddevSampOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# Streaming cursor of the table "project_supervisors"
input ProjectSupervisorsStreamCursorInput {
  # Stream column input with initial value
  initialValue: ProjectSupervisorsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input ProjectSupervisorsStreamCursorValueInput {
  projectId: bigint
  teamMemberId: bigint
}

# aggregate sum on columns
type ProjectSupervisorsSumFields {
  projectId: bigint
  teamMemberId: bigint
}

# order by sum() on columns of table "project_supervisors"
input ProjectSupervisorsSumOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# update columns of table "project_supervisors"
enum ProjectSupervisorsUpdateColumn {
  # column name
  projectId

  # column name
  teamMemberId
}

input ProjectSupervisorsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ProjectSupervisorsIncInput

  # sets the columns of the filtered rows to the given values
  _set: ProjectSupervisorsSetInput

  # filter the rows which have to be updated
  where: ProjectSupervisorsBoolExp!
}

# aggregate variance on columns
type ProjectSupervisorsVarianceFields {
  projectId: Float
  teamMemberId: Float
}

# order by variance() on columns of table "project_supervisors"
input ProjectSupervisorsVarianceOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varPop on columns
type ProjectSupervisorsVarPopFields {
  projectId: Float
  teamMemberId: Float
}

# order by varPop() on columns of table "project_supervisors"
input ProjectSupervisorsVarPopOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# aggregate varSamp on columns
type ProjectSupervisorsVarSampFields {
  projectId: Float
  teamMemberId: Float
}

# order by varSamp() on columns of table "project_supervisors"
input ProjectSupervisorsVarSampOrderBy {
  projectId: OrderBy
  teamMemberId: OrderBy
}

# update columns of table "project"
enum ProjectUpdateColumn {
  # column name
  bannerId

  # column name
  budget

  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  end

  # column name
  grantId

  # column name
  hiddenAt

  # column name
  id

  # column name
  isPrivate

  # column name
  isTemplate

  # column name
  name

  # column name
  regularEventInterval

  # column name
  slug

  # column name
  start

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

input ProjectUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: ProjectIncInput

  # sets the columns of the filtered rows to the given values
  _set: ProjectSetInput

  # filter the rows which have to be updated
  where: ProjectBoolExp!
}

# aggregate variance on columns
type ProjectVarianceFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "project"
input ProjectVarianceOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type ProjectVarPopFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "project"
input ProjectVarPopOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type ProjectVarSampFields {
  bannerId: Float
  budget: Float
  createdById: Float
  grantId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "project"
input ProjectVarSampOrderBy {
  bannerId: OrderBy
  budget: OrderBy
  createdById: OrderBy
  grantId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

type Query {
  # fetch data from the table: "action"
  action(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch aggregated fields from the table: "action"
  actionAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # fetch data from the table: "action" using primary key columns
  actionByPk(id: bigint!): Action

  # fetch data from the table: "actor"
  actor(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # fetch aggregated fields from the table: "actor"
  actorAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # fetch data from the table: "actor" using primary key columns
  actorByPk(id: bigint!): Actor

  # fetch data from the table: "actor_image"
  actorImage(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch aggregated fields from the table: "actor_image"
  actorImageAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # fetch data from the table: "actor_image" using primary key columns
  actorImageByPk(id: bigint!): ActorImage

  # fetch data from the table: "actor_tag"
  actorTag(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # fetch aggregated fields from the table: "actor_tag"
  actorTagAggregate(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): ActorTagAggregate!

  # fetch data from the table: "actor_tag" using primary key columns
  actorTagByPk(id: bigint!): ActorTag

  # fetch data from the table: "address"
  address(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch aggregated fields from the table: "address"
  addressAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # fetch data from the table: "address" using primary key columns
  addressByPk(id: bigint!): Address

  # fetch data from the table: "bank_account"
  bankAccount(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # fetch aggregated fields from the table: "bank_account"
  bankAccountAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!

  # fetch data from the table: "bank_account" using primary key columns
  bankAccountByPk(id: bigint!): BankAccount

  # fetch data from the table: "bank_info"
  bankInfo(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch aggregated fields from the table: "bank_info"
  bankInfoAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # fetch data from the table: "bank_info" using primary key columns
  bankInfoByPk(id: bigint!): BankInfo

  # fetch data from the table: "campus"
  campus(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch aggregated fields from the table: "campus"
  campusAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # fetch data from the table: "campus" using primary key columns
  campusByPk(id: bigint!): Campus

  # fetch data from the table: "campus_cluster"
  campusCluster(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch aggregated fields from the table: "campus_cluster"
  campusClusterAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # fetch data from the table: "campus_cluster" using primary key columns
  campusClusterByPk(id: bigint!): CampusCluster

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # fetch aggregated fields from the table: "event"
  eventAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # fetch data from the table: "event_approval"
  eventApproval(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch aggregated fields from the table: "event_approval"
  eventApprovalAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # fetch data from the table: "event_approval" using primary key columns
  eventApprovalByPk(id: bigint!): EventApproval

  # fetch data from the table: "event_approval_step"
  eventApprovalStep(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # fetch aggregated fields from the table: "event_approval_step"
  eventApprovalStepAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # fetch data from the table: "event_approval_step" using primary key columns
  eventApprovalStepByPk(id: bigint!): EventApprovalStep

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # fetch data from the table: "event_approval_step_notifiees" using primary key columns
  eventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepNotifiees

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # fetch data from the table: "event_approval_step_validators" using primary key columns
  eventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepValidators

  # fetch data from the table: "event" using primary key columns
  eventByPk(id: bigint!): Event

  # fetch data from the table: "event_favorite"
  eventFavorite(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # fetch aggregated fields from the table: "event_favorite"
  eventFavoriteAggregate(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): EventFavoriteAggregate!

  # fetch data from the table: "event_favorite" using primary key columns
  eventFavoriteByPk(id: bigint!): EventFavorite

  # fetch data from the table: "event_join"
  eventJoin(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch aggregated fields from the table: "event_join"
  eventJoinAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # fetch data from the table: "event_join" using primary key columns
  eventJoinByPk(id: bigint!): EventJoin

  # fetch data from the table: "event_organize"
  eventOrganize(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # fetch aggregated fields from the table: "event_organize"
  eventOrganizeAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!

  # fetch data from the table: "event_organize" using primary key columns
  eventOrganizeByPk(id: bigint!): EventOrganize

  # fetch data from the table: "event_supervisor"
  eventSupervisor(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # fetch aggregated fields from the table: "event_supervisor"
  eventSupervisorAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!

  # fetch data from the table: "event_supervisor" using primary key columns
  eventSupervisorByPk(id: bigint!): EventSupervisor

  # fetch data from the table: "expense"
  expense(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch aggregated fields from the table: "expense"
  expenseAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # fetch data from the table: "expense" using primary key columns
  expenseByPk(id: bigint!): Expense

  # fetch data from the table: "expense_item"
  expenseItem(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch aggregated fields from the table: "expense_item"
  expenseItemAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # fetch data from the table: "expense_item_attachments" using primary key columns
  expenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # fetch data from the table: "expense_item" using primary key columns
  expenseItemByPk(id: bigint!): ExpenseItem

  # fetch data from the table: "file_upload"
  fileUpload(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch aggregated fields from the table: "file_upload"
  fileUploadAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # fetch data from the table: "file_upload" using primary key columns
  fileUploadByPk(id: bigint!): FileUpload

  # fetch data from the table: "follow"
  follow(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch aggregated fields from the table: "follow"
  followAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # fetch data from the table: "follow" using primary key columns
  followByPk(id: bigint!): Follow

  # fetch data from the table: "form"
  form(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch aggregated fields from the table: "form"
  formAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # fetch data from the table: "form" using primary key columns
  formByPk(id: bigint!): Form

  # fetch data from the table: "form_submission"
  formSubmission(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch aggregated fields from the table: "form_submission"
  formSubmissionAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  formSubmissionAttachments(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): [FormSubmissionAttachments!]!

  # An aggregate relationship
  formSubmissionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): FormSubmissionAttachmentsAggregate!

  # fetch data from the table: "form_submission_attachments" using primary key columns
  formSubmissionAttachmentsByPk(fileUploadId: bigint!, formSubmissionId: bigint!): FormSubmissionAttachments

  # fetch data from the table: "form_submission" using primary key columns
  formSubmissionByPk(id: bigint!): FormSubmission

  # fetch data from the table: "grant"
  grant(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch aggregated fields from the table: "grant"
  grantAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # fetch data from the table: "grant_allocate"
  grantAllocate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # fetch aggregated fields from the table: "grant_allocate"
  grantAllocateAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  grantAllocateAttachments(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): [GrantAllocateAttachments!]!

  # An aggregate relationship
  grantAllocateAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): GrantAllocateAttachmentsAggregate!

  # fetch data from the table: "grant_allocate_attachments" using primary key columns
  grantAllocateAttachmentsByPk(fileUploadId: bigint!, grantAllocateId: bigint!): GrantAllocateAttachments

  # fetch data from the table: "grant_allocate" using primary key columns
  grantAllocateByPk(id: bigint!): GrantAllocate

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # fetch data from the table: "grant_attachments" using primary key columns
  grantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # fetch data from the table: "grant" using primary key columns
  grantByPk(id: bigint!): Grant

  # fetch data from the table: "legal_unit"
  legalUnit(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch aggregated fields from the table: "legal_unit"
  legalUnitAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # fetch data from the table: "legal_unit" using primary key columns
  legalUnitByPk(id: bigint!): LegalUnit

  # fetch data from the table: "legal_unit_location"
  legalUnitLocation(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # fetch aggregated fields from the table: "legal_unit_location"
  legalUnitLocationAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): LegalUnitLocationAggregate!

  # fetch data from the table: "legal_unit_location" using primary key columns
  legalUnitLocationByPk(id: bigint!): LegalUnitLocation

  # fetch data from the table: "location"
  location(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # fetch aggregated fields from the table: "location"
  locationAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!

  # fetch data from the table: "location" using primary key columns
  locationByPk(id: bigint!): Location

  # An array relationship
  locationImages(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): [LocationImages!]!

  # An aggregate relationship
  locationImagesAggregate(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): LocationImagesAggregate!

  # fetch data from the table: "location_images" using primary key columns
  locationImagesByPk(fileUploadId: bigint!, locationId: bigint!): LocationImages

  # fetch data from the table: "mission"
  mission(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch aggregated fields from the table: "mission"
  missionAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # fetch data from the table: "mission" using primary key columns
  missionByPk(id: bigint!): Mission

  # fetch data from the table: "mission_join"
  missionJoin(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch aggregated fields from the table: "mission_join"
  missionJoinAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # fetch data from the table: "mission_join" using primary key columns
  missionJoinByPk(id: bigint!): MissionJoin

  # fetch data from the table: "pole"
  pole(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch aggregated fields from the table: "pole"
  poleAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # fetch data from the table: "pole" using primary key columns
  poleByPk(id: bigint!): Pole

  # fetch data from the table: "project"
  project(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # fetch aggregated fields from the table: "project"
  projectAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # fetch data from the table: "project" using primary key columns
  projectByPk(id: bigint!): Project

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # fetch data from the table: "project_supervisors" using primary key columns
  projectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # fetch data from the table: "social"
  social(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch aggregated fields from the table: "social"
  socialAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # fetch data from the table: "social" using primary key columns
  socialByPk(id: bigint!): Social

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch aggregated fields from the table: "tag"
  tagAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # fetch data from the table: "tag" using primary key columns
  tagByPk(id: bigint!): Tag

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch aggregated fields from the table: "team"
  teamAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # fetch data from the table: "team" using primary key columns
  teamByPk(id: bigint!): Team

  # fetch data from the table: "team_document"
  teamDocument(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # fetch aggregated fields from the table: "team_document"
  teamDocumentAggregate(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): TeamDocumentAggregate!

  # fetch data from the table: "team_document" using primary key columns
  teamDocumentByPk(id: bigint!): TeamDocument

  # fetch data from the table: "team_history"
  teamHistory(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch aggregated fields from the table: "team_history"
  teamHistoryAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # fetch data from the table: "team_history" using primary key columns
  teamHistoryByPk(id: bigint!): TeamHistory

  # fetch data from the table: "team_join"
  teamJoin(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch aggregated fields from the table: "team_join"
  teamJoinAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # fetch data from the table: "team_join" using primary key columns
  teamJoinByPk(id: bigint!): TeamJoin

  # fetch data from the table: "team_member"
  teamMember(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch aggregated fields from the table: "team_member"
  teamMemberAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # fetch data from the table: "team_member" using primary key columns
  teamMemberByPk(id: bigint!): TeamMember

  # fetch data from the table: "team_member_role"
  teamMemberRole(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # fetch aggregated fields from the table: "team_member_role"
  teamMemberRoleAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # fetch data from the table: "team_member_role" using primary key columns
  teamMemberRoleByPk(id: bigint!): TeamMemberRole

  # fetch data from the table: "team_role"
  teamRole(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # fetch aggregated fields from the table: "team_role"
  teamRoleAggregate(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): TeamRoleAggregate!

  # fetch data from the table: "team_role" using primary key columns
  teamRoleByPk(id: bigint!): TeamRole

  # fetch data from the table: "tenant"
  tenant(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch aggregated fields from the table: "tenant"
  tenantAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # fetch data from the table: "tenant" using primary key columns
  tenantByPk(id: bigint!): Tenant

  # fetch data from the table: "tenant_member"
  tenantMember(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # fetch aggregated fields from the table: "tenant_member"
  tenantMemberAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): TenantMemberAggregate!

  # fetch data from the table: "tenant_member" using primary key columns
  tenantMemberByPk(id: bigint!): TenantMember

  # fetch data from the table: "tenant_member_role"
  tenantMemberRole(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # fetch aggregated fields from the table: "tenant_member_role"
  tenantMemberRoleAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # fetch data from the table: "tenant_member_role" using primary key columns
  tenantMemberRoleByPk(id: bigint!): TenantMemberRole

  # fetch data from the table: "tenant_organize"
  tenantOrganize(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # fetch aggregated fields from the table: "tenant_organize"
  tenantOrganizeAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # fetch data from the table: "tenant_organize" using primary key columns
  tenantOrganizeByPk(id: bigint!): TenantOrganize

  # fetch data from the table: "tenant_role"
  tenantRole(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): [TenantRole!]!

  # fetch aggregated fields from the table: "tenant_role"
  tenantRoleAggregate(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): TenantRoleAggregate!

  # fetch data from the table: "tenant_role" using primary key columns
  tenantRoleByPk(id: bigint!): TenantRole

  # fetch data from the table: "transaction"
  transaction(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # fetch aggregated fields from the table: "transaction"
  transactionAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  transactionAttachments(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): [TransactionAttachments!]!

  # An aggregate relationship
  transactionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): TransactionAttachmentsAggregate!

  # fetch data from the table: "transaction_attachments" using primary key columns
  transactionAttachmentsByPk(fileUploadId: bigint!, transactionId: bigint!): TransactionAttachments

  # fetch data from the table: "transaction" using primary key columns
  transactionByPk(id: bigint!): Transaction

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # fetch aggregated fields from the table: "user"
  userAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # fetch data from the table: "user" using primary key columns
  userByPk(id: bigint!): User
}

scalar smallint

# Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
input SmallintComparisonExp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _isNull: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# columns and relationships of "social"
type Social {
  # An object relationship
  actor: Actor!
  actorId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  order: smallint!
  pseudo: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!
  url: String!
}

# aggregated selection of "social"
type SocialAggregate {
  aggregate: SocialAggregateFields
  nodes: [Social!]!
}

input SocialAggregateBoolExp {
  count: socialAggregateBoolExpCount
}

input socialAggregateBoolExpCount {
  arguments: [SocialSelectColumn!]
  distinct: Boolean
  filter: SocialBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "social"
type SocialAggregateFields {
  avg: SocialAvgFields
  count(columns: [SocialSelectColumn!], distinct: Boolean): Int!
  max: SocialMaxFields
  min: SocialMinFields
  stddev: SocialStddevFields
  stddevPop: SocialStddevPopFields
  stddevSamp: SocialStddevSampFields
  sum: SocialSumFields
  varPop: SocialVarPopFields
  varSamp: SocialVarSampFields
  variance: SocialVarianceFields
}

# order by aggregate values of table "social"
input SocialAggregateOrderBy {
  avg: SocialAvgOrderBy
  count: OrderBy
  max: SocialMaxOrderBy
  min: SocialMinOrderBy
  stddev: SocialStddevOrderBy
  stddevPop: SocialStddevPopOrderBy
  stddevSamp: SocialStddevSampOrderBy
  sum: SocialSumOrderBy
  varPop: SocialVarPopOrderBy
  varSamp: SocialVarSampOrderBy
  variance: SocialVarianceOrderBy
}

# input type for inserting array relation for remote table "social"
input SocialArrRelInsertInput {
  data: [SocialInsertInput!]!

  # upsert condition
  onConflict: SocialOnConflict
}

# aggregate avg on columns
type SocialAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "social"
input SocialAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "social". All fields are combined with a logical 'AND'.
input SocialBoolExp {
  _and: [SocialBoolExp!]
  _not: SocialBoolExp
  _or: [SocialBoolExp!]
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  order: SmallintComparisonExp
  pseudo: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
  url: StringComparisonExp
}

# unique or primary key constraints on table "social"
enum SocialConstraint {
  # unique or primary key constraint on columns "id"
  social_pkey
}

# input type for incrementing numeric columns in table "social"
input SocialIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  order: smallint
  tenantScopeId: bigint
}

# input type for inserting data into table "social"
input SocialInsertInput {
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
  url: String
}

# aggregate max on columns
type SocialMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantScopeId: bigint
  type: String
  url: String
}

# order by max() on columns of table "social"
input SocialMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  url: OrderBy
}

# aggregate min on columns
type SocialMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantScopeId: bigint
  type: String
  url: String
}

# order by min() on columns of table "social"
input SocialMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  url: OrderBy
}

# response of any mutation on the table "social"
type SocialMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Social!]!
}

# on_conflict condition type for table "social"
input SocialOnConflict {
  constraint: SocialConstraint!
  updateColumns: [SocialUpdateColumn!]! = []
  where: SocialBoolExp
}

# Ordering options when selecting data from "social".
input SocialOrderBy {
  actor: ActorOrderBy
  actorId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  order: OrderBy
  pseudo: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  url: OrderBy
}

# primary key columns input for table: social
input SocialPkColumnsInput {
  id: bigint!
}

# select columns of table "social"
enum SocialSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  order

  # column name
  pseudo

  # column name
  tenantScopeId

  # column name
  type

  # column name
  url
}

# input type for updating data in table "social"
input SocialSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantScopeId: bigint
  type: String
  url: String
}

# aggregate stddev on columns
type SocialStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "social"
input SocialStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type SocialStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "social"
input SocialStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type SocialStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "social"
input SocialStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "social"
input SocialStreamCursorInput {
  # Stream column input with initial value
  initialValue: SocialStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input SocialStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  order: smallint
  pseudo: String
  tenantScopeId: bigint
  type: String
  url: String
}

# aggregate sum on columns
type SocialSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  order: smallint
  tenantScopeId: bigint
}

# order by sum() on columns of table "social"
input SocialSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "social"
enum SocialUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  order

  # column name
  pseudo

  # column name
  tenantScopeId

  # column name
  type

  # column name
  url
}

input SocialUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: SocialIncInput

  # sets the columns of the filtered rows to the given values
  _set: SocialSetInput

  # filter the rows which have to be updated
  where: SocialBoolExp!
}

# aggregate variance on columns
type SocialVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "social"
input SocialVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type SocialVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "social"
input SocialVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type SocialVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  order: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "social"
input SocialVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  order: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
input StringArrayComparisonExp {
  # is the array contained in the given array value
  _containedIn: [String!]

  # does the array contain the given value
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

# Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  # does the column match the given case-insensitive pattern
  _ilike: String
  _in: [String!]

  # does the column match the given POSIX regular expression, case insensitive
  _iregex: String
  _isNull: Boolean

  # does the column match the given pattern
  _like: String
  _lt: String
  _lte: String
  _neq: String

  # does the column NOT match the given case-insensitive pattern
  _nilike: String
  _nin: [String!]

  # does the column NOT match the given POSIX regular expression, case insensitive
  _niregex: String

  # does the column NOT match the given pattern
  _nlike: String

  # does the column NOT match the given POSIX regular expression, case sensitive
  _nregex: String

  # does the column NOT match the given SQL regular expression
  _nsimilar: String

  # does the column match the given POSIX regular expression, case sensitive
  _regex: String

  # does the column match the given SQL regular expression
  _similar: String
}

type Subscription {
  # fetch data from the table: "action"
  action(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch aggregated fields from the table: "action"
  actionAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # fetch data from the table: "action" using primary key columns
  actionByPk(id: bigint!): Action

  # fetch data from the table in a streaming manner: "action"
  actionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActionStreamCursorInput]!

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # fetch data from the table: "actor"
  actor(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # fetch aggregated fields from the table: "actor"
  actorAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # fetch data from the table: "actor" using primary key columns
  actorByPk(id: bigint!): Actor

  # fetch data from the table: "actor_image"
  actorImage(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch aggregated fields from the table: "actor_image"
  actorImageAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # fetch data from the table: "actor_image" using primary key columns
  actorImageByPk(id: bigint!): ActorImage

  # fetch data from the table in a streaming manner: "actor_image"
  actorImageStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorImageStreamCursorInput]!

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # fetch data from the table in a streaming manner: "actor"
  actorStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorStreamCursorInput]!

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # fetch data from the table: "actor_tag"
  actorTag(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # fetch aggregated fields from the table: "actor_tag"
  actorTagAggregate(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): ActorTagAggregate!

  # fetch data from the table: "actor_tag" using primary key columns
  actorTagByPk(id: bigint!): ActorTag

  # fetch data from the table in a streaming manner: "actor_tag"
  actorTagStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ActorTagStreamCursorInput]!

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # fetch data from the table: "address"
  address(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch aggregated fields from the table: "address"
  addressAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!

  # fetch data from the table: "address" using primary key columns
  addressByPk(id: bigint!): Address

  # fetch data from the table in a streaming manner: "address"
  addressStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [AddressStreamCursorInput]!

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # fetch data from the table: "bank_account"
  bankAccount(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # fetch aggregated fields from the table: "bank_account"
  bankAccountAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!

  # fetch data from the table: "bank_account" using primary key columns
  bankAccountByPk(id: bigint!): BankAccount

  # fetch data from the table in a streaming manner: "bank_account"
  bankAccountStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [BankAccountStreamCursorInput]!

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # fetch data from the table: "bank_info"
  bankInfo(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch aggregated fields from the table: "bank_info"
  bankInfoAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # fetch data from the table: "bank_info" using primary key columns
  bankInfoByPk(id: bigint!): BankInfo

  # fetch data from the table in a streaming manner: "bank_info"
  bankInfoStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [BankInfoStreamCursorInput]!

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # fetch data from the table: "campus"
  campus(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch aggregated fields from the table: "campus"
  campusAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # fetch data from the table: "campus" using primary key columns
  campusByPk(id: bigint!): Campus

  # fetch data from the table: "campus_cluster"
  campusCluster(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch aggregated fields from the table: "campus_cluster"
  campusClusterAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # fetch data from the table: "campus_cluster" using primary key columns
  campusClusterByPk(id: bigint!): CampusCluster

  # fetch data from the table in a streaming manner: "campus_cluster"
  campusClusterStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CampusClusterStreamCursorInput]!

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # fetch data from the table in a streaming manner: "campus"
  campusStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [CampusStreamCursorInput]!

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # fetch aggregated fields from the table: "event"
  eventAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # fetch data from the table: "event_approval"
  eventApproval(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch aggregated fields from the table: "event_approval"
  eventApprovalAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # fetch data from the table: "event_approval" using primary key columns
  eventApprovalByPk(id: bigint!): EventApproval

  # fetch data from the table: "event_approval_step"
  eventApprovalStep(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # fetch aggregated fields from the table: "event_approval_step"
  eventApprovalStepAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # fetch data from the table: "event_approval_step" using primary key columns
  eventApprovalStepByPk(id: bigint!): EventApprovalStep

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # fetch data from the table: "event_approval_step_notifiees" using primary key columns
  eventApprovalStepNotifieesByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepNotifiees

  # fetch data from the table in a streaming manner: "event_approval_step_notifiees"
  eventApprovalStepNotifieesStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepNotifieesStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # fetch data from the table in a streaming manner: "event_approval_step"
  eventApprovalStepStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # fetch data from the table: "event_approval_step_validators" using primary key columns
  eventApprovalStepValidatorsByPk(eventApprovalStepId: bigint!, userId: bigint!): EventApprovalStepValidators

  # fetch data from the table in a streaming manner: "event_approval_step_validators"
  eventApprovalStepValidatorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStepValidatorsStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # fetch data from the table in a streaming manner: "event_approval"
  eventApprovalStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventApprovalStreamCursorInput]!

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # fetch data from the table: "event" using primary key columns
  eventByPk(id: bigint!): Event

  # fetch data from the table: "event_favorite"
  eventFavorite(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # fetch aggregated fields from the table: "event_favorite"
  eventFavoriteAggregate(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): EventFavoriteAggregate!

  # fetch data from the table: "event_favorite" using primary key columns
  eventFavoriteByPk(id: bigint!): EventFavorite

  # fetch data from the table in a streaming manner: "event_favorite"
  eventFavoriteStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventFavoriteStreamCursorInput]!

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # fetch data from the table: "event_join"
  eventJoin(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch aggregated fields from the table: "event_join"
  eventJoinAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # fetch data from the table: "event_join" using primary key columns
  eventJoinByPk(id: bigint!): EventJoin

  # fetch data from the table in a streaming manner: "event_join"
  eventJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventJoinStreamCursorInput]!

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # fetch data from the table: "event_organize"
  eventOrganize(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # fetch aggregated fields from the table: "event_organize"
  eventOrganizeAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!

  # fetch data from the table: "event_organize" using primary key columns
  eventOrganizeByPk(id: bigint!): EventOrganize

  # fetch data from the table in a streaming manner: "event_organize"
  eventOrganizeStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventOrganizeStreamCursorInput]!

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # fetch data from the table in a streaming manner: "event"
  eventStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventStreamCursorInput]!

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # fetch data from the table: "event_supervisor"
  eventSupervisor(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # fetch aggregated fields from the table: "event_supervisor"
  eventSupervisorAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!

  # fetch data from the table: "event_supervisor" using primary key columns
  eventSupervisorByPk(id: bigint!): EventSupervisor

  # fetch data from the table in a streaming manner: "event_supervisor"
  eventSupervisorStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [EventSupervisorStreamCursorInput]!

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # fetch data from the table: "expense"
  expense(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch aggregated fields from the table: "expense"
  expenseAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # fetch data from the table: "expense" using primary key columns
  expenseByPk(id: bigint!): Expense

  # fetch data from the table: "expense_item"
  expenseItem(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch aggregated fields from the table: "expense_item"
  expenseItemAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenseItemAttachments(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # An aggregate relationship
  expenseItemAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemAttachmentsOrderBy!]

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): ExpenseItemAttachmentsAggregate!

  # fetch data from the table: "expense_item_attachments" using primary key columns
  expenseItemAttachmentsByPk(expenseItemId: bigint!, fileUploadId: bigint!): ExpenseItemAttachments

  # fetch data from the table in a streaming manner: "expense_item_attachments"
  expenseItemAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseItemAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: ExpenseItemAttachmentsBoolExp
  ): [ExpenseItemAttachments!]!

  # fetch data from the table: "expense_item" using primary key columns
  expenseItemByPk(id: bigint!): ExpenseItem

  # fetch data from the table in a streaming manner: "expense_item"
  expenseItemStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseItemStreamCursorInput]!

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # fetch data from the table in a streaming manner: "expense"
  expenseStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ExpenseStreamCursorInput]!

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # fetch data from the table: "file_upload"
  fileUpload(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch aggregated fields from the table: "file_upload"
  fileUploadAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # fetch data from the table: "file_upload" using primary key columns
  fileUploadByPk(id: bigint!): FileUpload

  # fetch data from the table in a streaming manner: "file_upload"
  fileUploadStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FileUploadStreamCursorInput]!

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # fetch data from the table: "follow"
  follow(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch aggregated fields from the table: "follow"
  followAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # fetch data from the table: "follow" using primary key columns
  followByPk(id: bigint!): Follow

  # fetch data from the table in a streaming manner: "follow"
  followStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FollowStreamCursorInput]!

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # fetch data from the table: "form"
  form(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch aggregated fields from the table: "form"
  formAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # fetch data from the table: "form" using primary key columns
  formByPk(id: bigint!): Form

  # fetch data from the table in a streaming manner: "form"
  formStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FormStreamCursorInput]!

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # fetch data from the table: "form_submission"
  formSubmission(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch aggregated fields from the table: "form_submission"
  formSubmissionAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  formSubmissionAttachments(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): [FormSubmissionAttachments!]!

  # An aggregate relationship
  formSubmissionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionAttachmentsOrderBy!]

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): FormSubmissionAttachmentsAggregate!

  # fetch data from the table: "form_submission_attachments" using primary key columns
  formSubmissionAttachmentsByPk(fileUploadId: bigint!, formSubmissionId: bigint!): FormSubmissionAttachments

  # fetch data from the table in a streaming manner: "form_submission_attachments"
  formSubmissionAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FormSubmissionAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: FormSubmissionAttachmentsBoolExp
  ): [FormSubmissionAttachments!]!

  # fetch data from the table: "form_submission" using primary key columns
  formSubmissionByPk(id: bigint!): FormSubmission

  # fetch data from the table in a streaming manner: "form_submission"
  formSubmissionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [FormSubmissionStreamCursorInput]!

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # fetch data from the table: "grant"
  grant(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch aggregated fields from the table: "grant"
  grantAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # fetch data from the table: "grant_allocate"
  grantAllocate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # fetch aggregated fields from the table: "grant_allocate"
  grantAllocateAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  grantAllocateAttachments(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): [GrantAllocateAttachments!]!

  # An aggregate relationship
  grantAllocateAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): GrantAllocateAttachmentsAggregate!

  # fetch data from the table: "grant_allocate_attachments" using primary key columns
  grantAllocateAttachmentsByPk(fileUploadId: bigint!, grantAllocateId: bigint!): GrantAllocateAttachments

  # fetch data from the table in a streaming manner: "grant_allocate_attachments"
  grantAllocateAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantAllocateAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: GrantAllocateAttachmentsBoolExp
  ): [GrantAllocateAttachments!]!

  # fetch data from the table: "grant_allocate" using primary key columns
  grantAllocateByPk(id: bigint!): GrantAllocate

  # fetch data from the table in a streaming manner: "grant_allocate"
  grantAllocateStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantAllocateStreamCursorInput]!

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An array relationship
  grantAttachments(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # An aggregate relationship
  grantAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [GrantAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAttachmentsOrderBy!]

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): GrantAttachmentsAggregate!

  # fetch data from the table: "grant_attachments" using primary key columns
  grantAttachmentsByPk(fileUploadId: bigint!, grantId: bigint!): GrantAttachments

  # fetch data from the table in a streaming manner: "grant_attachments"
  grantAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: GrantAttachmentsBoolExp
  ): [GrantAttachments!]!

  # fetch data from the table: "grant" using primary key columns
  grantByPk(id: bigint!): Grant

  # fetch data from the table in a streaming manner: "grant"
  grantStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [GrantStreamCursorInput]!

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # fetch data from the table: "legal_unit"
  legalUnit(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch aggregated fields from the table: "legal_unit"
  legalUnitAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # fetch data from the table: "legal_unit" using primary key columns
  legalUnitByPk(id: bigint!): LegalUnit

  # fetch data from the table: "legal_unit_location"
  legalUnitLocation(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # fetch aggregated fields from the table: "legal_unit_location"
  legalUnitLocationAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): LegalUnitLocationAggregate!

  # fetch data from the table: "legal_unit_location" using primary key columns
  legalUnitLocationByPk(id: bigint!): LegalUnitLocation

  # fetch data from the table in a streaming manner: "legal_unit_location"
  legalUnitLocationStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [LegalUnitLocationStreamCursorInput]!

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # fetch data from the table in a streaming manner: "legal_unit"
  legalUnitStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [LegalUnitStreamCursorInput]!

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # fetch data from the table: "location"
  location(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # fetch aggregated fields from the table: "location"
  locationAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!

  # fetch data from the table: "location" using primary key columns
  locationByPk(id: bigint!): Location

  # An array relationship
  locationImages(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): [LocationImages!]!

  # An aggregate relationship
  locationImagesAggregate(
    # distinct select on columns
    distinctOn: [LocationImagesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationImagesOrderBy!]

    # filter the rows returned
    where: LocationImagesBoolExp
  ): LocationImagesAggregate!

  # fetch data from the table: "location_images" using primary key columns
  locationImagesByPk(fileUploadId: bigint!, locationId: bigint!): LocationImages

  # fetch data from the table in a streaming manner: "location_images"
  locationImagesStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [LocationImagesStreamCursorInput]!

    # filter the rows returned
    where: LocationImagesBoolExp
  ): [LocationImages!]!

  # fetch data from the table in a streaming manner: "location"
  locationStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [LocationStreamCursorInput]!

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # fetch data from the table: "mission"
  mission(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch aggregated fields from the table: "mission"
  missionAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # fetch data from the table: "mission" using primary key columns
  missionByPk(id: bigint!): Mission

  # fetch data from the table: "mission_join"
  missionJoin(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch aggregated fields from the table: "mission_join"
  missionJoinAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # fetch data from the table: "mission_join" using primary key columns
  missionJoinByPk(id: bigint!): MissionJoin

  # fetch data from the table in a streaming manner: "mission_join"
  missionJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [MissionJoinStreamCursorInput]!

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # fetch data from the table in a streaming manner: "mission"
  missionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [MissionStreamCursorInput]!

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # fetch data from the table: "pole"
  pole(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch aggregated fields from the table: "pole"
  poleAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # fetch data from the table: "pole" using primary key columns
  poleByPk(id: bigint!): Pole

  # fetch data from the table in a streaming manner: "pole"
  poleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [PoleStreamCursorInput]!

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # fetch data from the table: "project"
  project(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # fetch aggregated fields from the table: "project"
  projectAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # fetch data from the table: "project" using primary key columns
  projectByPk(id: bigint!): Project

  # fetch data from the table in a streaming manner: "project"
  projectStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ProjectStreamCursorInput]!

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An array relationship
  projectSupervisors(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  projectSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # fetch data from the table: "project_supervisors" using primary key columns
  projectSupervisorsByPk(projectId: bigint!, teamMemberId: bigint!): ProjectSupervisors

  # fetch data from the table in a streaming manner: "project_supervisors"
  projectSupervisorsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [ProjectSupervisorsStreamCursorInput]!

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # fetch data from the table: "social"
  social(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch aggregated fields from the table: "social"
  socialAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # fetch data from the table: "social" using primary key columns
  socialByPk(id: bigint!): Social

  # fetch data from the table in a streaming manner: "social"
  socialStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [SocialStreamCursorInput]!

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch aggregated fields from the table: "tag"
  tagAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # fetch data from the table: "tag" using primary key columns
  tagByPk(id: bigint!): Tag

  # fetch data from the table in a streaming manner: "tag"
  tagStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TagStreamCursorInput]!

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # fetch data from the table: "team"
  team(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch aggregated fields from the table: "team"
  teamAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # fetch data from the table: "team" using primary key columns
  teamByPk(id: bigint!): Team

  # fetch data from the table: "team_document"
  teamDocument(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # fetch aggregated fields from the table: "team_document"
  teamDocumentAggregate(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): TeamDocumentAggregate!

  # fetch data from the table: "team_document" using primary key columns
  teamDocumentByPk(id: bigint!): TeamDocument

  # fetch data from the table in a streaming manner: "team_document"
  teamDocumentStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamDocumentStreamCursorInput]!

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # fetch data from the table: "team_history"
  teamHistory(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch aggregated fields from the table: "team_history"
  teamHistoryAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # fetch data from the table: "team_history" using primary key columns
  teamHistoryByPk(id: bigint!): TeamHistory

  # fetch data from the table in a streaming manner: "team_history"
  teamHistoryStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamHistoryStreamCursorInput]!

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # fetch data from the table: "team_join"
  teamJoin(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch aggregated fields from the table: "team_join"
  teamJoinAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # fetch data from the table: "team_join" using primary key columns
  teamJoinByPk(id: bigint!): TeamJoin

  # fetch data from the table in a streaming manner: "team_join"
  teamJoinStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamJoinStreamCursorInput]!

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # fetch data from the table: "team_member"
  teamMember(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch aggregated fields from the table: "team_member"
  teamMemberAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # fetch data from the table: "team_member" using primary key columns
  teamMemberByPk(id: bigint!): TeamMember

  # fetch data from the table: "team_member_role"
  teamMemberRole(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # fetch aggregated fields from the table: "team_member_role"
  teamMemberRoleAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # fetch data from the table: "team_member_role" using primary key columns
  teamMemberRoleByPk(id: bigint!): TeamMemberRole

  # fetch data from the table in a streaming manner: "team_member_role"
  teamMemberRoleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamMemberRoleStreamCursorInput]!

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # fetch data from the table in a streaming manner: "team_member"
  teamMemberStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamMemberStreamCursorInput]!

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # fetch data from the table: "team_role"
  teamRole(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # fetch aggregated fields from the table: "team_role"
  teamRoleAggregate(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): TeamRoleAggregate!

  # fetch data from the table: "team_role" using primary key columns
  teamRoleByPk(id: bigint!): TeamRole

  # fetch data from the table in a streaming manner: "team_role"
  teamRoleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamRoleStreamCursorInput]!

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # fetch data from the table in a streaming manner: "team"
  teamStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TeamStreamCursorInput]!

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # fetch data from the table: "tenant"
  tenant(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch aggregated fields from the table: "tenant"
  tenantAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # fetch data from the table: "tenant" using primary key columns
  tenantByPk(id: bigint!): Tenant

  # fetch data from the table: "tenant_member"
  tenantMember(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # fetch aggregated fields from the table: "tenant_member"
  tenantMemberAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): TenantMemberAggregate!

  # fetch data from the table: "tenant_member" using primary key columns
  tenantMemberByPk(id: bigint!): TenantMember

  # fetch data from the table: "tenant_member_role"
  tenantMemberRole(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # fetch aggregated fields from the table: "tenant_member_role"
  tenantMemberRoleAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # fetch data from the table: "tenant_member_role" using primary key columns
  tenantMemberRoleByPk(id: bigint!): TenantMemberRole

  # fetch data from the table in a streaming manner: "tenant_member_role"
  tenantMemberRoleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantMemberRoleStreamCursorInput]!

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # fetch data from the table in a streaming manner: "tenant_member"
  tenantMemberStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantMemberStreamCursorInput]!

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # fetch data from the table: "tenant_organize"
  tenantOrganize(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # fetch aggregated fields from the table: "tenant_organize"
  tenantOrganizeAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # fetch data from the table: "tenant_organize" using primary key columns
  tenantOrganizeByPk(id: bigint!): TenantOrganize

  # fetch data from the table in a streaming manner: "tenant_organize"
  tenantOrganizeStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantOrganizeStreamCursorInput]!

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # fetch data from the table: "tenant_role"
  tenantRole(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): [TenantRole!]!

  # fetch aggregated fields from the table: "tenant_role"
  tenantRoleAggregate(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): TenantRoleAggregate!

  # fetch data from the table: "tenant_role" using primary key columns
  tenantRoleByPk(id: bigint!): TenantRole

  # fetch data from the table in a streaming manner: "tenant_role"
  tenantRoleStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantRoleStreamCursorInput]!

    # filter the rows returned
    where: TenantRoleBoolExp
  ): [TenantRole!]!

  # fetch data from the table in a streaming manner: "tenant"
  tenantStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TenantStreamCursorInput]!

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # fetch data from the table: "transaction"
  transaction(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # fetch aggregated fields from the table: "transaction"
  transactionAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  transactionAttachments(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): [TransactionAttachments!]!

  # An aggregate relationship
  transactionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): TransactionAttachmentsAggregate!

  # fetch data from the table: "transaction_attachments" using primary key columns
  transactionAttachmentsByPk(fileUploadId: bigint!, transactionId: bigint!): TransactionAttachments

  # fetch data from the table in a streaming manner: "transaction_attachments"
  transactionAttachmentsStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TransactionAttachmentsStreamCursorInput]!

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): [TransactionAttachments!]!

  # fetch data from the table: "transaction" using primary key columns
  transactionByPk(id: bigint!): Transaction

  # fetch data from the table in a streaming manner: "transaction"
  transactionStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [TransactionStreamCursorInput]!

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # fetch data from the table: "user"
  user(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # fetch aggregated fields from the table: "user"
  userAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!

  # fetch data from the table: "user" using primary key columns
  userByPk(id: bigint!): User

  # fetch data from the table in a streaming manner: "user"
  userStream(
    # maximum number of rows returned in a single batch
    batchSize: Int!

    # cursor to stream the results returned by the query
    cursor: [UserStreamCursorInput]!

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!
}

# columns and relationships of "tag"
type Tag {
  # An object relationship
  actorTag: ActorTag
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  image: FileUpload
  imageId: bigint
  name: String!
  slug: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!
}

# aggregated selection of "tag"
type TagAggregate {
  aggregate: TagAggregateFields
  nodes: [Tag!]!
}

input TagAggregateBoolExp {
  count: tagAggregateBoolExpCount
}

input tagAggregateBoolExpCount {
  arguments: [TagSelectColumn!]
  distinct: Boolean
  filter: TagBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tag"
type TagAggregateFields {
  avg: TagAvgFields
  count(columns: [TagSelectColumn!], distinct: Boolean): Int!
  max: TagMaxFields
  min: TagMinFields
  stddev: TagStddevFields
  stddevPop: TagStddevPopFields
  stddevSamp: TagStddevSampFields
  sum: TagSumFields
  varPop: TagVarPopFields
  varSamp: TagVarSampFields
  variance: TagVarianceFields
}

# order by aggregate values of table "tag"
input TagAggregateOrderBy {
  avg: TagAvgOrderBy
  count: OrderBy
  max: TagMaxOrderBy
  min: TagMinOrderBy
  stddev: TagStddevOrderBy
  stddevPop: TagStddevPopOrderBy
  stddevSamp: TagStddevSampOrderBy
  sum: TagSumOrderBy
  varPop: TagVarPopOrderBy
  varSamp: TagVarSampOrderBy
  variance: TagVarianceOrderBy
}

# input type for inserting array relation for remote table "tag"
input TagArrRelInsertInput {
  data: [TagInsertInput!]!

  # upsert condition
  onConflict: TagOnConflict
}

# aggregate avg on columns
type TagAvgFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "tag"
input TagAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
input TagBoolExp {
  _and: [TagBoolExp!]
  _not: TagBoolExp
  _or: [TagBoolExp!]
  actorTag: ActorTagBoolExp
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  image: FileUploadBoolExp
  imageId: BigintComparisonExp
  name: StringComparisonExp
  slug: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "tag"
enum TagConstraint {
  # unique or primary key constraint on columns "id"
  tag_pkey
}

# input type for incrementing numeric columns in table "tag"
input TagIncInput {
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "tag"
input TagInsertInput {
  actorTag: ActorTagObjRelInsertInput
  color: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  image: FileUploadObjRelInsertInput
  imageId: bigint
  name: String
  slug: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
}

# aggregate max on columns
type TagMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "tag"
input TagMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type TagMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "tag"
input TagMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  imageId: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "tag"
type TagMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Tag!]!
}

# input type for inserting object relation for remote table "tag"
input TagObjRelInsertInput {
  data: TagInsertInput!

  # upsert condition
  onConflict: TagOnConflict
}

# on_conflict condition type for table "tag"
input TagOnConflict {
  constraint: TagConstraint!
  updateColumns: [TagUpdateColumn!]! = []
  where: TagBoolExp
}

# Ordering options when selecting data from "tag".
input TagOrderBy {
  actorTag: ActorTagOrderBy
  color: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  image: FileUploadOrderBy
  imageId: OrderBy
  name: OrderBy
  slug: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# primary key columns input for table: tag
input TagPkColumnsInput {
  id: bigint!
}

# select columns of table "tag"
enum TagSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  name

  # column name
  slug

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "tag"
input TagSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type TagStddevFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "tag"
input TagStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TagStddevPopFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "tag"
input TagStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TagStddevSampFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "tag"
input TagStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "tag"
input TagStreamCursorInput {
  # Stream column input with initial value
  initialValue: TagStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TagStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  hiddenAt: timestamptz
  id: bigint
  imageId: bigint
  name: String
  slug: String
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type TagSumFields {
  createdById: bigint
  id: bigint
  imageId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "tag"
input TagSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "tag"
enum TagUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  hiddenAt

  # column name
  id

  # column name
  imageId

  # column name
  name

  # column name
  slug

  # column name
  tenantScopeId

  # column name
  type
}

input TagUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TagIncInput

  # sets the columns of the filtered rows to the given values
  _set: TagSetInput

  # filter the rows which have to be updated
  where: TagBoolExp!
}

# aggregate variance on columns
type TagVarianceFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "tag"
input TagVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TagVarPopFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "tag"
input TagVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TagVarSampFields {
  createdById: Float
  id: Float
  imageId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "tag"
input TagVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  imageId: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "team"
type Team {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An array relationship
  bankAccounts(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # An aggregate relationship
  bankAccountsAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!

  # An array relationship
  childrenTeams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  childrenTeamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String!

  # An array relationship
  eventOrganizes(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # An aggregate relationship
  eventOrganizesAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String

  # An object relationship
  grantFund: LegalUnit

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  hiddenAt: timestamptz
  id: bigint!
  isJoinFormActive: Boolean!
  isOnboardingComplete: Boolean!

  # An object relationship
  joinForm: Form!
  joinFormId: bigint!
  managersCategoryName: String!
  membersCategoryName: String!
  membershipDuration: String!
  membershipFees: Float!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # An object relationship
  parent: Team
  parentId: bigint

  # An array relationship
  poles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  polesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!
  slug: String!

  # An array relationship
  teamDocuments(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # An aggregate relationship
  teamDocumentsAggregate(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): TeamDocumentAggregate!

  # An array relationship
  teamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  teamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  teamRoles(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # An aggregate relationship
  teamRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): TeamRoleAggregate!
  tenantGrantFundId: bigint

  # An array relationship
  tenantOrganizes(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # An aggregate relationship
  tenantOrganizesAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!

  # An object relationship
  video: FileUpload
  videoId: bigint
}

# aggregated selection of "team"
type TeamAggregate {
  aggregate: TeamAggregateFields
  nodes: [Team!]!
}

input TeamAggregateBoolExp {
  bool_and: teamAggregateBoolExpBool_and
  bool_or: teamAggregateBoolExpBool_or
  count: teamAggregateBoolExpCount
}

input teamAggregateBoolExpBool_and {
  arguments: TeamSelectColumnTeamAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TeamBoolExp
  predicate: BooleanComparisonExp!
}

input teamAggregateBoolExpBool_or {
  arguments: TeamSelectColumnTeamAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TeamBoolExp
  predicate: BooleanComparisonExp!
}

input teamAggregateBoolExpCount {
  arguments: [TeamSelectColumn!]
  distinct: Boolean
  filter: TeamBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team"
type TeamAggregateFields {
  avg: TeamAvgFields
  count(columns: [TeamSelectColumn!], distinct: Boolean): Int!
  max: TeamMaxFields
  min: TeamMinFields
  stddev: TeamStddevFields
  stddevPop: TeamStddevPopFields
  stddevSamp: TeamStddevSampFields
  sum: TeamSumFields
  varPop: TeamVarPopFields
  varSamp: TeamVarSampFields
  variance: TeamVarianceFields
}

# order by aggregate values of table "team"
input TeamAggregateOrderBy {
  avg: TeamAvgOrderBy
  count: OrderBy
  max: TeamMaxOrderBy
  min: TeamMinOrderBy
  stddev: TeamStddevOrderBy
  stddevPop: TeamStddevPopOrderBy
  stddevSamp: TeamStddevSampOrderBy
  sum: TeamSumOrderBy
  varPop: TeamVarPopOrderBy
  varSamp: TeamVarSampOrderBy
  variance: TeamVarianceOrderBy
}

# input type for inserting array relation for remote table "team"
input TeamArrRelInsertInput {
  data: [TeamInsertInput!]!

  # upsert condition
  onConflict: TeamOnConflict
}

# aggregate avg on columns
type TeamAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by avg() on columns of table "team"
input TeamAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# Boolean expression to filter rows from the table "team". All fields are combined with a logical 'AND'.
input TeamBoolExp {
  _and: [TeamBoolExp!]
  _not: TeamBoolExp
  _or: [TeamBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  bankAccounts: BankAccountBoolExp
  bankAccountsAggregate: BankAccountAggregateBoolExp
  childrenTeams: TeamBoolExp
  childrenTeamsAggregate: TeamAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  directorsCategoryName: StringComparisonExp
  eventOrganizes: EventOrganizeBoolExp
  eventOrganizesAggregate: EventOrganizeAggregateBoolExp
  expectingPresidentEmail: StringComparisonExp
  expectingSecretaryEmail: StringComparisonExp
  expectingTreasurerEmail: StringComparisonExp
  grantFund: LegalUnitBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  isJoinFormActive: BooleanComparisonExp
  isOnboardingComplete: BooleanComparisonExp
  joinForm: FormBoolExp
  joinFormId: BigintComparisonExp
  managersCategoryName: StringComparisonExp
  membersCategoryName: StringComparisonExp
  membershipDuration: StringComparisonExp
  membershipFees: FloatComparisonExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  parent: TeamBoolExp
  parentId: BigintComparisonExp
  poles: PoleBoolExp
  polesAggregate: PoleAggregateBoolExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  slug: StringComparisonExp
  teamDocuments: TeamDocumentBoolExp
  teamDocumentsAggregate: TeamDocumentAggregateBoolExp
  teamHistories: TeamHistoryBoolExp
  teamHistoriesAggregate: TeamHistoryAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMembers: TeamMemberBoolExp
  teamMembersAggregate: TeamMemberAggregateBoolExp
  teamRoles: TeamRoleBoolExp
  teamRolesAggregate: TeamRoleAggregateBoolExp
  tenantGrantFundId: BigintComparisonExp
  tenantOrganizes: TenantOrganizeBoolExp
  tenantOrganizesAggregate: TenantOrganizeAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
  video: FileUploadBoolExp
  videoId: BigintComparisonExp
}

# unique or primary key constraints on table "team"
enum TeamConstraint {
  # unique or primary key constraint on columns "actor_id"
  team_actor_id_unique

  # unique or primary key constraint on columns "join_form_id"
  team_join_form_id_unique

  # unique or primary key constraint on columns "id"
  team_pkey

  # unique or primary key constraint on columns "slug"
  team_slug_unique
}

# columns and relationships of "team_document"
type TeamDocument {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  file: FileUpload
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint!
  name: String!

  # An object relationship
  team: Team
  teamId: bigint

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!
  yearVersion: smallint
}

# aggregated selection of "team_document"
type TeamDocumentAggregate {
  aggregate: TeamDocumentAggregateFields
  nodes: [TeamDocument!]!
}

input TeamDocumentAggregateBoolExp {
  count: teamDocumentAggregateBoolExpCount
}

input teamDocumentAggregateBoolExpCount {
  arguments: [TeamDocumentSelectColumn!]
  distinct: Boolean
  filter: TeamDocumentBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_document"
type TeamDocumentAggregateFields {
  avg: TeamDocumentAvgFields
  count(columns: [TeamDocumentSelectColumn!], distinct: Boolean): Int!
  max: TeamDocumentMaxFields
  min: TeamDocumentMinFields
  stddev: TeamDocumentStddevFields
  stddevPop: TeamDocumentStddevPopFields
  stddevSamp: TeamDocumentStddevSampFields
  sum: TeamDocumentSumFields
  varPop: TeamDocumentVarPopFields
  varSamp: TeamDocumentVarSampFields
  variance: TeamDocumentVarianceFields
}

# order by aggregate values of table "team_document"
input TeamDocumentAggregateOrderBy {
  avg: TeamDocumentAvgOrderBy
  count: OrderBy
  max: TeamDocumentMaxOrderBy
  min: TeamDocumentMinOrderBy
  stddev: TeamDocumentStddevOrderBy
  stddevPop: TeamDocumentStddevPopOrderBy
  stddevSamp: TeamDocumentStddevSampOrderBy
  sum: TeamDocumentSumOrderBy
  varPop: TeamDocumentVarPopOrderBy
  varSamp: TeamDocumentVarSampOrderBy
  variance: TeamDocumentVarianceOrderBy
}

# input type for inserting array relation for remote table "team_document"
input TeamDocumentArrRelInsertInput {
  data: [TeamDocumentInsertInput!]!

  # upsert condition
  onConflict: TeamDocumentOnConflict
}

# aggregate avg on columns
type TeamDocumentAvgFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by avg() on columns of table "team_document"
input TeamDocumentAvgOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# Boolean expression to filter rows from the table "team_document". All fields are combined with a logical 'AND'.
input TeamDocumentBoolExp {
  _and: [TeamDocumentBoolExp!]
  _not: TeamDocumentBoolExp
  _or: [TeamDocumentBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  file: FileUploadBoolExp
  fileId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
  yearVersion: SmallintComparisonExp
}

# unique or primary key constraints on table "team_document"
enum TeamDocumentConstraint {
  # unique or primary key constraint on columns "file_id"
  team_document_file_id_unique

  # unique or primary key constraint on columns "id"
  team_document_pkey
}

# input type for incrementing numeric columns in table "team_document"
input TeamDocumentIncInput {
  createdById: bigint
  fileId: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  yearVersion: smallint
}

# input type for inserting data into table "team_document"
input TeamDocumentInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  file: FileUploadObjRelInsertInput
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
  yearVersion: smallint
}

# aggregate max on columns
type TeamDocumentMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
  type: String
  yearVersion: smallint
}

# order by max() on columns of table "team_document"
input TeamDocumentMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  fileId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# aggregate min on columns
type TeamDocumentMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
  type: String
  yearVersion: smallint
}

# order by min() on columns of table "team_document"
input TeamDocumentMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  fileId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# response of any mutation on the table "team_document"
type TeamDocumentMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamDocument!]!
}

# input type for inserting object relation for remote table "team_document"
input TeamDocumentObjRelInsertInput {
  data: TeamDocumentInsertInput!

  # upsert condition
  onConflict: TeamDocumentOnConflict
}

# on_conflict condition type for table "team_document"
input TeamDocumentOnConflict {
  constraint: TeamDocumentConstraint!
  updateColumns: [TeamDocumentUpdateColumn!]! = []
  where: TeamDocumentBoolExp
}

# Ordering options when selecting data from "team_document".
input TeamDocumentOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  file: FileUploadOrderBy
  fileId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  yearVersion: OrderBy
}

# primary key columns input for table: team_document
input TeamDocumentPkColumnsInput {
  id: bigint!
}

# select columns of table "team_document"
enum TeamDocumentSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  fileId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type

  # column name
  yearVersion
}

# input type for updating data in table "team_document"
input TeamDocumentSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
  type: String
  yearVersion: smallint
}

# aggregate stddev on columns
type TeamDocumentStddevFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by stddev() on columns of table "team_document"
input TeamDocumentStddevOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# aggregate stddevPop on columns
type TeamDocumentStddevPopFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by stddevPop() on columns of table "team_document"
input TeamDocumentStddevPopOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# aggregate stddevSamp on columns
type TeamDocumentStddevSampFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by stddevSamp() on columns of table "team_document"
input TeamDocumentStddevSampOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# Streaming cursor of the table "team_document"
input TeamDocumentStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamDocumentStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamDocumentStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  fileId: bigint
  hiddenAt: timestamptz
  id: bigint
  name: String
  teamId: bigint
  tenantScopeId: bigint
  type: String
  yearVersion: smallint
}

# aggregate sum on columns
type TeamDocumentSumFields {
  createdById: bigint
  fileId: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  yearVersion: smallint
}

# order by sum() on columns of table "team_document"
input TeamDocumentSumOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# update columns of table "team_document"
enum TeamDocumentUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  fileId

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type

  # column name
  yearVersion
}

input TeamDocumentUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamDocumentIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamDocumentSetInput

  # filter the rows which have to be updated
  where: TeamDocumentBoolExp!
}

# aggregate variance on columns
type TeamDocumentVarianceFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by variance() on columns of table "team_document"
input TeamDocumentVarianceOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# aggregate varPop on columns
type TeamDocumentVarPopFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by varPop() on columns of table "team_document"
input TeamDocumentVarPopOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# aggregate varSamp on columns
type TeamDocumentVarSampFields {
  createdById: Float
  fileId: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
  yearVersion: Float
}

# order by varSamp() on columns of table "team_document"
input TeamDocumentVarSampOrderBy {
  createdById: OrderBy
  fileId: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  yearVersion: OrderBy
}

# columns and relationships of "team_history"
type TeamHistory {
  approximateDate: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz!
  eventType: String!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "team_history"
type TeamHistoryAggregate {
  aggregate: TeamHistoryAggregateFields
  nodes: [TeamHistory!]!
}

input TeamHistoryAggregateBoolExp {
  count: teamHistoryAggregateBoolExpCount
}

input teamHistoryAggregateBoolExpCount {
  arguments: [TeamHistorySelectColumn!]
  distinct: Boolean
  filter: TeamHistoryBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_history"
type TeamHistoryAggregateFields {
  avg: TeamHistoryAvgFields
  count(columns: [TeamHistorySelectColumn!], distinct: Boolean): Int!
  max: TeamHistoryMaxFields
  min: TeamHistoryMinFields
  stddev: TeamHistoryStddevFields
  stddevPop: TeamHistoryStddevPopFields
  stddevSamp: TeamHistoryStddevSampFields
  sum: TeamHistorySumFields
  varPop: TeamHistoryVarPopFields
  varSamp: TeamHistoryVarSampFields
  variance: TeamHistoryVarianceFields
}

# order by aggregate values of table "team_history"
input TeamHistoryAggregateOrderBy {
  avg: TeamHistoryAvgOrderBy
  count: OrderBy
  max: TeamHistoryMaxOrderBy
  min: TeamHistoryMinOrderBy
  stddev: TeamHistoryStddevOrderBy
  stddevPop: TeamHistoryStddevPopOrderBy
  stddevSamp: TeamHistoryStddevSampOrderBy
  sum: TeamHistorySumOrderBy
  varPop: TeamHistoryVarPopOrderBy
  varSamp: TeamHistoryVarSampOrderBy
  variance: TeamHistoryVarianceOrderBy
}

# input type for inserting array relation for remote table "team_history"
input TeamHistoryArrRelInsertInput {
  data: [TeamHistoryInsertInput!]!

  # upsert condition
  onConflict: TeamHistoryOnConflict
}

# aggregate avg on columns
type TeamHistoryAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "team_history"
input TeamHistoryAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "team_history". All fields are combined with a logical 'AND'.
input TeamHistoryBoolExp {
  _and: [TeamHistoryBoolExp!]
  _not: TeamHistoryBoolExp
  _or: [TeamHistoryBoolExp!]
  approximateDate: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  eventDate: TimestamptzComparisonExp
  eventType: StringComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "team_history"
enum TeamHistoryConstraint {
  # unique or primary key constraint on columns "id"
  team_history_pkey
}

# input type for incrementing numeric columns in table "team_history"
input TeamHistoryIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "team_history"
input TeamHistoryInsertInput {
  approximateDate: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type TeamHistoryMaxFields {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "team_history"
input TeamHistoryMaxOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type TeamHistoryMinFields {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "team_history"
input TeamHistoryMinOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "team_history"
type TeamHistoryMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamHistory!]!
}

# on_conflict condition type for table "team_history"
input TeamHistoryOnConflict {
  constraint: TeamHistoryConstraint!
  updateColumns: [TeamHistoryUpdateColumn!]! = []
  where: TeamHistoryBoolExp
}

# Ordering options when selecting data from "team_history".
input TeamHistoryOrderBy {
  approximateDate: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  eventDate: OrderBy
  eventType: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: team_history
input TeamHistoryPkColumnsInput {
  id: bigint!
}

# select columns of table "team_history"
enum TeamHistorySelectColumn {
  # column name
  approximateDate

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventDate

  # column name
  eventType

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantScopeId
}

# input type for updating data in table "team_history"
input TeamHistorySetInput {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type TeamHistoryStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "team_history"
input TeamHistoryStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TeamHistoryStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "team_history"
input TeamHistoryStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TeamHistoryStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "team_history"
input TeamHistoryStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "team_history"
input TeamHistoryStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamHistoryStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamHistoryStreamCursorValueInput {
  approximateDate: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  eventDate: timestamptz
  eventType: String
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type TeamHistorySumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "team_history"
input TeamHistorySumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "team_history"
enum TeamHistoryUpdateColumn {
  # column name
  approximateDate

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  eventDate

  # column name
  eventType

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantScopeId
}

input TeamHistoryUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamHistoryIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamHistorySetInput

  # filter the rows which have to be updated
  where: TeamHistoryBoolExp!
}

# aggregate variance on columns
type TeamHistoryVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "team_history"
input TeamHistoryVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TeamHistoryVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "team_history"
input TeamHistoryVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TeamHistoryVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "team_history"
input TeamHistoryVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# input type for incrementing numeric columns in table "team"
input TeamIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  joinFormId: bigint
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  videoId: bigint
}

# input type for inserting data into table "team"
input TeamInsertInput {
  actions: ActionArrRelInsertInput
  actor: ActorObjRelInsertInput
  actorId: bigint
  bankAccounts: BankAccountArrRelInsertInput
  childrenTeams: TeamArrRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String
  eventOrganizes: EventOrganizeArrRelInsertInput
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String
  grantFund: LegalUnitObjRelInsertInput
  grants: GrantArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  isOnboardingComplete: Boolean
  joinForm: FormObjRelInsertInput
  joinFormId: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  missions: MissionArrRelInsertInput
  parent: TeamObjRelInsertInput
  parentId: bigint
  poles: PoleArrRelInsertInput
  projects: ProjectArrRelInsertInput
  slug: String
  teamDocuments: TeamDocumentArrRelInsertInput
  teamHistories: TeamHistoryArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMembers: TeamMemberArrRelInsertInput
  teamRoles: TeamRoleArrRelInsertInput
  tenantGrantFundId: bigint
  tenantOrganizes: TenantOrganizeArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
  video: FileUploadObjRelInsertInput
  videoId: bigint
}

# columns and relationships of "team_join"
type TeamJoin {
  askedRoleId: bigint!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz

  # An object relationship
  formSubmission: FormSubmission
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  joinedBy: User!
  joinedById: bigint!
  processedAt: timestamptz

  # An object relationship
  processedBy: User
  processedById: bigint
  state: String!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  teamRole: TeamRole!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "team_join"
type TeamJoinAggregate {
  aggregate: TeamJoinAggregateFields
  nodes: [TeamJoin!]!
}

input TeamJoinAggregateBoolExp {
  count: teamJoinAggregateBoolExpCount
}

input teamJoinAggregateBoolExpCount {
  arguments: [TeamJoinSelectColumn!]
  distinct: Boolean
  filter: TeamJoinBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_join"
type TeamJoinAggregateFields {
  avg: TeamJoinAvgFields
  count(columns: [TeamJoinSelectColumn!], distinct: Boolean): Int!
  max: TeamJoinMaxFields
  min: TeamJoinMinFields
  stddev: TeamJoinStddevFields
  stddevPop: TeamJoinStddevPopFields
  stddevSamp: TeamJoinStddevSampFields
  sum: TeamJoinSumFields
  varPop: TeamJoinVarPopFields
  varSamp: TeamJoinVarSampFields
  variance: TeamJoinVarianceFields
}

# order by aggregate values of table "team_join"
input TeamJoinAggregateOrderBy {
  avg: TeamJoinAvgOrderBy
  count: OrderBy
  max: TeamJoinMaxOrderBy
  min: TeamJoinMinOrderBy
  stddev: TeamJoinStddevOrderBy
  stddevPop: TeamJoinStddevPopOrderBy
  stddevSamp: TeamJoinStddevSampOrderBy
  sum: TeamJoinSumOrderBy
  varPop: TeamJoinVarPopOrderBy
  varSamp: TeamJoinVarSampOrderBy
  variance: TeamJoinVarianceOrderBy
}

# input type for inserting array relation for remote table "team_join"
input TeamJoinArrRelInsertInput {
  data: [TeamJoinInsertInput!]!

  # upsert condition
  onConflict: TeamJoinOnConflict
}

# aggregate avg on columns
type TeamJoinAvgFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "team_join"
input TeamJoinAvgOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "team_join". All fields are combined with a logical 'AND'.
input TeamJoinBoolExp {
  _and: [TeamJoinBoolExp!]
  _not: TeamJoinBoolExp
  _or: [TeamJoinBoolExp!]
  askedRoleId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  formSubmission: FormSubmissionBoolExp
  formSubmissionId: BigintComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  joinedBy: UserBoolExp
  joinedById: BigintComparisonExp
  processedAt: TimestamptzComparisonExp
  processedBy: UserBoolExp
  processedById: BigintComparisonExp
  state: StringComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamRole: TeamRoleBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "team_join"
enum TeamJoinConstraint {
  # unique or primary key constraint on columns "id"
  team_join_pkey
}

# input type for incrementing numeric columns in table "team_join"
input TeamJoinIncInput {
  askedRoleId: bigint
  createdById: bigint
  formSubmissionId: bigint
  id: bigint
  joinedById: bigint
  processedById: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "team_join"
input TeamJoinInsertInput {
  askedRoleId: bigint
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  formSubmission: FormSubmissionObjRelInsertInput
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedBy: UserObjRelInsertInput
  joinedById: bigint
  processedAt: timestamptz
  processedBy: UserObjRelInsertInput
  processedById: bigint
  state: String
  team: TeamObjRelInsertInput
  teamId: bigint
  teamRole: TeamRoleObjRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type TeamJoinMaxFields {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  processedAt: timestamptz
  processedById: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "team_join"
input TeamJoinMaxOrderBy {
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type TeamJoinMinFields {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  processedAt: timestamptz
  processedById: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "team_join"
input TeamJoinMinOrderBy {
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedAt: OrderBy
  processedById: OrderBy
  state: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "team_join"
type TeamJoinMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamJoin!]!
}

# on_conflict condition type for table "team_join"
input TeamJoinOnConflict {
  constraint: TeamJoinConstraint!
  updateColumns: [TeamJoinUpdateColumn!]! = []
  where: TeamJoinBoolExp
}

# Ordering options when selecting data from "team_join".
input TeamJoinOrderBy {
  askedRoleId: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  formSubmission: FormSubmissionOrderBy
  formSubmissionId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinedBy: UserOrderBy
  joinedById: OrderBy
  processedAt: OrderBy
  processedBy: UserOrderBy
  processedById: OrderBy
  state: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamRole: TeamRoleOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: team_join
input TeamJoinPkColumnsInput {
  id: bigint!
}

# select columns of table "team_join"
enum TeamJoinSelectColumn {
  # column name
  askedRoleId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedById

  # column name
  processedAt

  # column name
  processedById

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId
}

# input type for updating data in table "team_join"
input TeamJoinSetInput {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  processedAt: timestamptz
  processedById: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type TeamJoinStddevFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "team_join"
input TeamJoinStddevOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TeamJoinStddevPopFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "team_join"
input TeamJoinStddevPopOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TeamJoinStddevSampFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "team_join"
input TeamJoinStddevSampOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "team_join"
input TeamJoinStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamJoinStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamJoinStreamCursorValueInput {
  askedRoleId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  formSubmissionId: bigint
  hiddenAt: timestamptz
  id: bigint
  joinedById: bigint
  processedAt: timestamptz
  processedById: bigint
  state: String
  teamId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type TeamJoinSumFields {
  askedRoleId: bigint
  createdById: bigint
  formSubmissionId: bigint
  id: bigint
  joinedById: bigint
  processedById: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "team_join"
input TeamJoinSumOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "team_join"
enum TeamJoinUpdateColumn {
  # column name
  askedRoleId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  formSubmissionId

  # column name
  hiddenAt

  # column name
  id

  # column name
  joinedById

  # column name
  processedAt

  # column name
  processedById

  # column name
  state

  # column name
  teamId

  # column name
  tenantScopeId
}

input TeamJoinUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamJoinIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamJoinSetInput

  # filter the rows which have to be updated
  where: TeamJoinBoolExp!
}

# aggregate variance on columns
type TeamJoinVarianceFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "team_join"
input TeamJoinVarianceOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TeamJoinVarPopFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "team_join"
input TeamJoinVarPopOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TeamJoinVarSampFields {
  askedRoleId: Float
  createdById: Float
  formSubmissionId: Float
  id: Float
  joinedById: Float
  processedById: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "team_join"
input TeamJoinVarSampOrderBy {
  askedRoleId: OrderBy
  createdById: OrderBy
  formSubmissionId: OrderBy
  id: OrderBy
  joinedById: OrderBy
  processedById: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate max on columns
type TeamMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  slug: String
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  type: String
  videoId: bigint
}

# order by max() on columns of table "team"
input TeamMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  expectingPresidentEmail: OrderBy
  expectingSecretaryEmail: OrderBy
  expectingTreasurerEmail: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  slug: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  videoId: OrderBy
}

# columns and relationships of "team_member"
type TeamMember {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  permissions: Int!
  start: timestamptz!

  # An array relationship
  supervisedProjects(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): [ProjectSupervisors!]!

  # An aggregate relationship
  supervisedProjectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSupervisorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectSupervisorsOrderBy!]

    # filter the rows returned
    where: ProjectSupervisorsBoolExp
  ): ProjectSupervisorsAggregate!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "team_member"
type TeamMemberAggregate {
  aggregate: TeamMemberAggregateFields
  nodes: [TeamMember!]!
}

input TeamMemberAggregateBoolExp {
  count: teamMemberAggregateBoolExpCount
}

input teamMemberAggregateBoolExpCount {
  arguments: [TeamMemberSelectColumn!]
  distinct: Boolean
  filter: TeamMemberBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_member"
type TeamMemberAggregateFields {
  avg: TeamMemberAvgFields
  count(columns: [TeamMemberSelectColumn!], distinct: Boolean): Int!
  max: TeamMemberMaxFields
  min: TeamMemberMinFields
  stddev: TeamMemberStddevFields
  stddevPop: TeamMemberStddevPopFields
  stddevSamp: TeamMemberStddevSampFields
  sum: TeamMemberSumFields
  varPop: TeamMemberVarPopFields
  varSamp: TeamMemberVarSampFields
  variance: TeamMemberVarianceFields
}

# order by aggregate values of table "team_member"
input TeamMemberAggregateOrderBy {
  avg: TeamMemberAvgOrderBy
  count: OrderBy
  max: TeamMemberMaxOrderBy
  min: TeamMemberMinOrderBy
  stddev: TeamMemberStddevOrderBy
  stddevPop: TeamMemberStddevPopOrderBy
  stddevSamp: TeamMemberStddevSampOrderBy
  sum: TeamMemberSumOrderBy
  varPop: TeamMemberVarPopOrderBy
  varSamp: TeamMemberVarSampOrderBy
  variance: TeamMemberVarianceOrderBy
}

# input type for inserting array relation for remote table "team_member"
input TeamMemberArrRelInsertInput {
  data: [TeamMemberInsertInput!]!

  # upsert condition
  onConflict: TeamMemberOnConflict
}

# aggregate avg on columns
type TeamMemberAvgFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by avg() on columns of table "team_member"
input TeamMemberAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "team_member". All fields are combined with a logical 'AND'.
input TeamMemberBoolExp {
  _and: [TeamMemberBoolExp!]
  _not: TeamMemberBoolExp
  _or: [TeamMemberBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  permissions: IntComparisonExp
  start: TimestamptzComparisonExp
  supervisedProjects: ProjectSupervisorsBoolExp
  supervisedProjectsAggregate: ProjectSupervisorsAggregateBoolExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamMemberRoles: TeamMemberRoleBoolExp
  teamMemberRolesAggregate: TeamMemberRoleAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "team_member"
enum TeamMemberConstraint {
  # unique or primary key constraint on columns "id"
  team_member_pkey
}

# input type for incrementing numeric columns in table "team_member"
input TeamMemberIncInput {
  createdById: bigint
  id: bigint
  permissions: Int
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# input type for inserting data into table "team_member"
input TeamMemberInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  supervisedProjects: ProjectSupervisorsArrRelInsertInput
  team: TeamObjRelInsertInput
  teamId: bigint
  teamMemberRoles: TeamMemberRoleArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type TeamMemberMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by max() on columns of table "team_member"
input TeamMemberMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type TeamMemberMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by min() on columns of table "team_member"
input TeamMemberMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "team_member"
type TeamMemberMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamMember!]!
}

# input type for inserting object relation for remote table "team_member"
input TeamMemberObjRelInsertInput {
  data: TeamMemberInsertInput!

  # upsert condition
  onConflict: TeamMemberOnConflict
}

# on_conflict condition type for table "team_member"
input TeamMemberOnConflict {
  constraint: TeamMemberConstraint!
  updateColumns: [TeamMemberUpdateColumn!]! = []
  where: TeamMemberBoolExp
}

# Ordering options when selecting data from "team_member".
input TeamMemberOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  supervisedProjectsAggregate: ProjectSupervisorsAggregateOrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamMemberRolesAggregate: TeamMemberRoleAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: team_member
input TeamMemberPkColumnsInput {
  id: bigint!
}

# columns and relationships of "team_member_role"
type TeamMemberRole {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  teamMember: TeamMember!
  teamMemberId: bigint!

  # An object relationship
  teamRole: TeamRole!
  teamRoleId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "team_member_role"
type TeamMemberRoleAggregate {
  aggregate: TeamMemberRoleAggregateFields
  nodes: [TeamMemberRole!]!
}

input TeamMemberRoleAggregateBoolExp {
  count: teamMemberRoleAggregateBoolExpCount
}

input teamMemberRoleAggregateBoolExpCount {
  arguments: [TeamMemberRoleSelectColumn!]
  distinct: Boolean
  filter: TeamMemberRoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_member_role"
type TeamMemberRoleAggregateFields {
  avg: TeamMemberRoleAvgFields
  count(columns: [TeamMemberRoleSelectColumn!], distinct: Boolean): Int!
  max: TeamMemberRoleMaxFields
  min: TeamMemberRoleMinFields
  stddev: TeamMemberRoleStddevFields
  stddevPop: TeamMemberRoleStddevPopFields
  stddevSamp: TeamMemberRoleStddevSampFields
  sum: TeamMemberRoleSumFields
  varPop: TeamMemberRoleVarPopFields
  varSamp: TeamMemberRoleVarSampFields
  variance: TeamMemberRoleVarianceFields
}

# order by aggregate values of table "team_member_role"
input TeamMemberRoleAggregateOrderBy {
  avg: TeamMemberRoleAvgOrderBy
  count: OrderBy
  max: TeamMemberRoleMaxOrderBy
  min: TeamMemberRoleMinOrderBy
  stddev: TeamMemberRoleStddevOrderBy
  stddevPop: TeamMemberRoleStddevPopOrderBy
  stddevSamp: TeamMemberRoleStddevSampOrderBy
  sum: TeamMemberRoleSumOrderBy
  varPop: TeamMemberRoleVarPopOrderBy
  varSamp: TeamMemberRoleVarSampOrderBy
  variance: TeamMemberRoleVarianceOrderBy
}

# input type for inserting array relation for remote table "team_member_role"
input TeamMemberRoleArrRelInsertInput {
  data: [TeamMemberRoleInsertInput!]!

  # upsert condition
  onConflict: TeamMemberRoleOnConflict
}

# aggregate avg on columns
type TeamMemberRoleAvgFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "team_member_role"
input TeamMemberRoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "team_member_role". All fields are combined with a logical 'AND'.
input TeamMemberRoleBoolExp {
  _and: [TeamMemberRoleBoolExp!]
  _not: TeamMemberRoleBoolExp
  _or: [TeamMemberRoleBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  teamMember: TeamMemberBoolExp
  teamMemberId: BigintComparisonExp
  teamRole: TeamRoleBoolExp
  teamRoleId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "team_member_role"
enum TeamMemberRoleConstraint {
  # unique or primary key constraint on columns "id"
  team_member_role_pkey
}

# input type for incrementing numeric columns in table "team_member_role"
input TeamMemberRoleIncInput {
  createdById: bigint
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "team_member_role"
input TeamMemberRoleInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamMember: TeamMemberObjRelInsertInput
  teamMemberId: bigint
  teamRole: TeamRoleObjRelInsertInput
  teamRoleId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type TeamMemberRoleMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "team_member_role"
input TeamMemberRoleMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type TeamMemberRoleMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "team_member_role"
input TeamMemberRoleMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "team_member_role"
type TeamMemberRoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamMemberRole!]!
}

# on_conflict condition type for table "team_member_role"
input TeamMemberRoleOnConflict {
  constraint: TeamMemberRoleConstraint!
  updateColumns: [TeamMemberRoleUpdateColumn!]! = []
  where: TeamMemberRoleBoolExp
}

# Ordering options when selecting data from "team_member_role".
input TeamMemberRoleOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamMember: TeamMemberOrderBy
  teamMemberId: OrderBy
  teamRole: TeamRoleOrderBy
  teamRoleId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: team_member_role
input TeamMemberRolePkColumnsInput {
  id: bigint!
}

# select columns of table "team_member_role"
enum TeamMemberRoleSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamMemberId

  # column name
  teamRoleId

  # column name
  tenantScopeId
}

# input type for updating data in table "team_member_role"
input TeamMemberRoleSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type TeamMemberRoleStddevFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "team_member_role"
input TeamMemberRoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TeamMemberRoleStddevPopFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "team_member_role"
input TeamMemberRoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TeamMemberRoleStddevSampFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "team_member_role"
input TeamMemberRoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "team_member_role"
input TeamMemberRoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamMemberRoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamMemberRoleStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type TeamMemberRoleSumFields {
  createdById: bigint
  id: bigint
  teamMemberId: bigint
  teamRoleId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "team_member_role"
input TeamMemberRoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "team_member_role"
enum TeamMemberRoleUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamMemberId

  # column name
  teamRoleId

  # column name
  tenantScopeId
}

input TeamMemberRoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamMemberRoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamMemberRoleSetInput

  # filter the rows which have to be updated
  where: TeamMemberRoleBoolExp!
}

# aggregate variance on columns
type TeamMemberRoleVarianceFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "team_member_role"
input TeamMemberRoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TeamMemberRoleVarPopFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "team_member_role"
input TeamMemberRoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TeamMemberRoleVarSampFields {
  createdById: Float
  id: Float
  teamMemberId: Float
  teamRoleId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "team_member_role"
input TeamMemberRoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamMemberId: OrderBy
  teamRoleId: OrderBy
  tenantScopeId: OrderBy
}

# select columns of table "team_member"
enum TeamMemberSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  permissions

  # column name
  start

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  userId
}

# input type for updating data in table "team_member"
input TeamMemberSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# aggregate stddev on columns
type TeamMemberStddevFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddev() on columns of table "team_member"
input TeamMemberStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type TeamMemberStddevPopFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevPop() on columns of table "team_member"
input TeamMemberStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type TeamMemberStddevSampFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "team_member"
input TeamMemberStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "team_member"
input TeamMemberStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamMemberStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamMemberStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# aggregate sum on columns
type TeamMemberSumFields {
  createdById: bigint
  id: bigint
  permissions: Int
  teamId: bigint
  tenantScopeId: bigint
  userId: bigint
}

# order by sum() on columns of table "team_member"
input TeamMemberSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# update columns of table "team_member"
enum TeamMemberUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  permissions

  # column name
  start

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  userId
}

input TeamMemberUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamMemberIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamMemberSetInput

  # filter the rows which have to be updated
  where: TeamMemberBoolExp!
}

# aggregate variance on columns
type TeamMemberVarianceFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by variance() on columns of table "team_member"
input TeamMemberVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type TeamMemberVarPopFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by varPop() on columns of table "team_member"
input TeamMemberVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type TeamMemberVarSampFields {
  createdById: Float
  id: Float
  permissions: Float
  teamId: Float
  tenantScopeId: Float
  userId: Float
}

# order by varSamp() on columns of table "team_member"
input TeamMemberVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type TeamMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String
  hiddenAt: timestamptz
  id: bigint
  joinFormId: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  slug: String
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  type: String
  videoId: bigint
}

# order by min() on columns of table "team"
input TeamMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  expectingPresidentEmail: OrderBy
  expectingSecretaryEmail: OrderBy
  expectingTreasurerEmail: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  slug: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  videoId: OrderBy
}

# response of any mutation on the table "team"
type TeamMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Team!]!
}

# input type for inserting object relation for remote table "team"
input TeamObjRelInsertInput {
  data: TeamInsertInput!

  # upsert condition
  onConflict: TeamOnConflict
}

# on_conflict condition type for table "team"
input TeamOnConflict {
  constraint: TeamConstraint!
  updateColumns: [TeamUpdateColumn!]! = []
  where: TeamBoolExp
}

# Ordering options when selecting data from "team".
input TeamOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  actor: ActorOrderBy
  actorId: OrderBy
  bankAccountsAggregate: BankAccountAggregateOrderBy
  childrenTeamsAggregate: TeamAggregateOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  directorsCategoryName: OrderBy
  eventOrganizesAggregate: EventOrganizeAggregateOrderBy
  expectingPresidentEmail: OrderBy
  expectingSecretaryEmail: OrderBy
  expectingTreasurerEmail: OrderBy
  grantFund: LegalUnitOrderBy
  grantsAggregate: GrantAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  isJoinFormActive: OrderBy
  isOnboardingComplete: OrderBy
  joinForm: FormOrderBy
  joinFormId: OrderBy
  managersCategoryName: OrderBy
  membersCategoryName: OrderBy
  membershipDuration: OrderBy
  membershipFees: OrderBy
  missionsAggregate: MissionAggregateOrderBy
  parent: TeamOrderBy
  parentId: OrderBy
  polesAggregate: PoleAggregateOrderBy
  projectsAggregate: ProjectAggregateOrderBy
  slug: OrderBy
  teamDocumentsAggregate: TeamDocumentAggregateOrderBy
  teamHistoriesAggregate: TeamHistoryAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMembersAggregate: TeamMemberAggregateOrderBy
  teamRolesAggregate: TeamRoleAggregateOrderBy
  tenantGrantFundId: OrderBy
  tenantOrganizesAggregate: TenantOrganizeAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  video: FileUploadOrderBy
  videoId: OrderBy
}

# primary key columns input for table: team
input TeamPkColumnsInput {
  id: bigint!
}

# columns and relationships of "team_role"
type TeamRole {
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  permissions: [String!]!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String
}

# aggregated selection of "team_role"
type TeamRoleAggregate {
  aggregate: TeamRoleAggregateFields
  nodes: [TeamRole!]!
}

input TeamRoleAggregateBoolExp {
  count: teamRoleAggregateBoolExpCount
}

input teamRoleAggregateBoolExpCount {
  arguments: [TeamRoleSelectColumn!]
  distinct: Boolean
  filter: TeamRoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "team_role"
type TeamRoleAggregateFields {
  avg: TeamRoleAvgFields
  count(columns: [TeamRoleSelectColumn!], distinct: Boolean): Int!
  max: TeamRoleMaxFields
  min: TeamRoleMinFields
  stddev: TeamRoleStddevFields
  stddevPop: TeamRoleStddevPopFields
  stddevSamp: TeamRoleStddevSampFields
  sum: TeamRoleSumFields
  varPop: TeamRoleVarPopFields
  varSamp: TeamRoleVarSampFields
  variance: TeamRoleVarianceFields
}

# order by aggregate values of table "team_role"
input TeamRoleAggregateOrderBy {
  avg: TeamRoleAvgOrderBy
  count: OrderBy
  max: TeamRoleMaxOrderBy
  min: TeamRoleMinOrderBy
  stddev: TeamRoleStddevOrderBy
  stddevPop: TeamRoleStddevPopOrderBy
  stddevSamp: TeamRoleStddevSampOrderBy
  sum: TeamRoleSumOrderBy
  varPop: TeamRoleVarPopOrderBy
  varSamp: TeamRoleVarSampOrderBy
  variance: TeamRoleVarianceOrderBy
}

# input type for inserting array relation for remote table "team_role"
input TeamRoleArrRelInsertInput {
  data: [TeamRoleInsertInput!]!

  # upsert condition
  onConflict: TeamRoleOnConflict
}

# aggregate avg on columns
type TeamRoleAvgFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "team_role"
input TeamRoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "team_role". All fields are combined with a logical 'AND'.
input TeamRoleBoolExp {
  _and: [TeamRoleBoolExp!]
  _not: TeamRoleBoolExp
  _or: [TeamRoleBoolExp!]
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  permissions: StringArrayComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMemberRoles: TeamMemberRoleBoolExp
  teamMemberRolesAggregate: TeamMemberRoleAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "team_role"
enum TeamRoleConstraint {
  # unique or primary key constraint on columns "id"
  team_role_pkey
}

# input type for incrementing numeric columns in table "team_role"
input TeamRoleIncInput {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "team_role"
input TeamRoleInsertInput {
  color: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  team: TeamObjRelInsertInput
  teamId: bigint
  teamJoins: TeamJoinArrRelInsertInput
  teamMemberRoles: TeamMemberRoleArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
}

# aggregate max on columns
type TeamRoleMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "team_role"
input TeamRoleMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type TeamRoleMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "team_role"
input TeamRoleMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "team_role"
type TeamRoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TeamRole!]!
}

# input type for inserting object relation for remote table "team_role"
input TeamRoleObjRelInsertInput {
  data: TeamRoleInsertInput!

  # upsert condition
  onConflict: TeamRoleOnConflict
}

# on_conflict condition type for table "team_role"
input TeamRoleOnConflict {
  constraint: TeamRoleConstraint!
  updateColumns: [TeamRoleUpdateColumn!]! = []
  where: TeamRoleBoolExp
}

# Ordering options when selecting data from "team_role".
input TeamRoleOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMemberRolesAggregate: TeamMemberRoleAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# primary key columns input for table: team_role
input TeamRolePkColumnsInput {
  id: bigint!
}

# select columns of table "team_role"
enum TeamRoleSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  permissions

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "team_role"
input TeamRoleSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type TeamRoleStddevFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "team_role"
input TeamRoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TeamRoleStddevPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "team_role"
input TeamRoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TeamRoleStddevSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "team_role"
input TeamRoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "team_role"
input TeamRoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamRoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamRoleStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type TeamRoleSumFields {
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "team_role"
input TeamRoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "team_role"
enum TeamRoleUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  permissions

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

input TeamRoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamRoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamRoleSetInput

  # filter the rows which have to be updated
  where: TeamRoleBoolExp!
}

# aggregate variance on columns
type TeamRoleVarianceFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "team_role"
input TeamRoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TeamRoleVarPopFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "team_role"
input TeamRoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TeamRoleVarSampFields {
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "team_role"
input TeamRoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# select columns of table "team"
enum TeamSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  directorsCategoryName

  # column name
  expectingPresidentEmail

  # column name
  expectingSecretaryEmail

  # column name
  expectingTreasurerEmail

  # column name
  hiddenAt

  # column name
  id

  # column name
  isJoinFormActive

  # column name
  isOnboardingComplete

  # column name
  joinFormId

  # column name
  managersCategoryName

  # column name
  membersCategoryName

  # column name
  membershipDuration

  # column name
  membershipFees

  # column name
  parentId

  # column name
  slug

  # column name
  tenantGrantFundId

  # column name
  tenantScopeId

  # column name
  type

  # column name
  videoId
}

# select "teamAggregateBoolExpBool_andArgumentsColumns" columns of table "team"
enum TeamSelectColumnTeamAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isJoinFormActive

  # column name
  isOnboardingComplete
}

# select "teamAggregateBoolExpBool_orArgumentsColumns" columns of table "team"
enum TeamSelectColumnTeamAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isJoinFormActive

  # column name
  isOnboardingComplete
}

# input type for updating data in table "team"
input TeamSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  isOnboardingComplete: Boolean
  joinFormId: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  slug: String
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  type: String
  videoId: bigint
}

# aggregate stddev on columns
type TeamStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by stddev() on columns of table "team"
input TeamStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# aggregate stddevPop on columns
type TeamStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by stddevPop() on columns of table "team"
input TeamStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# aggregate stddevSamp on columns
type TeamStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by stddevSamp() on columns of table "team"
input TeamStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# Streaming cursor of the table "team"
input TeamStreamCursorInput {
  # Stream column input with initial value
  initialValue: TeamStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TeamStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  directorsCategoryName: String
  expectingPresidentEmail: String
  expectingSecretaryEmail: String
  expectingTreasurerEmail: String
  hiddenAt: timestamptz
  id: bigint
  isJoinFormActive: Boolean
  isOnboardingComplete: Boolean
  joinFormId: bigint
  managersCategoryName: String
  membersCategoryName: String
  membershipDuration: String
  membershipFees: Float
  parentId: bigint
  slug: String
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  type: String
  videoId: bigint
}

# aggregate sum on columns
type TeamSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  joinFormId: bigint
  membershipFees: Float
  parentId: bigint
  tenantGrantFundId: bigint
  tenantScopeId: bigint
  videoId: bigint
}

# order by sum() on columns of table "team"
input TeamSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# update columns of table "team"
enum TeamUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  directorsCategoryName

  # column name
  expectingPresidentEmail

  # column name
  expectingSecretaryEmail

  # column name
  expectingTreasurerEmail

  # column name
  hiddenAt

  # column name
  id

  # column name
  isJoinFormActive

  # column name
  isOnboardingComplete

  # column name
  joinFormId

  # column name
  managersCategoryName

  # column name
  membersCategoryName

  # column name
  membershipDuration

  # column name
  membershipFees

  # column name
  parentId

  # column name
  slug

  # column name
  tenantGrantFundId

  # column name
  tenantScopeId

  # column name
  type

  # column name
  videoId
}

input TeamUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TeamIncInput

  # sets the columns of the filtered rows to the given values
  _set: TeamSetInput

  # filter the rows which have to be updated
  where: TeamBoolExp!
}

# aggregate variance on columns
type TeamVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by variance() on columns of table "team"
input TeamVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# aggregate varPop on columns
type TeamVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by varPop() on columns of table "team"
input TeamVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# aggregate varSamp on columns
type TeamVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  joinFormId: Float
  membershipFees: Float
  parentId: Float
  tenantGrantFundId: Float
  tenantScopeId: Float
  videoId: Float
}

# order by varSamp() on columns of table "team"
input TeamVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  joinFormId: OrderBy
  membershipFees: OrderBy
  parentId: OrderBy
  tenantGrantFundId: OrderBy
  tenantScopeId: OrderBy
  videoId: OrderBy
}

# columns and relationships of "tenant"
type Tenant {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An array relationship
  actorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  actorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  actorTags(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # An aggregate relationship
  actorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): ActorTagAggregate!

  # An array relationship
  actors(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # An aggregate relationship
  actorsAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # An array relationship
  bankAccounts(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # An aggregate relationship
  bankAccountsAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!

  # An array relationship
  bankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  bankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # An array relationship
  campusClusters(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # An aggregate relationship
  campusClustersAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # An array relationship
  campuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  campusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  domain: String!

  # An array relationship
  eventApprovalSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  eventApprovalStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # An array relationship
  eventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  eventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  eventFavorites(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # An aggregate relationship
  eventFavoritesAggregate(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): EventFavoriteAggregate!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  eventOrganizes(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # An aggregate relationship
  eventOrganizesAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!

  # An array relationship
  eventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # An aggregate relationship
  eventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!

  # An object relationship
  eventValidationForm: Form
  eventValidationFormId: bigint

  # An array relationship
  events(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  eventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  expenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  expenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  expenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  expensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  fileUploads(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # An aggregate relationship
  fileUploadsAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # An array relationship
  follows(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followsAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!

  # An array relationship
  formSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  formSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  forms(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # An aggregate relationship
  formsAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # An array relationship
  grantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  grantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  grants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  grantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!
  id: bigint!
  isOidcEnabled: Boolean!

  # An array relationship
  locations(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # An aggregate relationship
  locationsAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  missions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  missionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!
  oidcCallbackUri: String!
  oidcClientId: String!
  oidcClientSecret: String!
  oidcDiscoveryUrl: String!
  oidcName: String!
  oidcScopes: String!
  pointName: String!

  # An array relationship
  poles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  polesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  projects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  projectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  socials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  socialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # An array relationship
  tags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  tagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An array relationship
  teamDocuments(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # An aggregate relationship
  teamDocumentsAggregate(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): TeamDocumentAggregate!

  # An array relationship
  teamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  teamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # An aggregate relationship
  teamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # An array relationship
  teamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  teamRoles(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # An aggregate relationship
  teamRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): TeamRoleAggregate!

  # An array relationship
  teams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  teamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An array relationship
  tenantMemberRoles(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # An aggregate relationship
  tenantMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # An array relationship
  tenantMembers(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # An aggregate relationship
  tenantMembersAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): TenantMemberAggregate!

  # An array relationship
  tenantOrganizes(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # An aggregate relationship
  tenantOrganizesAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # An array relationship
  tenantRoles(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): [TenantRole!]!

  # An aggregate relationship
  tenantRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): TenantRoleAggregate!

  # An array relationship
  transactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  transactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  users(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # An aggregate relationship
  usersAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!
}

# aggregated selection of "tenant"
type TenantAggregate {
  aggregate: TenantAggregateFields
  nodes: [Tenant!]!
}

input TenantAggregateBoolExp {
  bool_and: tenantAggregateBoolExpBool_and
  bool_or: tenantAggregateBoolExpBool_or
  count: tenantAggregateBoolExpCount
}

input tenantAggregateBoolExpBool_and {
  arguments: TenantSelectColumnTenantAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TenantBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAggregateBoolExpBool_or {
  arguments: TenantSelectColumnTenantAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TenantBoolExp
  predicate: BooleanComparisonExp!
}

input tenantAggregateBoolExpCount {
  arguments: [TenantSelectColumn!]
  distinct: Boolean
  filter: TenantBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant"
type TenantAggregateFields {
  avg: TenantAvgFields
  count(columns: [TenantSelectColumn!], distinct: Boolean): Int!
  max: TenantMaxFields
  min: TenantMinFields
  stddev: TenantStddevFields
  stddevPop: TenantStddevPopFields
  stddevSamp: TenantStddevSampFields
  sum: TenantSumFields
  varPop: TenantVarPopFields
  varSamp: TenantVarSampFields
  variance: TenantVarianceFields
}

# order by aggregate values of table "tenant"
input TenantAggregateOrderBy {
  avg: TenantAvgOrderBy
  count: OrderBy
  max: TenantMaxOrderBy
  min: TenantMinOrderBy
  stddev: TenantStddevOrderBy
  stddevPop: TenantStddevPopOrderBy
  stddevSamp: TenantStddevSampOrderBy
  sum: TenantSumOrderBy
  varPop: TenantVarPopOrderBy
  varSamp: TenantVarSampOrderBy
  variance: TenantVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant"
input TenantArrRelInsertInput {
  data: [TenantInsertInput!]!

  # upsert condition
  onConflict: TenantOnConflict
}

# aggregate avg on columns
type TenantAvgFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by avg() on columns of table "tenant"
input TenantAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
input TenantBoolExp {
  _and: [TenantBoolExp!]
  _not: TenantBoolExp
  _or: [TenantBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  actorImages: ActorImageBoolExp
  actorImagesAggregate: ActorImageAggregateBoolExp
  actorTags: ActorTagBoolExp
  actorTagsAggregate: ActorTagAggregateBoolExp
  actors: ActorBoolExp
  actorsAggregate: ActorAggregateBoolExp
  bankAccounts: BankAccountBoolExp
  bankAccountsAggregate: BankAccountAggregateBoolExp
  bankInfos: BankInfoBoolExp
  bankInfosAggregate: BankInfoAggregateBoolExp
  campusClusters: CampusClusterBoolExp
  campusClustersAggregate: CampusClusterAggregateBoolExp
  campuses: CampusBoolExp
  campusesAggregate: CampusAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  domain: StringComparisonExp
  eventApprovalSteps: EventApprovalStepBoolExp
  eventApprovalStepsAggregate: EventApprovalStepAggregateBoolExp
  eventApprovals: EventApprovalBoolExp
  eventApprovalsAggregate: EventApprovalAggregateBoolExp
  eventFavorites: EventFavoriteBoolExp
  eventFavoritesAggregate: EventFavoriteAggregateBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  eventOrganizes: EventOrganizeBoolExp
  eventOrganizesAggregate: EventOrganizeAggregateBoolExp
  eventSupervisors: EventSupervisorBoolExp
  eventSupervisorsAggregate: EventSupervisorAggregateBoolExp
  eventValidationForm: FormBoolExp
  eventValidationFormId: BigintComparisonExp
  events: EventBoolExp
  eventsAggregate: EventAggregateBoolExp
  expenseItems: ExpenseItemBoolExp
  expenseItemsAggregate: ExpenseItemAggregateBoolExp
  expenses: ExpenseBoolExp
  expensesAggregate: ExpenseAggregateBoolExp
  fileUploads: FileUploadBoolExp
  fileUploadsAggregate: FileUploadAggregateBoolExp
  follows: FollowBoolExp
  followsAggregate: FollowAggregateBoolExp
  formSubmissions: FormSubmissionBoolExp
  formSubmissionsAggregate: FormSubmissionAggregateBoolExp
  forms: FormBoolExp
  formsAggregate: FormAggregateBoolExp
  grantAllocates: GrantAllocateBoolExp
  grantAllocatesAggregate: GrantAllocateAggregateBoolExp
  grants: GrantBoolExp
  grantsAggregate: GrantAggregateBoolExp
  id: BigintComparisonExp
  isOidcEnabled: BooleanComparisonExp
  locations: LocationBoolExp
  locationsAggregate: LocationAggregateBoolExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  missions: MissionBoolExp
  missionsAggregate: MissionAggregateBoolExp
  oidcCallbackUri: StringComparisonExp
  oidcClientId: StringComparisonExp
  oidcClientSecret: StringComparisonExp
  oidcDiscoveryUrl: StringComparisonExp
  oidcName: StringComparisonExp
  oidcScopes: StringComparisonExp
  pointName: StringComparisonExp
  poles: PoleBoolExp
  polesAggregate: PoleAggregateBoolExp
  projects: ProjectBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  socials: SocialBoolExp
  socialsAggregate: SocialAggregateBoolExp
  tags: TagBoolExp
  tagsAggregate: TagAggregateBoolExp
  teamDocuments: TeamDocumentBoolExp
  teamDocumentsAggregate: TeamDocumentAggregateBoolExp
  teamHistories: TeamHistoryBoolExp
  teamHistoriesAggregate: TeamHistoryAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMemberRoles: TeamMemberRoleBoolExp
  teamMemberRolesAggregate: TeamMemberRoleAggregateBoolExp
  teamMembers: TeamMemberBoolExp
  teamMembersAggregate: TeamMemberAggregateBoolExp
  teamRoles: TeamRoleBoolExp
  teamRolesAggregate: TeamRoleAggregateBoolExp
  teams: TeamBoolExp
  teamsAggregate: TeamAggregateBoolExp
  tenantMemberRoles: TenantMemberRoleBoolExp
  tenantMemberRolesAggregate: TenantMemberRoleAggregateBoolExp
  tenantMembers: TenantMemberBoolExp
  tenantMembersAggregate: TenantMemberAggregateBoolExp
  tenantOrganizes: TenantOrganizeBoolExp
  tenantOrganizesAggregate: TenantOrganizeAggregateBoolExp
  tenantRoles: TenantRoleBoolExp
  tenantRolesAggregate: TenantRoleAggregateBoolExp
  transactions: TransactionBoolExp
  transactionsAggregate: TransactionAggregateBoolExp
  users: UserBoolExp
  usersAggregate: UserAggregateBoolExp
}

# unique or primary key constraints on table "tenant"
enum TenantConstraint {
  # unique or primary key constraint on columns "actor_id"
  tenant_actor_id_unique

  # unique or primary key constraint on columns "domain"
  tenant_domain_unique

  # unique or primary key constraint on columns "event_validation_form_id"
  tenant_event_validation_form_id_unique

  # unique or primary key constraint on columns "oidc_name"
  tenant_oidc_name_unique

  # unique or primary key constraint on columns "id"
  tenant_pkey
}

# input type for incrementing numeric columns in table "tenant"
input TenantIncInput {
  actorId: bigint
  createdById: bigint
  eventValidationFormId: bigint
  id: bigint
}

# input type for inserting data into table "tenant"
input TenantInsertInput {
  actions: ActionArrRelInsertInput
  actor: ActorObjRelInsertInput
  actorId: bigint
  actorImages: ActorImageArrRelInsertInput
  actorTags: ActorTagArrRelInsertInput
  actors: ActorArrRelInsertInput
  bankAccounts: BankAccountArrRelInsertInput
  bankInfos: BankInfoArrRelInsertInput
  campusClusters: CampusClusterArrRelInsertInput
  campuses: CampusArrRelInsertInput
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventApprovalSteps: EventApprovalStepArrRelInsertInput
  eventApprovals: EventApprovalArrRelInsertInput
  eventFavorites: EventFavoriteArrRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  eventOrganizes: EventOrganizeArrRelInsertInput
  eventSupervisors: EventSupervisorArrRelInsertInput
  eventValidationForm: FormObjRelInsertInput
  eventValidationFormId: bigint
  events: EventArrRelInsertInput
  expenseItems: ExpenseItemArrRelInsertInput
  expenses: ExpenseArrRelInsertInput
  fileUploads: FileUploadArrRelInsertInput
  follows: FollowArrRelInsertInput
  formSubmissions: FormSubmissionArrRelInsertInput
  forms: FormArrRelInsertInput
  grantAllocates: GrantAllocateArrRelInsertInput
  grants: GrantArrRelInsertInput
  id: bigint
  isOidcEnabled: Boolean
  locations: LocationArrRelInsertInput
  missionJoins: MissionJoinArrRelInsertInput
  missions: MissionArrRelInsertInput
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
  poles: PoleArrRelInsertInput
  projects: ProjectArrRelInsertInput
  socials: SocialArrRelInsertInput
  tags: TagArrRelInsertInput
  teamDocuments: TeamDocumentArrRelInsertInput
  teamHistories: TeamHistoryArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMemberRoles: TeamMemberRoleArrRelInsertInput
  teamMembers: TeamMemberArrRelInsertInput
  teamRoles: TeamRoleArrRelInsertInput
  teams: TeamArrRelInsertInput
  tenantMemberRoles: TenantMemberRoleArrRelInsertInput
  tenantMembers: TenantMemberArrRelInsertInput
  tenantOrganizes: TenantOrganizeArrRelInsertInput
  tenantRoles: TenantRoleArrRelInsertInput
  transactions: TransactionArrRelInsertInput
  users: UserArrRelInsertInput
}

# aggregate max on columns
type TenantMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# order by max() on columns of table "tenant"
input TenantMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  domain: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
}

# columns and relationships of "tenant_member"
type TenantMember {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  id: bigint!
  permissions: Int!
  start: timestamptz!

  # An array relationship
  tenantMemberRoles(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # An aggregate relationship
  tenantMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An object relationship
  user: User!
  userId: bigint!
}

# aggregated selection of "tenant_member"
type TenantMemberAggregate {
  aggregate: TenantMemberAggregateFields
  nodes: [TenantMember!]!
}

input TenantMemberAggregateBoolExp {
  count: tenantMemberAggregateBoolExpCount
}

input tenantMemberAggregateBoolExpCount {
  arguments: [TenantMemberSelectColumn!]
  distinct: Boolean
  filter: TenantMemberBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant_member"
type TenantMemberAggregateFields {
  avg: TenantMemberAvgFields
  count(columns: [TenantMemberSelectColumn!], distinct: Boolean): Int!
  max: TenantMemberMaxFields
  min: TenantMemberMinFields
  stddev: TenantMemberStddevFields
  stddevPop: TenantMemberStddevPopFields
  stddevSamp: TenantMemberStddevSampFields
  sum: TenantMemberSumFields
  varPop: TenantMemberVarPopFields
  varSamp: TenantMemberVarSampFields
  variance: TenantMemberVarianceFields
}

# order by aggregate values of table "tenant_member"
input TenantMemberAggregateOrderBy {
  avg: TenantMemberAvgOrderBy
  count: OrderBy
  max: TenantMemberMaxOrderBy
  min: TenantMemberMinOrderBy
  stddev: TenantMemberStddevOrderBy
  stddevPop: TenantMemberStddevPopOrderBy
  stddevSamp: TenantMemberStddevSampOrderBy
  sum: TenantMemberSumOrderBy
  varPop: TenantMemberVarPopOrderBy
  varSamp: TenantMemberVarSampOrderBy
  variance: TenantMemberVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant_member"
input TenantMemberArrRelInsertInput {
  data: [TenantMemberInsertInput!]!

  # upsert condition
  onConflict: TenantMemberOnConflict
}

# aggregate avg on columns
type TenantMemberAvgFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by avg() on columns of table "tenant_member"
input TenantMemberAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Boolean expression to filter rows from the table "tenant_member". All fields are combined with a logical 'AND'.
input TenantMemberBoolExp {
  _and: [TenantMemberBoolExp!]
  _not: TenantMemberBoolExp
  _or: [TenantMemberBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  permissions: IntComparisonExp
  start: TimestamptzComparisonExp
  tenantMemberRoles: TenantMemberRoleBoolExp
  tenantMemberRolesAggregate: TenantMemberRoleAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  user: UserBoolExp
  userId: BigintComparisonExp
}

# unique or primary key constraints on table "tenant_member"
enum TenantMemberConstraint {
  # unique or primary key constraint on columns "id"
  tenant_member_pkey
}

# input type for incrementing numeric columns in table "tenant_member"
input TenantMemberIncInput {
  createdById: bigint
  id: bigint
  permissions: Int
  tenantScopeId: bigint
  userId: bigint
}

# input type for inserting data into table "tenant_member"
input TenantMemberInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  tenantMemberRoles: TenantMemberRoleArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  user: UserObjRelInsertInput
  userId: bigint
}

# aggregate max on columns
type TenantMemberMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  tenantScopeId: bigint
  userId: bigint
}

# order by max() on columns of table "tenant_member"
input TenantMemberMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type TenantMemberMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  tenantScopeId: bigint
  userId: bigint
}

# order by min() on columns of table "tenant_member"
input TenantMemberMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# response of any mutation on the table "tenant_member"
type TenantMemberMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TenantMember!]!
}

# input type for inserting object relation for remote table "tenant_member"
input TenantMemberObjRelInsertInput {
  data: TenantMemberInsertInput!

  # upsert condition
  onConflict: TenantMemberOnConflict
}

# on_conflict condition type for table "tenant_member"
input TenantMemberOnConflict {
  constraint: TenantMemberConstraint!
  updateColumns: [TenantMemberUpdateColumn!]! = []
  where: TenantMemberBoolExp
}

# Ordering options when selecting data from "tenant_member".
input TenantMemberOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  id: OrderBy
  permissions: OrderBy
  start: OrderBy
  tenantMemberRolesAggregate: TenantMemberRoleAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  user: UserOrderBy
  userId: OrderBy
}

# primary key columns input for table: tenant_member
input TenantMemberPkColumnsInput {
  id: bigint!
}

# columns and relationships of "tenant_member_role"
type TenantMemberRole {
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  tenantMember: TenantMember!
  tenantMemberId: bigint!

  # An object relationship
  tenantRole: TenantRole!
  tenantRoleId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "tenant_member_role"
type TenantMemberRoleAggregate {
  aggregate: TenantMemberRoleAggregateFields
  nodes: [TenantMemberRole!]!
}

input TenantMemberRoleAggregateBoolExp {
  count: tenantMemberRoleAggregateBoolExpCount
}

input tenantMemberRoleAggregateBoolExpCount {
  arguments: [TenantMemberRoleSelectColumn!]
  distinct: Boolean
  filter: TenantMemberRoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant_member_role"
type TenantMemberRoleAggregateFields {
  avg: TenantMemberRoleAvgFields
  count(columns: [TenantMemberRoleSelectColumn!], distinct: Boolean): Int!
  max: TenantMemberRoleMaxFields
  min: TenantMemberRoleMinFields
  stddev: TenantMemberRoleStddevFields
  stddevPop: TenantMemberRoleStddevPopFields
  stddevSamp: TenantMemberRoleStddevSampFields
  sum: TenantMemberRoleSumFields
  varPop: TenantMemberRoleVarPopFields
  varSamp: TenantMemberRoleVarSampFields
  variance: TenantMemberRoleVarianceFields
}

# order by aggregate values of table "tenant_member_role"
input TenantMemberRoleAggregateOrderBy {
  avg: TenantMemberRoleAvgOrderBy
  count: OrderBy
  max: TenantMemberRoleMaxOrderBy
  min: TenantMemberRoleMinOrderBy
  stddev: TenantMemberRoleStddevOrderBy
  stddevPop: TenantMemberRoleStddevPopOrderBy
  stddevSamp: TenantMemberRoleStddevSampOrderBy
  sum: TenantMemberRoleSumOrderBy
  varPop: TenantMemberRoleVarPopOrderBy
  varSamp: TenantMemberRoleVarSampOrderBy
  variance: TenantMemberRoleVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant_member_role"
input TenantMemberRoleArrRelInsertInput {
  data: [TenantMemberRoleInsertInput!]!

  # upsert condition
  onConflict: TenantMemberRoleOnConflict
}

# aggregate avg on columns
type TenantMemberRoleAvgFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "tenant_member_role"
input TenantMemberRoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "tenant_member_role". All fields are combined with a logical 'AND'.
input TenantMemberRoleBoolExp {
  _and: [TenantMemberRoleBoolExp!]
  _not: TenantMemberRoleBoolExp
  _or: [TenantMemberRoleBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  tenantMember: TenantMemberBoolExp
  tenantMemberId: BigintComparisonExp
  tenantRole: TenantRoleBoolExp
  tenantRoleId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "tenant_member_role"
enum TenantMemberRoleConstraint {
  # unique or primary key constraint on columns "id"
  tenant_member_role_pkey
}

# input type for incrementing numeric columns in table "tenant_member_role"
input TenantMemberRoleIncInput {
  createdById: bigint
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "tenant_member_role"
input TenantMemberRoleInsertInput {
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantMember: TenantMemberObjRelInsertInput
  tenantMemberId: bigint
  tenantRole: TenantRoleObjRelInsertInput
  tenantRoleId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type TenantMemberRoleMaxFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# order by max() on columns of table "tenant_member_role"
input TenantMemberRoleMaxOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type TenantMemberRoleMinFields {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# order by min() on columns of table "tenant_member_role"
input TenantMemberRoleMinOrderBy {
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "tenant_member_role"
type TenantMemberRoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TenantMemberRole!]!
}

# on_conflict condition type for table "tenant_member_role"
input TenantMemberRoleOnConflict {
  constraint: TenantMemberRoleConstraint!
  updateColumns: [TenantMemberRoleUpdateColumn!]! = []
  where: TenantMemberRoleBoolExp
}

# Ordering options when selecting data from "tenant_member_role".
input TenantMemberRoleOrderBy {
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  tenantMember: TenantMemberOrderBy
  tenantMemberId: OrderBy
  tenantRole: TenantRoleOrderBy
  tenantRoleId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: tenant_member_role
input TenantMemberRolePkColumnsInput {
  id: bigint!
}

# select columns of table "tenant_member_role"
enum TenantMemberRoleSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantMemberId

  # column name
  tenantRoleId

  # column name
  tenantScopeId
}

# input type for updating data in table "tenant_member_role"
input TenantMemberRoleSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# aggregate stddev on columns
type TenantMemberRoleStddevFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "tenant_member_role"
input TenantMemberRoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TenantMemberRoleStddevPopFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "tenant_member_role"
input TenantMemberRoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TenantMemberRoleStddevSampFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "tenant_member_role"
input TenantMemberRoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "tenant_member_role"
input TenantMemberRoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantMemberRoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantMemberRoleStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# aggregate sum on columns
type TenantMemberRoleSumFields {
  createdById: bigint
  id: bigint
  tenantMemberId: bigint
  tenantRoleId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "tenant_member_role"
input TenantMemberRoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "tenant_member_role"
enum TenantMemberRoleUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  tenantMemberId

  # column name
  tenantRoleId

  # column name
  tenantScopeId
}

input TenantMemberRoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantMemberRoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantMemberRoleSetInput

  # filter the rows which have to be updated
  where: TenantMemberRoleBoolExp!
}

# aggregate variance on columns
type TenantMemberRoleVarianceFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "tenant_member_role"
input TenantMemberRoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TenantMemberRoleVarPopFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "tenant_member_role"
input TenantMemberRoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TenantMemberRoleVarSampFields {
  createdById: Float
  id: Float
  tenantMemberId: Float
  tenantRoleId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "tenant_member_role"
input TenantMemberRoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantMemberId: OrderBy
  tenantRoleId: OrderBy
  tenantScopeId: OrderBy
}

# select columns of table "tenant_member"
enum TenantMemberSelectColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  id

  # column name
  permissions

  # column name
  start

  # column name
  tenantScopeId

  # column name
  userId
}

# input type for updating data in table "tenant_member"
input TenantMemberSetInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  tenantScopeId: bigint
  userId: bigint
}

# aggregate stddev on columns
type TenantMemberStddevFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddev() on columns of table "tenant_member"
input TenantMemberStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevPop on columns
type TenantMemberStddevPopFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevPop() on columns of table "tenant_member"
input TenantMemberStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate stddevSamp on columns
type TenantMemberStddevSampFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by stddevSamp() on columns of table "tenant_member"
input TenantMemberStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# Streaming cursor of the table "tenant_member"
input TenantMemberStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantMemberStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantMemberStreamCursorValueInput {
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  id: bigint
  permissions: Int
  start: timestamptz
  tenantScopeId: bigint
  userId: bigint
}

# aggregate sum on columns
type TenantMemberSumFields {
  createdById: bigint
  id: bigint
  permissions: Int
  tenantScopeId: bigint
  userId: bigint
}

# order by sum() on columns of table "tenant_member"
input TenantMemberSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# update columns of table "tenant_member"
enum TenantMemberUpdateColumn {
  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  id

  # column name
  permissions

  # column name
  start

  # column name
  tenantScopeId

  # column name
  userId
}

input TenantMemberUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantMemberIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantMemberSetInput

  # filter the rows which have to be updated
  where: TenantMemberBoolExp!
}

# aggregate variance on columns
type TenantMemberVarianceFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by variance() on columns of table "tenant_member"
input TenantMemberVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varPop on columns
type TenantMemberVarPopFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by varPop() on columns of table "tenant_member"
input TenantMemberVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate varSamp on columns
type TenantMemberVarSampFields {
  createdById: Float
  id: Float
  permissions: Float
  tenantScopeId: Float
  userId: Float
}

# order by varSamp() on columns of table "tenant_member"
input TenantMemberVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  userId: OrderBy
}

# aggregate min on columns
type TenantMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# order by min() on columns of table "tenant"
input TenantMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  domain: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
}

# response of any mutation on the table "tenant"
type TenantMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Tenant!]!
}

# input type for inserting object relation for remote table "tenant"
input TenantObjRelInsertInput {
  data: TenantInsertInput!

  # upsert condition
  onConflict: TenantOnConflict
}

# on_conflict condition type for table "tenant"
input TenantOnConflict {
  constraint: TenantConstraint!
  updateColumns: [TenantUpdateColumn!]! = []
  where: TenantBoolExp
}

# Ordering options when selecting data from "tenant".
input TenantOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  actor: ActorOrderBy
  actorId: OrderBy
  actorImagesAggregate: ActorImageAggregateOrderBy
  actorTagsAggregate: ActorTagAggregateOrderBy
  actorsAggregate: ActorAggregateOrderBy
  bankAccountsAggregate: BankAccountAggregateOrderBy
  bankInfosAggregate: BankInfoAggregateOrderBy
  campusClustersAggregate: CampusClusterAggregateOrderBy
  campusesAggregate: CampusAggregateOrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  domain: OrderBy
  eventApprovalStepsAggregate: EventApprovalStepAggregateOrderBy
  eventApprovalsAggregate: EventApprovalAggregateOrderBy
  eventFavoritesAggregate: EventFavoriteAggregateOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  eventOrganizesAggregate: EventOrganizeAggregateOrderBy
  eventSupervisorsAggregate: EventSupervisorAggregateOrderBy
  eventValidationForm: FormOrderBy
  eventValidationFormId: OrderBy
  eventsAggregate: EventAggregateOrderBy
  expenseItemsAggregate: ExpenseItemAggregateOrderBy
  expensesAggregate: ExpenseAggregateOrderBy
  fileUploadsAggregate: FileUploadAggregateOrderBy
  followsAggregate: FollowAggregateOrderBy
  formSubmissionsAggregate: FormSubmissionAggregateOrderBy
  formsAggregate: FormAggregateOrderBy
  grantAllocatesAggregate: GrantAllocateAggregateOrderBy
  grantsAggregate: GrantAggregateOrderBy
  id: OrderBy
  isOidcEnabled: OrderBy
  locationsAggregate: LocationAggregateOrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  missionsAggregate: MissionAggregateOrderBy
  oidcCallbackUri: OrderBy
  oidcClientId: OrderBy
  oidcClientSecret: OrderBy
  oidcDiscoveryUrl: OrderBy
  oidcName: OrderBy
  oidcScopes: OrderBy
  pointName: OrderBy
  polesAggregate: PoleAggregateOrderBy
  projectsAggregate: ProjectAggregateOrderBy
  socialsAggregate: SocialAggregateOrderBy
  tagsAggregate: TagAggregateOrderBy
  teamDocumentsAggregate: TeamDocumentAggregateOrderBy
  teamHistoriesAggregate: TeamHistoryAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMemberRolesAggregate: TeamMemberRoleAggregateOrderBy
  teamMembersAggregate: TeamMemberAggregateOrderBy
  teamRolesAggregate: TeamRoleAggregateOrderBy
  teamsAggregate: TeamAggregateOrderBy
  tenantMemberRolesAggregate: TenantMemberRoleAggregateOrderBy
  tenantMembersAggregate: TenantMemberAggregateOrderBy
  tenantOrganizesAggregate: TenantOrganizeAggregateOrderBy
  tenantRolesAggregate: TenantRoleAggregateOrderBy
  transactionsAggregate: TransactionAggregateOrderBy
  usersAggregate: UserAggregateOrderBy
}

# columns and relationships of "tenant_organize"
type TenantOrganize {
  # An object relationship
  campusCluster: CampusCluster!
  campusClusterId: bigint!
  createdAt: timestamptz!
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  team: Team!
  teamId: bigint!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String!

  # An object relationship
  user: User
}

# aggregated selection of "tenant_organize"
type TenantOrganizeAggregate {
  aggregate: TenantOrganizeAggregateFields
  nodes: [TenantOrganize!]!
}

input TenantOrganizeAggregateBoolExp {
  count: tenantOrganizeAggregateBoolExpCount
}

input tenantOrganizeAggregateBoolExpCount {
  arguments: [TenantOrganizeSelectColumn!]
  distinct: Boolean
  filter: TenantOrganizeBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant_organize"
type TenantOrganizeAggregateFields {
  avg: TenantOrganizeAvgFields
  count(columns: [TenantOrganizeSelectColumn!], distinct: Boolean): Int!
  max: TenantOrganizeMaxFields
  min: TenantOrganizeMinFields
  stddev: TenantOrganizeStddevFields
  stddevPop: TenantOrganizeStddevPopFields
  stddevSamp: TenantOrganizeStddevSampFields
  sum: TenantOrganizeSumFields
  varPop: TenantOrganizeVarPopFields
  varSamp: TenantOrganizeVarSampFields
  variance: TenantOrganizeVarianceFields
}

# order by aggregate values of table "tenant_organize"
input TenantOrganizeAggregateOrderBy {
  avg: TenantOrganizeAvgOrderBy
  count: OrderBy
  max: TenantOrganizeMaxOrderBy
  min: TenantOrganizeMinOrderBy
  stddev: TenantOrganizeStddevOrderBy
  stddevPop: TenantOrganizeStddevPopOrderBy
  stddevSamp: TenantOrganizeStddevSampOrderBy
  sum: TenantOrganizeSumOrderBy
  varPop: TenantOrganizeVarPopOrderBy
  varSamp: TenantOrganizeVarSampOrderBy
  variance: TenantOrganizeVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant_organize"
input TenantOrganizeArrRelInsertInput {
  data: [TenantOrganizeInsertInput!]!

  # upsert condition
  onConflict: TenantOrganizeOnConflict
}

# aggregate avg on columns
type TenantOrganizeAvgFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "tenant_organize"
input TenantOrganizeAvgOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "tenant_organize". All fields are combined with a logical 'AND'.
input TenantOrganizeBoolExp {
  _and: [TenantOrganizeBoolExp!]
  _not: TenantOrganizeBoolExp
  _or: [TenantOrganizeBoolExp!]
  campusCluster: CampusClusterBoolExp
  campusClusterId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  team: TeamBoolExp
  teamId: BigintComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
  user: UserBoolExp
}

# unique or primary key constraints on table "tenant_organize"
enum TenantOrganizeConstraint {
  # unique or primary key constraint on columns "id"
  tenant_organize_pkey
}

# input type for incrementing numeric columns in table "tenant_organize"
input TenantOrganizeIncInput {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "tenant_organize"
input TenantOrganizeInsertInput {
  campusCluster: CampusClusterObjRelInsertInput
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  team: TeamObjRelInsertInput
  teamId: bigint
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
  user: UserObjRelInsertInput
}

# aggregate max on columns
type TenantOrganizeMaxFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "tenant_organize"
input TenantOrganizeMaxOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type TenantOrganizeMinFields {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "tenant_organize"
input TenantOrganizeMinOrderBy {
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "tenant_organize"
type TenantOrganizeMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TenantOrganize!]!
}

# on_conflict condition type for table "tenant_organize"
input TenantOrganizeOnConflict {
  constraint: TenantOrganizeConstraint!
  updateColumns: [TenantOrganizeUpdateColumn!]! = []
  where: TenantOrganizeBoolExp
}

# Ordering options when selecting data from "tenant_organize".
input TenantOrganizeOrderBy {
  campusCluster: CampusClusterOrderBy
  campusClusterId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  team: TeamOrderBy
  teamId: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
  user: UserOrderBy
}

# primary key columns input for table: tenant_organize
input TenantOrganizePkColumnsInput {
  id: bigint!
}

# select columns of table "tenant_organize"
enum TenantOrganizeSelectColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "tenant_organize"
input TenantOrganizeSetInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type TenantOrganizeStddevFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "tenant_organize"
input TenantOrganizeStddevOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TenantOrganizeStddevPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "tenant_organize"
input TenantOrganizeStddevPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TenantOrganizeStddevSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "tenant_organize"
input TenantOrganizeStddevSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "tenant_organize"
input TenantOrganizeStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantOrganizeStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantOrganizeStreamCursorValueInput {
  campusClusterId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type TenantOrganizeSumFields {
  campusClusterId: bigint
  createdById: bigint
  id: bigint
  teamId: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "tenant_organize"
input TenantOrganizeSumOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "tenant_organize"
enum TenantOrganizeUpdateColumn {
  # column name
  campusClusterId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  teamId

  # column name
  tenantScopeId

  # column name
  type
}

input TenantOrganizeUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantOrganizeIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantOrganizeSetInput

  # filter the rows which have to be updated
  where: TenantOrganizeBoolExp!
}

# aggregate variance on columns
type TenantOrganizeVarianceFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "tenant_organize"
input TenantOrganizeVarianceOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TenantOrganizeVarPopFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "tenant_organize"
input TenantOrganizeVarPopOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TenantOrganizeVarSampFields {
  campusClusterId: Float
  createdById: Float
  id: Float
  teamId: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "tenant_organize"
input TenantOrganizeVarSampOrderBy {
  campusClusterId: OrderBy
  createdById: OrderBy
  id: OrderBy
  teamId: OrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: tenant
input TenantPkColumnsInput {
  id: bigint!
}

# columns and relationships of "tenant_role"
type TenantRole {
  color: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint!
  name: String!
  permissions: [String!]!

  # An array relationship
  tenantMemberRoles(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # An aggregate relationship
  tenantMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
  type: String
}

# aggregated selection of "tenant_role"
type TenantRoleAggregate {
  aggregate: TenantRoleAggregateFields
  nodes: [TenantRole!]!
}

input TenantRoleAggregateBoolExp {
  count: tenantRoleAggregateBoolExpCount
}

input tenantRoleAggregateBoolExpCount {
  arguments: [TenantRoleSelectColumn!]
  distinct: Boolean
  filter: TenantRoleBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "tenant_role"
type TenantRoleAggregateFields {
  avg: TenantRoleAvgFields
  count(columns: [TenantRoleSelectColumn!], distinct: Boolean): Int!
  max: TenantRoleMaxFields
  min: TenantRoleMinFields
  stddev: TenantRoleStddevFields
  stddevPop: TenantRoleStddevPopFields
  stddevSamp: TenantRoleStddevSampFields
  sum: TenantRoleSumFields
  varPop: TenantRoleVarPopFields
  varSamp: TenantRoleVarSampFields
  variance: TenantRoleVarianceFields
}

# order by aggregate values of table "tenant_role"
input TenantRoleAggregateOrderBy {
  avg: TenantRoleAvgOrderBy
  count: OrderBy
  max: TenantRoleMaxOrderBy
  min: TenantRoleMinOrderBy
  stddev: TenantRoleStddevOrderBy
  stddevPop: TenantRoleStddevPopOrderBy
  stddevSamp: TenantRoleStddevSampOrderBy
  sum: TenantRoleSumOrderBy
  varPop: TenantRoleVarPopOrderBy
  varSamp: TenantRoleVarSampOrderBy
  variance: TenantRoleVarianceOrderBy
}

# input type for inserting array relation for remote table "tenant_role"
input TenantRoleArrRelInsertInput {
  data: [TenantRoleInsertInput!]!

  # upsert condition
  onConflict: TenantRoleOnConflict
}

# aggregate avg on columns
type TenantRoleAvgFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "tenant_role"
input TenantRoleAvgOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "tenant_role". All fields are combined with a logical 'AND'.
input TenantRoleBoolExp {
  _and: [TenantRoleBoolExp!]
  _not: TenantRoleBoolExp
  _or: [TenantRoleBoolExp!]
  color: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  permissions: StringArrayComparisonExp
  tenantMemberRoles: TenantMemberRoleBoolExp
  tenantMemberRolesAggregate: TenantMemberRoleAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  type: StringComparisonExp
}

# unique or primary key constraints on table "tenant_role"
enum TenantRoleConstraint {
  # unique or primary key constraint on columns "id"
  tenant_role_pkey
}

# input type for incrementing numeric columns in table "tenant_role"
input TenantRoleIncInput {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "tenant_role"
input TenantRoleInsertInput {
  color: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  tenantMemberRoles: TenantMemberRoleArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  type: String
}

# aggregate max on columns
type TenantRoleMaxFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  tenantScopeId: bigint
  type: String
}

# order by max() on columns of table "tenant_role"
input TenantRoleMaxOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# aggregate min on columns
type TenantRoleMinFields {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  tenantScopeId: bigint
  type: String
}

# order by min() on columns of table "tenant_role"
input TenantRoleMinOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# response of any mutation on the table "tenant_role"
type TenantRoleMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TenantRole!]!
}

# input type for inserting object relation for remote table "tenant_role"
input TenantRoleObjRelInsertInput {
  data: TenantRoleInsertInput!

  # upsert condition
  onConflict: TenantRoleOnConflict
}

# on_conflict condition type for table "tenant_role"
input TenantRoleOnConflict {
  constraint: TenantRoleConstraint!
  updateColumns: [TenantRoleUpdateColumn!]! = []
  where: TenantRoleBoolExp
}

# Ordering options when selecting data from "tenant_role".
input TenantRoleOrderBy {
  color: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  name: OrderBy
  permissions: OrderBy
  tenantMemberRolesAggregate: TenantMemberRoleAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  type: OrderBy
}

# primary key columns input for table: tenant_role
input TenantRolePkColumnsInput {
  id: bigint!
}

# select columns of table "tenant_role"
enum TenantRoleSelectColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  permissions

  # column name
  tenantScopeId

  # column name
  type
}

# input type for updating data in table "tenant_role"
input TenantRoleSetInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  tenantScopeId: bigint
  type: String
}

# aggregate stddev on columns
type TenantRoleStddevFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "tenant_role"
input TenantRoleStddevOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TenantRoleStddevPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "tenant_role"
input TenantRoleStddevPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TenantRoleStddevSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "tenant_role"
input TenantRoleStddevSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "tenant_role"
input TenantRoleStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantRoleStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantRoleStreamCursorValueInput {
  color: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  hiddenAt: timestamptz
  id: bigint
  name: String
  permissions: [String!]
  tenantScopeId: bigint
  type: String
}

# aggregate sum on columns
type TenantRoleSumFields {
  createdById: bigint
  id: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "tenant_role"
input TenantRoleSumOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "tenant_role"
enum TenantRoleUpdateColumn {
  # column name
  color

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  hiddenAt

  # column name
  id

  # column name
  name

  # column name
  permissions

  # column name
  tenantScopeId

  # column name
  type
}

input TenantRoleUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantRoleIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantRoleSetInput

  # filter the rows which have to be updated
  where: TenantRoleBoolExp!
}

# aggregate variance on columns
type TenantRoleVarianceFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "tenant_role"
input TenantRoleVarianceOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TenantRoleVarPopFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "tenant_role"
input TenantRoleVarPopOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TenantRoleVarSampFields {
  createdById: Float
  id: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "tenant_role"
input TenantRoleVarSampOrderBy {
  createdById: OrderBy
  id: OrderBy
  tenantScopeId: OrderBy
}

# select columns of table "tenant"
enum TenantSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  domain

  # column name
  eventValidationFormId

  # column name
  id

  # column name
  isOidcEnabled

  # column name
  oidcCallbackUri

  # column name
  oidcClientId

  # column name
  oidcClientSecret

  # column name
  oidcDiscoveryUrl

  # column name
  oidcName

  # column name
  oidcScopes

  # column name
  pointName
}

# select "tenantAggregateBoolExpBool_andArgumentsColumns" columns of table "tenant"
enum TenantSelectColumnTenantAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isOidcEnabled
}

# select "tenantAggregateBoolExpBool_orArgumentsColumns" columns of table "tenant"
enum TenantSelectColumnTenantAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isOidcEnabled
}

# input type for updating data in table "tenant"
input TenantSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  isOidcEnabled: Boolean
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# aggregate stddev on columns
type TenantStddevFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddev() on columns of table "tenant"
input TenantStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate stddevPop on columns
type TenantStddevPopFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddevPop() on columns of table "tenant"
input TenantStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate stddevSamp on columns
type TenantStddevSampFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by stddevSamp() on columns of table "tenant"
input TenantStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# Streaming cursor of the table "tenant"
input TenantStreamCursorInput {
  # Stream column input with initial value
  initialValue: TenantStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TenantStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  domain: String
  eventValidationFormId: bigint
  id: bigint
  isOidcEnabled: Boolean
  oidcCallbackUri: String
  oidcClientId: String
  oidcClientSecret: String
  oidcDiscoveryUrl: String
  oidcName: String
  oidcScopes: String
  pointName: String
}

# aggregate sum on columns
type TenantSumFields {
  actorId: bigint
  createdById: bigint
  eventValidationFormId: bigint
  id: bigint
}

# order by sum() on columns of table "tenant"
input TenantSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# update columns of table "tenant"
enum TenantUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  domain

  # column name
  eventValidationFormId

  # column name
  id

  # column name
  isOidcEnabled

  # column name
  oidcCallbackUri

  # column name
  oidcClientId

  # column name
  oidcClientSecret

  # column name
  oidcDiscoveryUrl

  # column name
  oidcName

  # column name
  oidcScopes

  # column name
  pointName
}

input TenantUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TenantIncInput

  # sets the columns of the filtered rows to the given values
  _set: TenantSetInput

  # filter the rows which have to be updated
  where: TenantBoolExp!
}

# aggregate variance on columns
type TenantVarianceFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by variance() on columns of table "tenant"
input TenantVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate varPop on columns
type TenantVarPopFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by varPop() on columns of table "tenant"
input TenantVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

# aggregate varSamp on columns
type TenantVarSampFields {
  actorId: Float
  createdById: Float
  eventValidationFormId: Float
  id: Float
}

# order by varSamp() on columns of table "tenant"
input TenantVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  eventValidationFormId: OrderBy
  id: OrderBy
}

scalar timestamptz

# Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "transaction"
type Transaction {
  amount: Float!

  # An object relationship
  bankAccount: BankAccount!
  bankAccountId: bigint!
  category: String!
  createdAt: timestamptz!

  # An object relationship
  createdBy: User
  createdById: bigint
  deletedAt: timestamptz
  description: String!

  # An object relationship
  event: Event
  eventId: bigint

  # An object relationship
  expense: Expense
  expenseId: bigint

  # An array relationship
  grantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  grantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An object relationship
  initiatedBy: User
  initiatedById: bigint
  initiatedByType: String!
  isOnline: Boolean!

  # An object relationship
  location: Location
  locationId: bigint
  method: String!
  payedAt: timestamptz!

  # An object relationship
  payedBy: Actor!
  payedById: bigint!

  # An object relationship
  project: Project
  projectId: bigint

  # An object relationship
  receivedBy: Actor!
  receivedById: bigint!
  state: String!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!

  # An array relationship
  transactionAttachments(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): [TransactionAttachments!]!

  # An aggregate relationship
  transactionAttachmentsAggregate(
    # distinct select on columns
    distinctOn: [TransactionAttachmentsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionAttachmentsOrderBy!]

    # filter the rows returned
    where: TransactionAttachmentsBoolExp
  ): TransactionAttachmentsAggregate!
}

# aggregated selection of "transaction"
type TransactionAggregate {
  aggregate: TransactionAggregateFields
  nodes: [Transaction!]!
}

input TransactionAggregateBoolExp {
  bool_and: transactionAggregateBoolExpBool_and
  bool_or: transactionAggregateBoolExpBool_or
  count: transactionAggregateBoolExpCount
}

input transactionAggregateBoolExpBool_and {
  arguments: TransactionSelectColumnTransactionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: TransactionBoolExp
  predicate: BooleanComparisonExp!
}

input transactionAggregateBoolExpBool_or {
  arguments: TransactionSelectColumnTransactionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: TransactionBoolExp
  predicate: BooleanComparisonExp!
}

input transactionAggregateBoolExpCount {
  arguments: [TransactionSelectColumn!]
  distinct: Boolean
  filter: TransactionBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "transaction"
type TransactionAggregateFields {
  avg: TransactionAvgFields
  count(columns: [TransactionSelectColumn!], distinct: Boolean): Int!
  max: TransactionMaxFields
  min: TransactionMinFields
  stddev: TransactionStddevFields
  stddevPop: TransactionStddevPopFields
  stddevSamp: TransactionStddevSampFields
  sum: TransactionSumFields
  varPop: TransactionVarPopFields
  varSamp: TransactionVarSampFields
  variance: TransactionVarianceFields
}

# order by aggregate values of table "transaction"
input TransactionAggregateOrderBy {
  avg: TransactionAvgOrderBy
  count: OrderBy
  max: TransactionMaxOrderBy
  min: TransactionMinOrderBy
  stddev: TransactionStddevOrderBy
  stddevPop: TransactionStddevPopOrderBy
  stddevSamp: TransactionStddevSampOrderBy
  sum: TransactionSumOrderBy
  varPop: TransactionVarPopOrderBy
  varSamp: TransactionVarSampOrderBy
  variance: TransactionVarianceOrderBy
}

# input type for inserting array relation for remote table "transaction"
input TransactionArrRelInsertInput {
  data: [TransactionInsertInput!]!

  # upsert condition
  onConflict: TransactionOnConflict
}

# columns and relationships of "transaction_attachments"
type TransactionAttachments {
  # An object relationship
  attachment: FileUpload!
  fileUploadId: bigint!

  # An object relationship
  transaction: Transaction!
  transactionId: bigint!
}

# aggregated selection of "transaction_attachments"
type TransactionAttachmentsAggregate {
  aggregate: TransactionAttachmentsAggregateFields
  nodes: [TransactionAttachments!]!
}

input TransactionAttachmentsAggregateBoolExp {
  count: transactionAttachmentsAggregateBoolExpCount
}

input transactionAttachmentsAggregateBoolExpCount {
  arguments: [TransactionAttachmentsSelectColumn!]
  distinct: Boolean
  filter: TransactionAttachmentsBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "transaction_attachments"
type TransactionAttachmentsAggregateFields {
  avg: TransactionAttachmentsAvgFields
  count(columns: [TransactionAttachmentsSelectColumn!], distinct: Boolean): Int!
  max: TransactionAttachmentsMaxFields
  min: TransactionAttachmentsMinFields
  stddev: TransactionAttachmentsStddevFields
  stddevPop: TransactionAttachmentsStddevPopFields
  stddevSamp: TransactionAttachmentsStddevSampFields
  sum: TransactionAttachmentsSumFields
  varPop: TransactionAttachmentsVarPopFields
  varSamp: TransactionAttachmentsVarSampFields
  variance: TransactionAttachmentsVarianceFields
}

# order by aggregate values of table "transaction_attachments"
input TransactionAttachmentsAggregateOrderBy {
  avg: TransactionAttachmentsAvgOrderBy
  count: OrderBy
  max: TransactionAttachmentsMaxOrderBy
  min: TransactionAttachmentsMinOrderBy
  stddev: TransactionAttachmentsStddevOrderBy
  stddevPop: TransactionAttachmentsStddevPopOrderBy
  stddevSamp: TransactionAttachmentsStddevSampOrderBy
  sum: TransactionAttachmentsSumOrderBy
  varPop: TransactionAttachmentsVarPopOrderBy
  varSamp: TransactionAttachmentsVarSampOrderBy
  variance: TransactionAttachmentsVarianceOrderBy
}

# input type for inserting array relation for remote table "transaction_attachments"
input TransactionAttachmentsArrRelInsertInput {
  data: [TransactionAttachmentsInsertInput!]!

  # upsert condition
  onConflict: TransactionAttachmentsOnConflict
}

# aggregate avg on columns
type TransactionAttachmentsAvgFields {
  fileUploadId: Float
  transactionId: Float
}

# order by avg() on columns of table "transaction_attachments"
input TransactionAttachmentsAvgOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# Boolean expression to filter rows from the table "transaction_attachments". All fields are combined with a logical 'AND'.
input TransactionAttachmentsBoolExp {
  _and: [TransactionAttachmentsBoolExp!]
  _not: TransactionAttachmentsBoolExp
  _or: [TransactionAttachmentsBoolExp!]
  attachment: FileUploadBoolExp
  fileUploadId: BigintComparisonExp
  transaction: TransactionBoolExp
  transactionId: BigintComparisonExp
}

# unique or primary key constraints on table "transaction_attachments"
enum TransactionAttachmentsConstraint {
  # unique or primary key constraint on columns "transaction_id", "file_upload_id"
  transaction_attachments_pkey
}

# input type for incrementing numeric columns in table "transaction_attachments"
input TransactionAttachmentsIncInput {
  fileUploadId: bigint
  transactionId: bigint
}

# input type for inserting data into table "transaction_attachments"
input TransactionAttachmentsInsertInput {
  attachment: FileUploadObjRelInsertInput
  fileUploadId: bigint
  transaction: TransactionObjRelInsertInput
  transactionId: bigint
}

# aggregate max on columns
type TransactionAttachmentsMaxFields {
  fileUploadId: bigint
  transactionId: bigint
}

# order by max() on columns of table "transaction_attachments"
input TransactionAttachmentsMaxOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate min on columns
type TransactionAttachmentsMinFields {
  fileUploadId: bigint
  transactionId: bigint
}

# order by min() on columns of table "transaction_attachments"
input TransactionAttachmentsMinOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# response of any mutation on the table "transaction_attachments"
type TransactionAttachmentsMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [TransactionAttachments!]!
}

# on_conflict condition type for table "transaction_attachments"
input TransactionAttachmentsOnConflict {
  constraint: TransactionAttachmentsConstraint!
  updateColumns: [TransactionAttachmentsUpdateColumn!]! = []
  where: TransactionAttachmentsBoolExp
}

# Ordering options when selecting data from "transaction_attachments".
input TransactionAttachmentsOrderBy {
  attachment: FileUploadOrderBy
  fileUploadId: OrderBy
  transaction: TransactionOrderBy
  transactionId: OrderBy
}

# primary key columns input for table: transaction_attachments
input TransactionAttachmentsPkColumnsInput {
  fileUploadId: bigint!
  transactionId: bigint!
}

# select columns of table "transaction_attachments"
enum TransactionAttachmentsSelectColumn {
  # column name
  fileUploadId

  # column name
  transactionId
}

# input type for updating data in table "transaction_attachments"
input TransactionAttachmentsSetInput {
  fileUploadId: bigint
  transactionId: bigint
}

# aggregate stddev on columns
type TransactionAttachmentsStddevFields {
  fileUploadId: Float
  transactionId: Float
}

# order by stddev() on columns of table "transaction_attachments"
input TransactionAttachmentsStddevOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate stddevPop on columns
type TransactionAttachmentsStddevPopFields {
  fileUploadId: Float
  transactionId: Float
}

# order by stddevPop() on columns of table "transaction_attachments"
input TransactionAttachmentsStddevPopOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate stddevSamp on columns
type TransactionAttachmentsStddevSampFields {
  fileUploadId: Float
  transactionId: Float
}

# order by stddevSamp() on columns of table "transaction_attachments"
input TransactionAttachmentsStddevSampOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# Streaming cursor of the table "transaction_attachments"
input TransactionAttachmentsStreamCursorInput {
  # Stream column input with initial value
  initialValue: TransactionAttachmentsStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TransactionAttachmentsStreamCursorValueInput {
  fileUploadId: bigint
  transactionId: bigint
}

# aggregate sum on columns
type TransactionAttachmentsSumFields {
  fileUploadId: bigint
  transactionId: bigint
}

# order by sum() on columns of table "transaction_attachments"
input TransactionAttachmentsSumOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# update columns of table "transaction_attachments"
enum TransactionAttachmentsUpdateColumn {
  # column name
  fileUploadId

  # column name
  transactionId
}

input TransactionAttachmentsUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TransactionAttachmentsIncInput

  # sets the columns of the filtered rows to the given values
  _set: TransactionAttachmentsSetInput

  # filter the rows which have to be updated
  where: TransactionAttachmentsBoolExp!
}

# aggregate variance on columns
type TransactionAttachmentsVarianceFields {
  fileUploadId: Float
  transactionId: Float
}

# order by variance() on columns of table "transaction_attachments"
input TransactionAttachmentsVarianceOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate varPop on columns
type TransactionAttachmentsVarPopFields {
  fileUploadId: Float
  transactionId: Float
}

# order by varPop() on columns of table "transaction_attachments"
input TransactionAttachmentsVarPopOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate varSamp on columns
type TransactionAttachmentsVarSampFields {
  fileUploadId: Float
  transactionId: Float
}

# order by varSamp() on columns of table "transaction_attachments"
input TransactionAttachmentsVarSampOrderBy {
  fileUploadId: OrderBy
  transactionId: OrderBy
}

# aggregate avg on columns
type TransactionAvgFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "transaction"
input TransactionAvgOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
input TransactionBoolExp {
  _and: [TransactionBoolExp!]
  _not: TransactionBoolExp
  _or: [TransactionBoolExp!]
  amount: FloatComparisonExp
  bankAccount: BankAccountBoolExp
  bankAccountId: BigintComparisonExp
  category: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  deletedAt: TimestamptzComparisonExp
  description: StringComparisonExp
  event: EventBoolExp
  eventId: BigintComparisonExp
  expense: ExpenseBoolExp
  expenseId: BigintComparisonExp
  grantAllocates: GrantAllocateBoolExp
  grantAllocatesAggregate: GrantAllocateAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  initiatedBy: UserBoolExp
  initiatedById: BigintComparisonExp
  initiatedByType: StringComparisonExp
  isOnline: BooleanComparisonExp
  location: LocationBoolExp
  locationId: BigintComparisonExp
  method: StringComparisonExp
  payedAt: TimestamptzComparisonExp
  payedBy: ActorBoolExp
  payedById: BigintComparisonExp
  project: ProjectBoolExp
  projectId: BigintComparisonExp
  receivedBy: ActorBoolExp
  receivedById: BigintComparisonExp
  state: StringComparisonExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
  transactionAttachments: TransactionAttachmentsBoolExp
  transactionAttachmentsAggregate: TransactionAttachmentsAggregateBoolExp
}

# unique or primary key constraints on table "transaction"
enum TransactionConstraint {
  # unique or primary key constraint on columns "expense_id"
  transaction_expense_id_unique

  # unique or primary key constraint on columns "id"
  transaction_pkey
}

# input type for incrementing numeric columns in table "transaction"
input TransactionIncInput {
  amount: Float
  bankAccountId: bigint
  createdById: bigint
  eventId: bigint
  expenseId: bigint
  id: bigint
  initiatedById: bigint
  locationId: bigint
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  tenantScopeId: bigint
}

# input type for inserting data into table "transaction"
input TransactionInsertInput {
  amount: Float
  bankAccount: BankAccountObjRelInsertInput
  bankAccountId: bigint
  category: String
  createdAt: timestamptz
  createdBy: UserObjRelInsertInput
  createdById: bigint
  deletedAt: timestamptz
  description: String
  event: EventObjRelInsertInput
  eventId: bigint
  expense: ExpenseObjRelInsertInput
  expenseId: bigint
  grantAllocates: GrantAllocateArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  initiatedBy: UserObjRelInsertInput
  initiatedById: bigint
  initiatedByType: String
  isOnline: Boolean
  location: LocationObjRelInsertInput
  locationId: bigint
  method: String
  payedAt: timestamptz
  payedBy: ActorObjRelInsertInput
  payedById: bigint
  project: ProjectObjRelInsertInput
  projectId: bigint
  receivedBy: ActorObjRelInsertInput
  receivedById: bigint
  state: String
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
  transactionAttachments: TransactionAttachmentsArrRelInsertInput
}

# aggregate max on columns
type TransactionMaxFields {
  amount: Float
  bankAccountId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  initiatedById: bigint
  initiatedByType: String
  locationId: bigint
  method: String
  payedAt: timestamptz
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  state: String
  tenantScopeId: bigint
}

# order by max() on columns of table "transaction"
input TransactionMaxOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  initiatedByType: OrderBy
  locationId: OrderBy
  method: OrderBy
  payedAt: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type TransactionMinFields {
  amount: Float
  bankAccountId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  initiatedById: bigint
  initiatedByType: String
  locationId: bigint
  method: String
  payedAt: timestamptz
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  state: String
  tenantScopeId: bigint
}

# order by min() on columns of table "transaction"
input TransactionMinOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  initiatedByType: OrderBy
  locationId: OrderBy
  method: OrderBy
  payedAt: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  state: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "transaction"
type TransactionMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [Transaction!]!
}

# input type for inserting object relation for remote table "transaction"
input TransactionObjRelInsertInput {
  data: TransactionInsertInput!

  # upsert condition
  onConflict: TransactionOnConflict
}

# on_conflict condition type for table "transaction"
input TransactionOnConflict {
  constraint: TransactionConstraint!
  updateColumns: [TransactionUpdateColumn!]! = []
  where: TransactionBoolExp
}

# Ordering options when selecting data from "transaction".
input TransactionOrderBy {
  amount: OrderBy
  bankAccount: BankAccountOrderBy
  bankAccountId: OrderBy
  category: OrderBy
  createdAt: OrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  description: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  expense: ExpenseOrderBy
  expenseId: OrderBy
  grantAllocatesAggregate: GrantAllocateAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  initiatedBy: UserOrderBy
  initiatedById: OrderBy
  initiatedByType: OrderBy
  isOnline: OrderBy
  location: LocationOrderBy
  locationId: OrderBy
  method: OrderBy
  payedAt: OrderBy
  payedBy: ActorOrderBy
  payedById: OrderBy
  project: ProjectOrderBy
  projectId: OrderBy
  receivedBy: ActorOrderBy
  receivedById: OrderBy
  state: OrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
  transactionAttachmentsAggregate: TransactionAttachmentsAggregateOrderBy
}

# primary key columns input for table: transaction
input TransactionPkColumnsInput {
  id: bigint!
}

# select columns of table "transaction"
enum TransactionSelectColumn {
  # column name
  amount

  # column name
  bankAccountId

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  initiatedById

  # column name
  initiatedByType

  # column name
  isOnline

  # column name
  locationId

  # column name
  method

  # column name
  payedAt

  # column name
  payedById

  # column name
  projectId

  # column name
  receivedById

  # column name
  state

  # column name
  tenantScopeId
}

# select "transactionAggregateBoolExpBool_andArgumentsColumns" columns of table "transaction"
enum TransactionSelectColumnTransactionAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isOnline
}

# select "transactionAggregateBoolExpBool_orArgumentsColumns" columns of table "transaction"
enum TransactionSelectColumnTransactionAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isOnline
}

# input type for updating data in table "transaction"
input TransactionSetInput {
  amount: Float
  bankAccountId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  initiatedById: bigint
  initiatedByType: String
  isOnline: Boolean
  locationId: bigint
  method: String
  payedAt: timestamptz
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type TransactionStddevFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "transaction"
input TransactionStddevOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type TransactionStddevPopFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "transaction"
input TransactionStddevPopOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type TransactionStddevSampFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "transaction"
input TransactionStddevSampOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "transaction"
input TransactionStreamCursorInput {
  # Stream column input with initial value
  initialValue: TransactionStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input TransactionStreamCursorValueInput {
  amount: Float
  bankAccountId: bigint
  category: String
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  description: String
  eventId: bigint
  expenseId: bigint
  hiddenAt: timestamptz
  id: bigint
  initiatedById: bigint
  initiatedByType: String
  isOnline: Boolean
  locationId: bigint
  method: String
  payedAt: timestamptz
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  state: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type TransactionSumFields {
  amount: Float
  bankAccountId: bigint
  createdById: bigint
  eventId: bigint
  expenseId: bigint
  id: bigint
  initiatedById: bigint
  locationId: bigint
  payedById: bigint
  projectId: bigint
  receivedById: bigint
  tenantScopeId: bigint
}

# order by sum() on columns of table "transaction"
input TransactionSumOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "transaction"
enum TransactionUpdateColumn {
  # column name
  amount

  # column name
  bankAccountId

  # column name
  category

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  description

  # column name
  eventId

  # column name
  expenseId

  # column name
  hiddenAt

  # column name
  id

  # column name
  initiatedById

  # column name
  initiatedByType

  # column name
  isOnline

  # column name
  locationId

  # column name
  method

  # column name
  payedAt

  # column name
  payedById

  # column name
  projectId

  # column name
  receivedById

  # column name
  state

  # column name
  tenantScopeId
}

input TransactionUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: TransactionIncInput

  # sets the columns of the filtered rows to the given values
  _set: TransactionSetInput

  # filter the rows which have to be updated
  where: TransactionBoolExp!
}

# aggregate variance on columns
type TransactionVarianceFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "transaction"
input TransactionVarianceOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type TransactionVarPopFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "transaction"
input TransactionVarPopOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type TransactionVarSampFields {
  amount: Float
  bankAccountId: Float
  createdById: Float
  eventId: Float
  expenseId: Float
  id: Float
  initiatedById: Float
  locationId: Float
  payedById: Float
  projectId: Float
  receivedById: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "transaction"
input TransactionVarSampOrderBy {
  amount: OrderBy
  bankAccountId: OrderBy
  createdById: OrderBy
  eventId: OrderBy
  expenseId: OrderBy
  id: OrderBy
  initiatedById: OrderBy
  locationId: OrderBy
  payedById: OrderBy
  projectId: OrderBy
  receivedById: OrderBy
  tenantScopeId: OrderBy
}

# columns and relationships of "user"
type User {
  # An array relationship
  actions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  actionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An object relationship
  actor: Actor!
  actorId: bigint!

  # An array relationship
  createdActions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  createdActionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  createdActorImages(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): [ActorImage!]!

  # An aggregate relationship
  createdActorImagesAggregate(
    # distinct select on columns
    distinctOn: [ActorImageSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorImageOrderBy!]

    # filter the rows returned
    where: ActorImageBoolExp
  ): ActorImageAggregate!

  # An array relationship
  createdActorTags(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): [ActorTag!]!

  # An aggregate relationship
  createdActorTagsAggregate(
    # distinct select on columns
    distinctOn: [ActorTagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorTagOrderBy!]

    # filter the rows returned
    where: ActorTagBoolExp
  ): ActorTagAggregate!

  # An array relationship
  createdActors(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): [Actor!]!

  # An aggregate relationship
  createdActorsAggregate(
    # distinct select on columns
    distinctOn: [ActorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActorOrderBy!]

    # filter the rows returned
    where: ActorBoolExp
  ): ActorAggregate!

  # An array relationship
  createdAddresses(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): [Address!]!

  # An aggregate relationship
  createdAddressesAggregate(
    # distinct select on columns
    distinctOn: [AddressSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [AddressOrderBy!]

    # filter the rows returned
    where: AddressBoolExp
  ): AddressAggregate!
  createdAt: timestamptz!

  # An array relationship
  createdBankAccounts(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): [BankAccount!]!

  # An aggregate relationship
  createdBankAccountsAggregate(
    # distinct select on columns
    distinctOn: [BankAccountSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankAccountOrderBy!]

    # filter the rows returned
    where: BankAccountBoolExp
  ): BankAccountAggregate!

  # An array relationship
  createdBankInfos(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): [BankInfo!]!

  # An aggregate relationship
  createdBankInfosAggregate(
    # distinct select on columns
    distinctOn: [BankInfoSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [BankInfoOrderBy!]

    # filter the rows returned
    where: BankInfoBoolExp
  ): BankInfoAggregate!

  # An object relationship
  createdBy: User
  createdById: bigint

  # An array relationship
  createdCampusClusters(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): [CampusCluster!]!

  # An aggregate relationship
  createdCampusClustersAggregate(
    # distinct select on columns
    distinctOn: [CampusClusterSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusClusterOrderBy!]

    # filter the rows returned
    where: CampusClusterBoolExp
  ): CampusClusterAggregate!

  # An array relationship
  createdCampuses(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): [Campus!]!

  # An aggregate relationship
  createdCampusesAggregate(
    # distinct select on columns
    distinctOn: [CampusSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [CampusOrderBy!]

    # filter the rows returned
    where: CampusBoolExp
  ): CampusAggregate!

  # An array relationship
  createdEventApprovalSteps(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): [EventApprovalStep!]!

  # An aggregate relationship
  createdEventApprovalStepsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepOrderBy!]

    # filter the rows returned
    where: EventApprovalStepBoolExp
  ): EventApprovalStepAggregate!

  # An array relationship
  createdEventApprovals(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): [EventApproval!]!

  # An aggregate relationship
  createdEventApprovalsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalOrderBy!]

    # filter the rows returned
    where: EventApprovalBoolExp
  ): EventApprovalAggregate!

  # An array relationship
  createdEventFavorites(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): [EventFavorite!]!

  # An aggregate relationship
  createdEventFavoritesAggregate(
    # distinct select on columns
    distinctOn: [EventFavoriteSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventFavoriteOrderBy!]

    # filter the rows returned
    where: EventFavoriteBoolExp
  ): EventFavoriteAggregate!

  # An array relationship
  createdEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  createdEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  createdEventOrganizes(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): [EventOrganize!]!

  # An aggregate relationship
  createdEventOrganizesAggregate(
    # distinct select on columns
    distinctOn: [EventOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrganizeOrderBy!]

    # filter the rows returned
    where: EventOrganizeBoolExp
  ): EventOrganizeAggregate!

  # An array relationship
  createdEventSupervisors(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # An aggregate relationship
  createdEventSupervisorsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!

  # An array relationship
  createdEvents(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): [Event!]!

  # An aggregate relationship
  createdEventsAggregate(
    # distinct select on columns
    distinctOn: [EventSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventOrderBy!]

    # filter the rows returned
    where: EventBoolExp
  ): EventAggregate!

  # An array relationship
  createdExpenseItems(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): [ExpenseItem!]!

  # An aggregate relationship
  createdExpenseItemsAggregate(
    # distinct select on columns
    distinctOn: [ExpenseItemSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseItemOrderBy!]

    # filter the rows returned
    where: ExpenseItemBoolExp
  ): ExpenseItemAggregate!

  # An array relationship
  createdExpenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  createdExpensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  createdFileUploads(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): [FileUpload!]!

  # An aggregate relationship
  createdFileUploadsAggregate(
    # distinct select on columns
    distinctOn: [FileUploadSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FileUploadOrderBy!]

    # filter the rows returned
    where: FileUploadBoolExp
  ): FileUploadAggregate!

  # An array relationship
  createdFormSubmissions(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): [FormSubmission!]!

  # An aggregate relationship
  createdFormSubmissionsAggregate(
    # distinct select on columns
    distinctOn: [FormSubmissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormSubmissionOrderBy!]

    # filter the rows returned
    where: FormSubmissionBoolExp
  ): FormSubmissionAggregate!

  # An array relationship
  createdForms(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): [Form!]!

  # An aggregate relationship
  createdFormsAggregate(
    # distinct select on columns
    distinctOn: [FormSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FormOrderBy!]

    # filter the rows returned
    where: FormBoolExp
  ): FormAggregate!

  # An array relationship
  createdGrantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  createdGrantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  createdGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  createdGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  createdLegalUnitLocations(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): [LegalUnitLocation!]!

  # An aggregate relationship
  createdLegalUnitLocationsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitLocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitLocationOrderBy!]

    # filter the rows returned
    where: LegalUnitLocationBoolExp
  ): LegalUnitLocationAggregate!

  # An array relationship
  createdLegalUnits(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): [LegalUnit!]!

  # An aggregate relationship
  createdLegalUnitsAggregate(
    # distinct select on columns
    distinctOn: [LegalUnitSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LegalUnitOrderBy!]

    # filter the rows returned
    where: LegalUnitBoolExp
  ): LegalUnitAggregate!

  # An array relationship
  createdLocations(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): [Location!]!

  # An aggregate relationship
  createdLocationsAggregate(
    # distinct select on columns
    distinctOn: [LocationSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [LocationOrderBy!]

    # filter the rows returned
    where: LocationBoolExp
  ): LocationAggregate!

  # An array relationship
  createdMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  createdMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  createdMissions(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): [Mission!]!

  # An aggregate relationship
  createdMissionsAggregate(
    # distinct select on columns
    distinctOn: [MissionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionOrderBy!]

    # filter the rows returned
    where: MissionBoolExp
  ): MissionAggregate!

  # An array relationship
  createdPoles(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): [Pole!]!

  # An aggregate relationship
  createdPolesAggregate(
    # distinct select on columns
    distinctOn: [PoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [PoleOrderBy!]

    # filter the rows returned
    where: PoleBoolExp
  ): PoleAggregate!

  # An array relationship
  createdProjects(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): [Project!]!

  # An aggregate relationship
  createdProjectsAggregate(
    # distinct select on columns
    distinctOn: [ProjectSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ProjectOrderBy!]

    # filter the rows returned
    where: ProjectBoolExp
  ): ProjectAggregate!

  # An array relationship
  createdSocials(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): [Social!]!

  # An aggregate relationship
  createdSocialsAggregate(
    # distinct select on columns
    distinctOn: [SocialSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [SocialOrderBy!]

    # filter the rows returned
    where: SocialBoolExp
  ): SocialAggregate!

  # An array relationship
  createdTags(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): [Tag!]!

  # An aggregate relationship
  createdTagsAggregate(
    # distinct select on columns
    distinctOn: [TagSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TagOrderBy!]

    # filter the rows returned
    where: TagBoolExp
  ): TagAggregate!

  # An array relationship
  createdTeamDocuments(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): [TeamDocument!]!

  # An aggregate relationship
  createdTeamDocumentsAggregate(
    # distinct select on columns
    distinctOn: [TeamDocumentSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamDocumentOrderBy!]

    # filter the rows returned
    where: TeamDocumentBoolExp
  ): TeamDocumentAggregate!

  # An array relationship
  createdTeamHistories(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): [TeamHistory!]!

  # An aggregate relationship
  createdTeamHistoriesAggregate(
    # distinct select on columns
    distinctOn: [TeamHistorySelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamHistoryOrderBy!]

    # filter the rows returned
    where: TeamHistoryBoolExp
  ): TeamHistoryAggregate!

  # An array relationship
  createdTeamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  createdTeamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  createdTeamMemberRoles(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): [TeamMemberRole!]!

  # An aggregate relationship
  createdTeamMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberRoleOrderBy!]

    # filter the rows returned
    where: TeamMemberRoleBoolExp
  ): TeamMemberRoleAggregate!

  # An array relationship
  createdTeamMembers(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  createdTeamMembersAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  createdTeamRoles(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): [TeamRole!]!

  # An aggregate relationship
  createdTeamRolesAggregate(
    # distinct select on columns
    distinctOn: [TeamRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamRoleOrderBy!]

    # filter the rows returned
    where: TeamRoleBoolExp
  ): TeamRoleAggregate!

  # An array relationship
  createdTeams(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): [Team!]!

  # An aggregate relationship
  createdTeamsAggregate(
    # distinct select on columns
    distinctOn: [TeamSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamOrderBy!]

    # filter the rows returned
    where: TeamBoolExp
  ): TeamAggregate!

  # An array relationship
  createdTenantMembers(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # An aggregate relationship
  createdTenantMembersAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): TenantMemberAggregate!

  # An array relationship
  createdTenantOrganizes(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): [TenantOrganize!]!

  # An aggregate relationship
  createdTenantOrganizesAggregate(
    # distinct select on columns
    distinctOn: [TenantOrganizeSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrganizeOrderBy!]

    # filter the rows returned
    where: TenantOrganizeBoolExp
  ): TenantOrganizeAggregate!

  # An array relationship
  createdTenantRoles(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): [TenantRole!]!

  # An aggregate relationship
  createdTenantRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantRoleOrderBy!]

    # filter the rows returned
    where: TenantRoleBoolExp
  ): TenantRoleAggregate!

  # An array relationship
  createdTenants(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): [Tenant!]!

  # An aggregate relationship
  createdTenantsAggregate(
    # distinct select on columns
    distinctOn: [TenantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantOrderBy!]

    # filter the rows returned
    where: TenantBoolExp
  ): TenantAggregate!

  # An array relationship
  createdTransactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  createdTransactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!

  # An array relationship
  createdUsers(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): [User!]!

  # An aggregate relationship
  createdUsersAggregate(
    # distinct select on columns
    distinctOn: [UserSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [UserOrderBy!]

    # filter the rows returned
    where: UserBoolExp
  ): UserAggregate!
  deletedAt: timestamptz

  # An array relationship
  eventApprovalStepNotifiees(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): [EventApprovalStepNotifiees!]!

  # An aggregate relationship
  eventApprovalStepNotifieesAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepNotifieesSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepNotifieesOrderBy!]

    # filter the rows returned
    where: EventApprovalStepNotifieesBoolExp
  ): EventApprovalStepNotifieesAggregate!

  # An array relationship
  eventApprovalStepValidators(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): [EventApprovalStepValidators!]!

  # An aggregate relationship
  eventApprovalStepValidatorsAggregate(
    # distinct select on columns
    distinctOn: [EventApprovalStepValidatorsSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventApprovalStepValidatorsOrderBy!]

    # filter the rows returned
    where: EventApprovalStepValidatorsBoolExp
  ): EventApprovalStepValidatorsAggregate!

  # An array relationship
  eventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  eventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!
  firstName: String!

  # An array relationship
  following(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): [Follow!]!

  # An aggregate relationship
  followingAggregate(
    # distinct select on columns
    distinctOn: [FollowSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [FollowOrderBy!]

    # filter the rows returned
    where: FollowBoolExp
  ): FollowAggregate!
  hiddenAt: timestamptz
  id: bigint!

  # An array relationship
  initiatedTransactions(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): [Transaction!]!

  # An aggregate relationship
  initiatedTransactionsAggregate(
    # distinct select on columns
    distinctOn: [TransactionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TransactionOrderBy!]

    # filter the rows returned
    where: TransactionBoolExp
  ): TransactionAggregate!
  isBot: Boolean!
  isDarkModePreferred: Boolean!
  isDataAnonymizedOnDeactivation: Boolean!
  isDataExportedOnDeactivation: Boolean!
  isIntroductionFinished: Boolean!
  isOnboardingFinished: Boolean!
  lastName: String!
  middleNames: [String!]!

  # An array relationship
  missionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  missionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!
  passwordHash: String
  points: Float!

  # An array relationship
  pointsProcessedActions(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): [Action!]!

  # An aggregate relationship
  pointsProcessedActionsAggregate(
    # distinct select on columns
    distinctOn: [ActionSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ActionOrderBy!]

    # filter the rows returned
    where: ActionBoolExp
  ): ActionAggregate!

  # An array relationship
  pointsProcessedMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  pointsProcessedMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  processedEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  processedEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  processedExpenses(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): [Expense!]!

  # An aggregate relationship
  processedExpensesAggregate(
    # distinct select on columns
    distinctOn: [ExpenseSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [ExpenseOrderBy!]

    # filter the rows returned
    where: ExpenseBoolExp
  ): ExpenseAggregate!

  # An array relationship
  processedMissionJoins(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): [MissionJoin!]!

  # An aggregate relationship
  processedMissionJoinsAggregate(
    # distinct select on columns
    distinctOn: [MissionJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [MissionJoinOrderBy!]

    # filter the rows returned
    where: MissionJoinBoolExp
  ): MissionJoinAggregate!

  # An array relationship
  processedParticipationEventJoins(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): [EventJoin!]!

  # An aggregate relationship
  processedParticipationEventJoinsAggregate(
    # distinct select on columns
    distinctOn: [EventJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventJoinOrderBy!]

    # filter the rows returned
    where: EventJoinBoolExp
  ): EventJoinAggregate!

  # An array relationship
  processedReceivedAmountGrantAllocates(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): [GrantAllocate!]!

  # An aggregate relationship
  processedReceivedAmountGrantAllocatesAggregate(
    # distinct select on columns
    distinctOn: [GrantAllocateSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantAllocateOrderBy!]

    # filter the rows returned
    where: GrantAllocateBoolExp
  ): GrantAllocateAggregate!

  # An array relationship
  processedReceivedAmountGrants(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): [Grant!]!

  # An aggregate relationship
  processedReceivedAmountGrantsAggregate(
    # distinct select on columns
    distinctOn: [GrantSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [GrantOrderBy!]

    # filter the rows returned
    where: GrantBoolExp
  ): GrantAggregate!

  # An array relationship
  processedTeamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  processedTeamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!
  slug: String!

  # An array relationship
  supervisedEvents(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): [EventSupervisor!]!

  # An aggregate relationship
  supervisedEventsAggregate(
    # distinct select on columns
    distinctOn: [EventSupervisorSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [EventSupervisorOrderBy!]

    # filter the rows returned
    where: EventSupervisorBoolExp
  ): EventSupervisorAggregate!

  # An array relationship
  teamJoins(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): [TeamJoin!]!

  # An aggregate relationship
  teamJoinsAggregate(
    # distinct select on columns
    distinctOn: [TeamJoinSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamJoinOrderBy!]

    # filter the rows returned
    where: TeamJoinBoolExp
  ): TeamJoinAggregate!

  # An array relationship
  teamMemberships(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): [TeamMember!]!

  # An aggregate relationship
  teamMembershipsAggregate(
    # distinct select on columns
    distinctOn: [TeamMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TeamMemberOrderBy!]

    # filter the rows returned
    where: TeamMemberBoolExp
  ): TeamMemberAggregate!

  # An array relationship
  tenantMemberRoles(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): [TenantMemberRole!]!

  # An aggregate relationship
  tenantMemberRolesAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberRoleSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberRoleOrderBy!]

    # filter the rows returned
    where: TenantMemberRoleBoolExp
  ): TenantMemberRoleAggregate!

  # An array relationship
  tenantMemberships(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): [TenantMember!]!

  # An aggregate relationship
  tenantMembershipsAggregate(
    # distinct select on columns
    distinctOn: [TenantMemberSelectColumn!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    orderBy: [TenantMemberOrderBy!]

    # filter the rows returned
    where: TenantMemberBoolExp
  ): TenantMemberAggregate!

  # An object relationship
  tenantScope: Tenant!
  tenantScopeId: bigint!
}

# aggregated selection of "user"
type UserAggregate {
  aggregate: UserAggregateFields
  nodes: [User!]!
}

input UserAggregateBoolExp {
  bool_and: userAggregateBoolExpBool_and
  bool_or: userAggregateBoolExpBool_or
  count: userAggregateBoolExpCount
}

input userAggregateBoolExpBool_and {
  arguments: UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpBool_or {
  arguments: UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: UserBoolExp
  predicate: BooleanComparisonExp!
}

input userAggregateBoolExpCount {
  arguments: [UserSelectColumn!]
  distinct: Boolean
  filter: UserBoolExp
  predicate: IntComparisonExp!
}

# aggregate fields of "user"
type UserAggregateFields {
  avg: UserAvgFields
  count(columns: [UserSelectColumn!], distinct: Boolean): Int!
  max: UserMaxFields
  min: UserMinFields
  stddev: UserStddevFields
  stddevPop: UserStddevPopFields
  stddevSamp: UserStddevSampFields
  sum: UserSumFields
  varPop: UserVarPopFields
  varSamp: UserVarSampFields
  variance: UserVarianceFields
}

# order by aggregate values of table "user"
input UserAggregateOrderBy {
  avg: UserAvgOrderBy
  count: OrderBy
  max: UserMaxOrderBy
  min: UserMinOrderBy
  stddev: UserStddevOrderBy
  stddevPop: UserStddevPopOrderBy
  stddevSamp: UserStddevSampOrderBy
  sum: UserSumOrderBy
  varPop: UserVarPopOrderBy
  varSamp: UserVarSampOrderBy
  variance: UserVarianceOrderBy
}

# input type for inserting array relation for remote table "user"
input UserArrRelInsertInput {
  data: [UserInsertInput!]!

  # upsert condition
  onConflict: UserOnConflict
}

# aggregate avg on columns
type UserAvgFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by avg() on columns of table "user"
input UserAvgOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
input UserBoolExp {
  _and: [UserBoolExp!]
  _not: UserBoolExp
  _or: [UserBoolExp!]
  actions: ActionBoolExp
  actionsAggregate: ActionAggregateBoolExp
  actor: ActorBoolExp
  actorId: BigintComparisonExp
  createdActions: ActionBoolExp
  createdActionsAggregate: ActionAggregateBoolExp
  createdActorImages: ActorImageBoolExp
  createdActorImagesAggregate: ActorImageAggregateBoolExp
  createdActorTags: ActorTagBoolExp
  createdActorTagsAggregate: ActorTagAggregateBoolExp
  createdActors: ActorBoolExp
  createdActorsAggregate: ActorAggregateBoolExp
  createdAddresses: AddressBoolExp
  createdAddressesAggregate: AddressAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  createdBankAccounts: BankAccountBoolExp
  createdBankAccountsAggregate: BankAccountAggregateBoolExp
  createdBankInfos: BankInfoBoolExp
  createdBankInfosAggregate: BankInfoAggregateBoolExp
  createdBy: UserBoolExp
  createdById: BigintComparisonExp
  createdCampusClusters: CampusClusterBoolExp
  createdCampusClustersAggregate: CampusClusterAggregateBoolExp
  createdCampuses: CampusBoolExp
  createdCampusesAggregate: CampusAggregateBoolExp
  createdEventApprovalSteps: EventApprovalStepBoolExp
  createdEventApprovalStepsAggregate: EventApprovalStepAggregateBoolExp
  createdEventApprovals: EventApprovalBoolExp
  createdEventApprovalsAggregate: EventApprovalAggregateBoolExp
  createdEventFavorites: EventFavoriteBoolExp
  createdEventFavoritesAggregate: EventFavoriteAggregateBoolExp
  createdEventJoins: EventJoinBoolExp
  createdEventJoinsAggregate: EventJoinAggregateBoolExp
  createdEventOrganizes: EventOrganizeBoolExp
  createdEventOrganizesAggregate: EventOrganizeAggregateBoolExp
  createdEventSupervisors: EventSupervisorBoolExp
  createdEventSupervisorsAggregate: EventSupervisorAggregateBoolExp
  createdEvents: EventBoolExp
  createdEventsAggregate: EventAggregateBoolExp
  createdExpenseItems: ExpenseItemBoolExp
  createdExpenseItemsAggregate: ExpenseItemAggregateBoolExp
  createdExpenses: ExpenseBoolExp
  createdExpensesAggregate: ExpenseAggregateBoolExp
  createdFileUploads: FileUploadBoolExp
  createdFileUploadsAggregate: FileUploadAggregateBoolExp
  createdFormSubmissions: FormSubmissionBoolExp
  createdFormSubmissionsAggregate: FormSubmissionAggregateBoolExp
  createdForms: FormBoolExp
  createdFormsAggregate: FormAggregateBoolExp
  createdGrantAllocates: GrantAllocateBoolExp
  createdGrantAllocatesAggregate: GrantAllocateAggregateBoolExp
  createdGrants: GrantBoolExp
  createdGrantsAggregate: GrantAggregateBoolExp
  createdLegalUnitLocations: LegalUnitLocationBoolExp
  createdLegalUnitLocationsAggregate: LegalUnitLocationAggregateBoolExp
  createdLegalUnits: LegalUnitBoolExp
  createdLegalUnitsAggregate: LegalUnitAggregateBoolExp
  createdLocations: LocationBoolExp
  createdLocationsAggregate: LocationAggregateBoolExp
  createdMissionJoins: MissionJoinBoolExp
  createdMissionJoinsAggregate: MissionJoinAggregateBoolExp
  createdMissions: MissionBoolExp
  createdMissionsAggregate: MissionAggregateBoolExp
  createdPoles: PoleBoolExp
  createdPolesAggregate: PoleAggregateBoolExp
  createdProjects: ProjectBoolExp
  createdProjectsAggregate: ProjectAggregateBoolExp
  createdSocials: SocialBoolExp
  createdSocialsAggregate: SocialAggregateBoolExp
  createdTags: TagBoolExp
  createdTagsAggregate: TagAggregateBoolExp
  createdTeamDocuments: TeamDocumentBoolExp
  createdTeamDocumentsAggregate: TeamDocumentAggregateBoolExp
  createdTeamHistories: TeamHistoryBoolExp
  createdTeamHistoriesAggregate: TeamHistoryAggregateBoolExp
  createdTeamJoins: TeamJoinBoolExp
  createdTeamJoinsAggregate: TeamJoinAggregateBoolExp
  createdTeamMemberRoles: TeamMemberRoleBoolExp
  createdTeamMemberRolesAggregate: TeamMemberRoleAggregateBoolExp
  createdTeamMembers: TeamMemberBoolExp
  createdTeamMembersAggregate: TeamMemberAggregateBoolExp
  createdTeamRoles: TeamRoleBoolExp
  createdTeamRolesAggregate: TeamRoleAggregateBoolExp
  createdTeams: TeamBoolExp
  createdTeamsAggregate: TeamAggregateBoolExp
  createdTenantMembers: TenantMemberBoolExp
  createdTenantMembersAggregate: TenantMemberAggregateBoolExp
  createdTenantOrganizes: TenantOrganizeBoolExp
  createdTenantOrganizesAggregate: TenantOrganizeAggregateBoolExp
  createdTenantRoles: TenantRoleBoolExp
  createdTenantRolesAggregate: TenantRoleAggregateBoolExp
  createdTenants: TenantBoolExp
  createdTenantsAggregate: TenantAggregateBoolExp
  createdTransactions: TransactionBoolExp
  createdTransactionsAggregate: TransactionAggregateBoolExp
  createdUsers: UserBoolExp
  createdUsersAggregate: UserAggregateBoolExp
  deletedAt: TimestamptzComparisonExp
  eventApprovalStepNotifiees: EventApprovalStepNotifieesBoolExp
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateBoolExp
  eventApprovalStepValidators: EventApprovalStepValidatorsBoolExp
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateBoolExp
  eventJoins: EventJoinBoolExp
  eventJoinsAggregate: EventJoinAggregateBoolExp
  firstName: StringComparisonExp
  following: FollowBoolExp
  followingAggregate: FollowAggregateBoolExp
  hiddenAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  initiatedTransactions: TransactionBoolExp
  initiatedTransactionsAggregate: TransactionAggregateBoolExp
  isBot: BooleanComparisonExp
  isDarkModePreferred: BooleanComparisonExp
  isDataAnonymizedOnDeactivation: BooleanComparisonExp
  isDataExportedOnDeactivation: BooleanComparisonExp
  isIntroductionFinished: BooleanComparisonExp
  isOnboardingFinished: BooleanComparisonExp
  lastName: StringComparisonExp
  middleNames: StringArrayComparisonExp
  missionJoins: MissionJoinBoolExp
  missionJoinsAggregate: MissionJoinAggregateBoolExp
  passwordHash: StringComparisonExp
  points: FloatComparisonExp
  pointsProcessedActions: ActionBoolExp
  pointsProcessedActionsAggregate: ActionAggregateBoolExp
  pointsProcessedMissionJoins: MissionJoinBoolExp
  pointsProcessedMissionJoinsAggregate: MissionJoinAggregateBoolExp
  processedEventJoins: EventJoinBoolExp
  processedEventJoinsAggregate: EventJoinAggregateBoolExp
  processedExpenses: ExpenseBoolExp
  processedExpensesAggregate: ExpenseAggregateBoolExp
  processedMissionJoins: MissionJoinBoolExp
  processedMissionJoinsAggregate: MissionJoinAggregateBoolExp
  processedParticipationEventJoins: EventJoinBoolExp
  processedParticipationEventJoinsAggregate: EventJoinAggregateBoolExp
  processedReceivedAmountGrantAllocates: GrantAllocateBoolExp
  processedReceivedAmountGrantAllocatesAggregate: GrantAllocateAggregateBoolExp
  processedReceivedAmountGrants: GrantBoolExp
  processedReceivedAmountGrantsAggregate: GrantAggregateBoolExp
  processedTeamJoins: TeamJoinBoolExp
  processedTeamJoinsAggregate: TeamJoinAggregateBoolExp
  slug: StringComparisonExp
  supervisedEvents: EventSupervisorBoolExp
  supervisedEventsAggregate: EventSupervisorAggregateBoolExp
  teamJoins: TeamJoinBoolExp
  teamJoinsAggregate: TeamJoinAggregateBoolExp
  teamMemberships: TeamMemberBoolExp
  teamMembershipsAggregate: TeamMemberAggregateBoolExp
  tenantMemberRoles: TenantMemberRoleBoolExp
  tenantMemberRolesAggregate: TenantMemberRoleAggregateBoolExp
  tenantMemberships: TenantMemberBoolExp
  tenantMembershipsAggregate: TenantMemberAggregateBoolExp
  tenantScope: TenantBoolExp
  tenantScopeId: BigintComparisonExp
}

# unique or primary key constraints on table "user"
enum UserConstraint {
  # unique or primary key constraint on columns "actor_id"
  user_actor_id_unique

  # unique or primary key constraint on columns "id"
  user_pkey

  # unique or primary key constraint on columns "slug"
  user_slug_unique
}

# input type for incrementing numeric columns in table "user"
input UserIncInput {
  actorId: bigint
  createdById: bigint
  id: bigint
  points: Float
  tenantScopeId: bigint
}

# input type for inserting data into table "user"
input UserInsertInput {
  actions: ActionArrRelInsertInput
  actor: ActorObjRelInsertInput
  actorId: bigint
  createdActions: ActionArrRelInsertInput
  createdActorImages: ActorImageArrRelInsertInput
  createdActorTags: ActorTagArrRelInsertInput
  createdActors: ActorArrRelInsertInput
  createdAddresses: AddressArrRelInsertInput
  createdAt: timestamptz
  createdBankAccounts: BankAccountArrRelInsertInput
  createdBankInfos: BankInfoArrRelInsertInput
  createdBy: UserObjRelInsertInput
  createdById: bigint
  createdCampusClusters: CampusClusterArrRelInsertInput
  createdCampuses: CampusArrRelInsertInput
  createdEventApprovalSteps: EventApprovalStepArrRelInsertInput
  createdEventApprovals: EventApprovalArrRelInsertInput
  createdEventFavorites: EventFavoriteArrRelInsertInput
  createdEventJoins: EventJoinArrRelInsertInput
  createdEventOrganizes: EventOrganizeArrRelInsertInput
  createdEventSupervisors: EventSupervisorArrRelInsertInput
  createdEvents: EventArrRelInsertInput
  createdExpenseItems: ExpenseItemArrRelInsertInput
  createdExpenses: ExpenseArrRelInsertInput
  createdFileUploads: FileUploadArrRelInsertInput
  createdFormSubmissions: FormSubmissionArrRelInsertInput
  createdForms: FormArrRelInsertInput
  createdGrantAllocates: GrantAllocateArrRelInsertInput
  createdGrants: GrantArrRelInsertInput
  createdLegalUnitLocations: LegalUnitLocationArrRelInsertInput
  createdLegalUnits: LegalUnitArrRelInsertInput
  createdLocations: LocationArrRelInsertInput
  createdMissionJoins: MissionJoinArrRelInsertInput
  createdMissions: MissionArrRelInsertInput
  createdPoles: PoleArrRelInsertInput
  createdProjects: ProjectArrRelInsertInput
  createdSocials: SocialArrRelInsertInput
  createdTags: TagArrRelInsertInput
  createdTeamDocuments: TeamDocumentArrRelInsertInput
  createdTeamHistories: TeamHistoryArrRelInsertInput
  createdTeamJoins: TeamJoinArrRelInsertInput
  createdTeamMemberRoles: TeamMemberRoleArrRelInsertInput
  createdTeamMembers: TeamMemberArrRelInsertInput
  createdTeamRoles: TeamRoleArrRelInsertInput
  createdTeams: TeamArrRelInsertInput
  createdTenantMembers: TenantMemberArrRelInsertInput
  createdTenantOrganizes: TenantOrganizeArrRelInsertInput
  createdTenantRoles: TenantRoleArrRelInsertInput
  createdTenants: TenantArrRelInsertInput
  createdTransactions: TransactionArrRelInsertInput
  createdUsers: UserArrRelInsertInput
  deletedAt: timestamptz
  eventApprovalStepNotifiees: EventApprovalStepNotifieesArrRelInsertInput
  eventApprovalStepValidators: EventApprovalStepValidatorsArrRelInsertInput
  eventJoins: EventJoinArrRelInsertInput
  firstName: String
  following: FollowArrRelInsertInput
  hiddenAt: timestamptz
  id: bigint
  initiatedTransactions: TransactionArrRelInsertInput
  isBot: Boolean
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: [String!]
  missionJoins: MissionJoinArrRelInsertInput
  passwordHash: String
  points: Float
  pointsProcessedActions: ActionArrRelInsertInput
  pointsProcessedMissionJoins: MissionJoinArrRelInsertInput
  processedEventJoins: EventJoinArrRelInsertInput
  processedExpenses: ExpenseArrRelInsertInput
  processedMissionJoins: MissionJoinArrRelInsertInput
  processedParticipationEventJoins: EventJoinArrRelInsertInput
  processedReceivedAmountGrantAllocates: GrantAllocateArrRelInsertInput
  processedReceivedAmountGrants: GrantArrRelInsertInput
  processedTeamJoins: TeamJoinArrRelInsertInput
  slug: String
  supervisedEvents: EventSupervisorArrRelInsertInput
  teamJoins: TeamJoinArrRelInsertInput
  teamMemberships: TeamMemberArrRelInsertInput
  tenantMemberRoles: TenantMemberRoleArrRelInsertInput
  tenantMemberships: TenantMemberArrRelInsertInput
  tenantScope: TenantObjRelInsertInput
  tenantScopeId: bigint
}

# aggregate max on columns
type UserMaxFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  lastName: String
  middleNames: [String!]
  passwordHash: String
  points: Float
  slug: String
  tenantScopeId: bigint
}

# order by max() on columns of table "user"
input UserMaxOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  firstName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastName: OrderBy
  middleNames: OrderBy
  passwordHash: OrderBy
  points: OrderBy
  slug: OrderBy
  tenantScopeId: OrderBy
}

# aggregate min on columns
type UserMinFields {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  lastName: String
  middleNames: [String!]
  passwordHash: String
  points: Float
  slug: String
  tenantScopeId: bigint
}

# order by min() on columns of table "user"
input UserMinOrderBy {
  actorId: OrderBy
  createdAt: OrderBy
  createdById: OrderBy
  deletedAt: OrderBy
  firstName: OrderBy
  hiddenAt: OrderBy
  id: OrderBy
  lastName: OrderBy
  middleNames: OrderBy
  passwordHash: OrderBy
  points: OrderBy
  slug: OrderBy
  tenantScopeId: OrderBy
}

# response of any mutation on the table "user"
type UserMutationResponse {
  # number of rows affected by the mutation
  affectedRows: Int!

  # data from the rows affected by the mutation
  returning: [User!]!
}

# input type for inserting object relation for remote table "user"
input UserObjRelInsertInput {
  data: UserInsertInput!

  # upsert condition
  onConflict: UserOnConflict
}

# on_conflict condition type for table "user"
input UserOnConflict {
  constraint: UserConstraint!
  updateColumns: [UserUpdateColumn!]! = []
  where: UserBoolExp
}

# Ordering options when selecting data from "user".
input UserOrderBy {
  actionsAggregate: ActionAggregateOrderBy
  actor: ActorOrderBy
  actorId: OrderBy
  createdActionsAggregate: ActionAggregateOrderBy
  createdActorImagesAggregate: ActorImageAggregateOrderBy
  createdActorTagsAggregate: ActorTagAggregateOrderBy
  createdActorsAggregate: ActorAggregateOrderBy
  createdAddressesAggregate: AddressAggregateOrderBy
  createdAt: OrderBy
  createdBankAccountsAggregate: BankAccountAggregateOrderBy
  createdBankInfosAggregate: BankInfoAggregateOrderBy
  createdBy: UserOrderBy
  createdById: OrderBy
  createdCampusClustersAggregate: CampusClusterAggregateOrderBy
  createdCampusesAggregate: CampusAggregateOrderBy
  createdEventApprovalStepsAggregate: EventApprovalStepAggregateOrderBy
  createdEventApprovalsAggregate: EventApprovalAggregateOrderBy
  createdEventFavoritesAggregate: EventFavoriteAggregateOrderBy
  createdEventJoinsAggregate: EventJoinAggregateOrderBy
  createdEventOrganizesAggregate: EventOrganizeAggregateOrderBy
  createdEventSupervisorsAggregate: EventSupervisorAggregateOrderBy
  createdEventsAggregate: EventAggregateOrderBy
  createdExpenseItemsAggregate: ExpenseItemAggregateOrderBy
  createdExpensesAggregate: ExpenseAggregateOrderBy
  createdFileUploadsAggregate: FileUploadAggregateOrderBy
  createdFormSubmissionsAggregate: FormSubmissionAggregateOrderBy
  createdFormsAggregate: FormAggregateOrderBy
  createdGrantAllocatesAggregate: GrantAllocateAggregateOrderBy
  createdGrantsAggregate: GrantAggregateOrderBy
  createdLegalUnitLocationsAggregate: LegalUnitLocationAggregateOrderBy
  createdLegalUnitsAggregate: LegalUnitAggregateOrderBy
  createdLocationsAggregate: LocationAggregateOrderBy
  createdMissionJoinsAggregate: MissionJoinAggregateOrderBy
  createdMissionsAggregate: MissionAggregateOrderBy
  createdPolesAggregate: PoleAggregateOrderBy
  createdProjectsAggregate: ProjectAggregateOrderBy
  createdSocialsAggregate: SocialAggregateOrderBy
  createdTagsAggregate: TagAggregateOrderBy
  createdTeamDocumentsAggregate: TeamDocumentAggregateOrderBy
  createdTeamHistoriesAggregate: TeamHistoryAggregateOrderBy
  createdTeamJoinsAggregate: TeamJoinAggregateOrderBy
  createdTeamMemberRolesAggregate: TeamMemberRoleAggregateOrderBy
  createdTeamMembersAggregate: TeamMemberAggregateOrderBy
  createdTeamRolesAggregate: TeamRoleAggregateOrderBy
  createdTeamsAggregate: TeamAggregateOrderBy
  createdTenantMembersAggregate: TenantMemberAggregateOrderBy
  createdTenantOrganizesAggregate: TenantOrganizeAggregateOrderBy
  createdTenantRolesAggregate: TenantRoleAggregateOrderBy
  createdTenantsAggregate: TenantAggregateOrderBy
  createdTransactionsAggregate: TransactionAggregateOrderBy
  createdUsersAggregate: UserAggregateOrderBy
  deletedAt: OrderBy
  eventApprovalStepNotifieesAggregate: EventApprovalStepNotifieesAggregateOrderBy
  eventApprovalStepValidatorsAggregate: EventApprovalStepValidatorsAggregateOrderBy
  eventJoinsAggregate: EventJoinAggregateOrderBy
  firstName: OrderBy
  followingAggregate: FollowAggregateOrderBy
  hiddenAt: OrderBy
  id: OrderBy
  initiatedTransactionsAggregate: TransactionAggregateOrderBy
  isBot: OrderBy
  isDarkModePreferred: OrderBy
  isDataAnonymizedOnDeactivation: OrderBy
  isDataExportedOnDeactivation: OrderBy
  isIntroductionFinished: OrderBy
  isOnboardingFinished: OrderBy
  lastName: OrderBy
  middleNames: OrderBy
  missionJoinsAggregate: MissionJoinAggregateOrderBy
  passwordHash: OrderBy
  points: OrderBy
  pointsProcessedActionsAggregate: ActionAggregateOrderBy
  pointsProcessedMissionJoinsAggregate: MissionJoinAggregateOrderBy
  processedEventJoinsAggregate: EventJoinAggregateOrderBy
  processedExpensesAggregate: ExpenseAggregateOrderBy
  processedMissionJoinsAggregate: MissionJoinAggregateOrderBy
  processedParticipationEventJoinsAggregate: EventJoinAggregateOrderBy
  processedReceivedAmountGrantAllocatesAggregate: GrantAllocateAggregateOrderBy
  processedReceivedAmountGrantsAggregate: GrantAggregateOrderBy
  processedTeamJoinsAggregate: TeamJoinAggregateOrderBy
  slug: OrderBy
  supervisedEventsAggregate: EventSupervisorAggregateOrderBy
  teamJoinsAggregate: TeamJoinAggregateOrderBy
  teamMembershipsAggregate: TeamMemberAggregateOrderBy
  tenantMemberRolesAggregate: TenantMemberRoleAggregateOrderBy
  tenantMembershipsAggregate: TenantMemberAggregateOrderBy
  tenantScope: TenantOrderBy
  tenantScopeId: OrderBy
}

# primary key columns input for table: user
input UserPkColumnsInput {
  id: bigint!
}

# select columns of table "user"
enum UserSelectColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  firstName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isBot

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished

  # column name
  lastName

  # column name
  middleNames

  # column name
  passwordHash

  # column name
  points

  # column name
  slug

  # column name
  tenantScopeId
}

# select "userAggregateBoolExpBool_andArgumentsColumns" columns of table "user"
enum UserSelectColumnUserAggregateBoolExpBool_andArgumentsColumns {
  # column name
  isBot

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished
}

# select "userAggregateBoolExpBool_orArgumentsColumns" columns of table "user"
enum UserSelectColumnUserAggregateBoolExpBool_orArgumentsColumns {
  # column name
  isBot

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished
}

# input type for updating data in table "user"
input UserSetInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  isBot: Boolean
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: [String!]
  passwordHash: String
  points: Float
  slug: String
  tenantScopeId: bigint
}

# aggregate stddev on columns
type UserStddevFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by stddev() on columns of table "user"
input UserStddevOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevPop on columns
type UserStddevPopFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by stddevPop() on columns of table "user"
input UserStddevPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# aggregate stddevSamp on columns
type UserStddevSampFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by stddevSamp() on columns of table "user"
input UserStddevSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# Streaming cursor of the table "user"
input UserStreamCursorInput {
  # Stream column input with initial value
  initialValue: UserStreamCursorValueInput!

  # cursor ordering
  ordering: CursorOrdering
}

# Initial value of the column from where the streaming should start
input UserStreamCursorValueInput {
  actorId: bigint
  createdAt: timestamptz
  createdById: bigint
  deletedAt: timestamptz
  firstName: String
  hiddenAt: timestamptz
  id: bigint
  isBot: Boolean
  isDarkModePreferred: Boolean
  isDataAnonymizedOnDeactivation: Boolean
  isDataExportedOnDeactivation: Boolean
  isIntroductionFinished: Boolean
  isOnboardingFinished: Boolean
  lastName: String
  middleNames: [String!]
  passwordHash: String
  points: Float
  slug: String
  tenantScopeId: bigint
}

# aggregate sum on columns
type UserSumFields {
  actorId: bigint
  createdById: bigint
  id: bigint
  points: Float
  tenantScopeId: bigint
}

# order by sum() on columns of table "user"
input UserSumOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# update columns of table "user"
enum UserUpdateColumn {
  # column name
  actorId

  # column name
  createdAt

  # column name
  createdById

  # column name
  deletedAt

  # column name
  firstName

  # column name
  hiddenAt

  # column name
  id

  # column name
  isBot

  # column name
  isDarkModePreferred

  # column name
  isDataAnonymizedOnDeactivation

  # column name
  isDataExportedOnDeactivation

  # column name
  isIntroductionFinished

  # column name
  isOnboardingFinished

  # column name
  lastName

  # column name
  middleNames

  # column name
  passwordHash

  # column name
  points

  # column name
  slug

  # column name
  tenantScopeId
}

input UserUpdates {
  # increments the numeric columns with given value of the filtered values
  _inc: UserIncInput

  # sets the columns of the filtered rows to the given values
  _set: UserSetInput

  # filter the rows which have to be updated
  where: UserBoolExp!
}

# aggregate variance on columns
type UserVarianceFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by variance() on columns of table "user"
input UserVarianceOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varPop on columns
type UserVarPopFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by varPop() on columns of table "user"
input UserVarPopOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

# aggregate varSamp on columns
type UserVarSampFields {
  actorId: Float
  createdById: Float
  id: Float
  points: Float
  tenantScopeId: Float
}

# order by varSamp() on columns of table "user"
input UserVarSampOrderBy {
  actorId: OrderBy
  createdById: OrderBy
  id: OrderBy
  points: OrderBy
  tenantScopeId: OrderBy
}

