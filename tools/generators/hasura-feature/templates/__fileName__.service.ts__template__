import { RequestContext } from '<% for(const _ of Array.from({ length: subfolder.split('/').length-1 })) { %>../<% } %>../../shards/abstract/request-context';
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { HasuraService } from '<% for(const _ of Array.from({ length: subfolder.split('/').length-1 })) { %>../<% } %>../../global/hasura/hasura.service';
import { BadRequestException, Injectable } from '@nestjs/common';
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { <%= className %>Repository } from '@okampus/api/dal';
import type { ValueTypes } from '@okampus/shared/graphql';

@Injectable()
export class <%= pluralClassName %>Service extends RequestContext {
  constructor(
    private readonly <%= propertyName %>Repository: <%= className %>Repository,
    private readonly hasuraService: HasuraService
  ) { 
    super(); 
  }

  validateProps(props: ValueTypes['<%= className %>IncInput']) {
    // Custom logic
    return true;
  }

  async insert<%= className %>(
    selectionSet: string[],
    objects: Array<ValueTypes['<%= className %>InsertInput']>,
    onConflict?: ValueTypes['<%= className %>OnConflict']
  ) {
    const arePropsValid = await objects.every((object) => this.validateProps(object));
    if (!arePropsValid) throw new BadRequestException('Cannot insert <%= className %> with invalid props.');

    const data = await this.hasuraService.insert('insert<%= className %>', selectionSet, objects, onConflict);
    // Custom logic
    return data.insert<%= className %>;
  }

  async update<%= className %>(
    selectionSet: string[],
    where: ValueTypes['<%= className %>BoolExp'],
    _set: ValueTypes['<%= className %>SetInput'],
  ) {
    const arePropsValid = this.validateProps(_set);
    if (!arePropsValid) throw new BadRequestException('Cannot update <%= className %> with invalid props.');

    const data = await this.hasuraService.update('update<%= className %>', selectionSet, where, _set);
    // Custom logic
    return data.update<%= className %>;
  }

  async find<%= className %>(
    selectionSet: string[],
    where: ValueTypes['<%= className %>BoolExp'],
    orderBy?: Array<ValueTypes['<%= className %>OrderBy']>,
    distinctOn?: Array<ValueTypes['<%= className %>SelectColumn']>,
    limit?: number,
    offset?: number,
  ) {
    // Custom logic
    const data = await this.hasuraService.find('<%= propertyName %>', selectionSet, where, orderBy, distinctOn, limit, offset);
    return data.<%= propertyName %>;
  }

  async find<%= className %>ByPk(
    selectionSet: string[],
    <% for(const pk of pkColumns) { %> <%= pk %>: string, <% } %>
  ) {
    // Custom logic
    const data = await this.hasuraService.findByPk('<%= propertyName %>ByPk', selectionSet, { <% for(const pk of pkColumns) { %> <%= pk %>, <% } %> });
    return data.<%= propertyName %>ByPk;
  }

  async update<%= className %>ByPk(
    selectionSet: string[],
    pkColumns: ValueTypes['<%= className %>PkColumnsInput'],
    _set: ValueTypes['<%= className %>SetInput'],
  ) {
    const arePropsValid = await this.validateProps(_set);
    if (!arePropsValid) throw new BadRequestException('Cannot update <%= className %> with invalid props.');

    const data = await this.hasuraService.updateByPk('update<%= className %>ByPk', selectionSet, pkColumns, _set);
    // Custom logic
    return data.update<%= className %>ByPk;
  }

  async aggregate<%= className %>(
    selectionSet: string[],
    where: ValueTypes['<%= className %>BoolExp'],
    orderBy?: Array<ValueTypes['<%= className %>OrderBy']>,
    distinctOn?: Array<ValueTypes['<%= className %>SelectColumn']>,
    limit?: number,
    offset?: number
  ) {
    // Custom logic
    const data = await this.hasuraService.aggregate('<%= propertyName %>Aggregate', selectionSet, where, orderBy, distinctOn, limit, offset);
    return data.<%= propertyName %>Aggregate;
  }
}